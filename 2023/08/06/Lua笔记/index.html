<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Lua笔记 | AmeのBlog</title><meta name="author" content="Ame"><meta name="copyright" content="Ame"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Lua笔记"><meta name="application-name" content="Lua笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Lua笔记"><meta property="og:url" content="http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/index.html"><meta property="og:site_name" content="AmeのBlog"><meta property="og:description" content="Lua笔记第一个 Lua 程序  交互式编程Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。 Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用： 123$ lua -i $ Lua 5.3.0  Copyright (C) 1994-2015 Lua.or"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cn.mcecy.com/image/20231229/2e2933416d77bbc721603da53c02025a.webp?_r_=33c48a4b-31d1-3f62-9619-e53f1a18441b"><meta property="article:author" content="Ame"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cn.mcecy.com/image/20231229/2e2933416d77bbc721603da53c02025a.webp?_r_=33c48a4b-31d1-3f62-9619-e53f1a18441b"><meta name="description" content="Lua笔记第一个 Lua 程序  交互式编程Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。 Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用： 123$ lua -i $ Lua 5.3.0  Copyright (C) 1994-2015 Lua.or"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8e4110517d1babfcceed4ddebc854947";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: undefined,
  LA51: undefined,
  greetingBox: {"enable":true,"default":"你好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://comment.486916.xyz',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":3000,"accessToken":"","mailMd5":"a1a1121ffa2761089a6da5ece364f475"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":100,"position":"top","messagePrev":"距离文章发布已过去","messageNext":"天，文章内容可能过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Ame","link":"链接: ","source":"来源: AmeのBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'AmeのBlog',
  title: 'Lua笔记',
  postAI: '',
  pageFillDescription: 'Lua笔记, 第一个 Lua 程序, 交互式编程, 脚本式编程, 注释, 单行注释, 多行注释, 标示符, 关键词, 全局变量, Lua 数据类型, nil（空）, boolean（布尔）, number（数字）, string（字符串）, table（表）, function（函数）, thread（线程）, userdata（自定义类型）, Lua 变量, 赋值语句, 索引, Lua 循环, 循环控制语句, 无限循环, Lua 流程控制, Lua 函数, 函数定义, 多返回值, 可变参数, Lua 运算符, 算术运算符, 实例, 关系运算符, 实例, 逻辑运算符, 实例, 其他运算符, 实例, 运算符优先级, 实例, Lua 字符串, 字符串长度计算, 字符串操作, 字符串截取, 字符串大小写转换, 字符串查找与反转, 字符串格式化, 字符与整数相互转换, 其他常用函数, 匹配模式, Lua 数组, 一维数组, 多维数组, Lua 迭代器, 泛型 for 迭代器, 无状态的迭代器, 多状态的迭代器, Lua table(表), table(表)的构造, Table 操作, Table 连接, 插入和移除, Table 排序, Table 最大值, Lua 模块与包, require 函数, 加载机制, C 包, Lua 元表(Metatable), __index 元方法, 总结, __newindex 元方法, 为表添加操作符, __call 元方法, __tostring 元方法, Lua 协同程序(coroutine), 什么是协同(coroutine)？, 基本语法, 生产者-消费者问题, 线程和协同程序区别, Lua 文件 Ix2FO, 简单模式, 完全模式, Lua 错误处理, 语法错误, 运行错误, 错误处理, error函数, pcall 和 xpcall、debug, Lua 调试(Debug), 调试类型, Lua 垃圾回收, 垃圾回收器函数, Lua 面向对象, 面向对象特征, Lua 中面向对象, 一个简单实例, 创建对象, 访问属性, 访问成员函数, 完整实例, Lua 继承, 完整实例, 函数重写, Lua 数据库访问笔记第一个程序交互式编程提供了交互式编程模式我们可以在命令行中输入程序并立即查看效果交互式编程模式可以通过命令或来启用在命令行中输入以下命令接着我们按下回车键输出结果如下脚本式编程我们可以将程序代码保存到一个以结尾的文件并执行该模式称为脚本式编程如我们将如下代码存储在名为的脚本文件中使用名执行以上脚本输出结果为我们也可以将代码修改为如下形式来执行脚本在开头添加实例以上代码中我们指定了的解释器加上号标记解释器会忽略它接下来我们为脚本添加可执行权限并执行注释单行注释两个减号是单行注释多行注释多行注释多行注释标示符标示符用于定义一个变量函数获取其他用户定义的项标示符以一个字母到或到或下划线开头后加上个或多个字母下划线数字到最好不要使用下划线加大写字母的标示符因为的保留字也是这样的不允许使用特殊字符如和来定义标示符是一个区分大小写的编程语言因此在中与是两个不同的标示符以下列出了一些正确的标示符关键词以下列出了的保留关键词保留关键字不能作为常量或变量或其他用户自定义标示符一般约定以下划线开头连接一串大写字母的名字比如被保留用于内部全局变量全局变量在默认情况下变量总是认为是全局的全局变量不需要声明给一个变量赋值后即创建了这个全局变量访问一个没有初始化的全局变量也不会出错只不过得到的结果是如果你想删除一个全局变量只需要将变量赋值为这样变量就好像从没被使用过一样换句话说当且仅当一个变量不等于时这个变量即存在数据类型是动态类型语言变量不要类型定义只需要为变量赋值值可以存储在变量中作为参数传递或结果返回中有个基本类型分别为和数据类型描述这个最简单只有值属于该类表示一个无效值在条件表达式中相当于包含两个值和表示双精度类型的实浮点数字符串由一对双引号或单引号来表示由或编写的函数表示任意存储在变量中的数据结构表示执行的独立线路用于执行协同程序中的表其实是一个关联数组数组的索引可以是数字字符串或表类型在里的创建是通过构造表达式来完成最简单构造表达式是用来创建一个空表我们可以使用函数测试给定变量或者值的类型实例空类型表示一种没有任何有效值它只有一个值例如打印一个没有赋值的变量便会输出一个值对于全局变量和还有一个删除作用给全局变量或者表里的变量赋一个值等同于把它们删掉执行下面代码就知作比较时应该加上双引号结果为的原因是实质是返回的字符串是一个类型布尔类型只有两个可选值真和假把和看作是其他的都为数字也是实例至少有一个是和都为数字是数字为以上代码执行结果如下和都为数字是数字默认只有一种类型双精度类型默认类型可以修改里的定义以下几种写法都被看作是类型实例以上代码执行结果字符串字符串由一对双引号或单引号来表示也可以用个方括号来表示一块字符串实例菜鸟教程以下代码执行结果为菜鸟教程在对一个数字字符串上进行算术操作时会尝试将这个数字字符串转成一个数字以上代码中执行报错了字符串连接使用的是如使用来计算字符串的长度放在字符串前面如下实例实例表在里的创建是通过构造表达式来完成最简单构造表达式是用来创建一个空表也可以在表里添加一些数据直接初始化表实例创建一个空的直接初始表中的表其实是一个关联数组数组的索引可以是数字或者是字符串实例脚本文件脚本执行结果为不同于其他语言的数组把作为数组的初始索引在里表的默认初始索引一般以开始实例脚本文件脚本执行结果为不会固定长度大小有新数据添加时长度会自动增长没初始的都是实例脚本文件脚本执行结果为函数在中函数是被看作是第一类值函数可以存在变量里实例脚本文件脚本执行结果为可以以匿名函数的方式通过参数传递实例脚本文件匿名函数脚本执行结果为线程在里最主要的线程是协同程序它跟线程差不多拥有自己独立的栈局部变量和指令指针可以跟其他协同程序共享全局变量和其他大部分东西线程跟协程的区别线程可以同时多个运行而协程任意时刻只能运行一个并且处于运行状态的协程只有被挂起时才会暂停自定义类型是一种用户自定义数据用于表示一种由应用程序或语言库所创建的类型可以将任意的任意数据类型的数据通常是和指针存储到变量中调用变量变量在使用前需要在代码中进行声明即创建该变量编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区用于存储变量的值变量有三种类型全局变量局部变量表中的域中的变量全是全局变量哪怕是语句块或是函数里除非用显式声明为局部变量局部变量的作用域为从声明位置开始到所在语句块结束变量的默认值均为实例文件脚本全局变量局部变量全局变量局部变量局部变量对局部变量重新赋值执行以上实例输出结果为赋值语句赋值是改变一个变量的值和改变表域的最基本的方法可以对多个变量同时赋值变量列表和值列表的各个元素用逗号分开赋值语句右边的值会依次赋给左边的变量遇到赋值语句会先计算右边所有的值然后再执行赋值操作所以我们可以这样进行交换变量的值当变量个数和值的个数不一致时会一直以变量个数为基础采取以下策略变量个数值的个数按变量个数补足变量个数值的个数多余的值会被忽略实例上面最后一个例子是一个常见的错误情况注意如果要对多个变量赋值必须依次对每个变量赋值多值赋值经常用来交换变量或将函数调用返回给变量返回两个值第一个赋给第二个赋给应该尽可能的使用局部变量有两个好处避免命名冲突访问局部变量的速度比全局变量更快索引对的索引使用方括号也提供了操作当索引为字符串类型时的一种简化写法采用索引访问本质上是一个类似这样的函数调用实例循环很多情况下我们需要做一些有规律性的重复操作因此在程序中就需要重复执行某些语句一组被重复执行的语句称之为循环体能否继续重复决定循环的终止条件循环结构是在一定条件下反复执行某段程序的流程结构被反复执行的程序被称为循环体循环语句是由循环体及循环的终止条件两部分组成的语言提供了以下几种循环处理方式循环类型描述循环在条件为时让程序重复地执行某些语句执行语句前会先检查条件是否为循环重复执行指定语句重复次数可在语句中控制重复执行循环直到指定的条件为真时为止循环嵌套可以在循环内嵌套一个或多个循环语句循环控制语句循环控制语句用于控制程序的流程以实现程序的各种结构方式支持以下循环控制语句控制语句描述语句退出当前循环或语句并开始脚本执行紧接着的语句语句将程序的控制点转移到一个标签处无限循环在循环体中如果条件永远为循环语句就会永远执行下去以下以循环为例实例循环将永远执行下去流程控制编程语言流程控制语句通过程序设定一个或多个条件语句来设定在条件为时执行指定程序代码在条件为时执行其他指定代码以下是典型的流程控制流程图控制结构的条件表达式结果可以是任何值认为和为假和非为真要注意的是中为实例为为以上代码输出结果为为提供了以下控制结构语句语句描述语句语句由一个布尔表达式作为条件判断其后紧跟其他语句组成语句语句可以与语句搭配使用在条件表达式为时执行语句代码嵌套语句你可以在或中使用一个或多个或语句函数在中函数是对语句和表达式进行抽象的主要方法既可以用来处理一些特殊的工作也可以用来计算一些值提供了许多的内建函数你可以很方便的在程序中调用它们如函数可以将传入的参数打印在控制台上函数主要有两种用途完成指定的任务这种情况下函数作为调用语句使用计算并返回值这种情况下函数作为赋值语句的表达式使用函数定义编程语言函数定义格式如下解析该参数是可选的指定函数是全局函数还是局部函数未设置该参数默认为全局函数如果你需要设置函数为局部函数需要使用关键字指定函数名称函数参数多个参数以逗号隔开函数也可以不带参数函数体函数中需要执行的代码语句块函数返回值语言函数可以返回多个值每个值以逗号隔开以下实例定义了函数参数为用于比较两值的大小并返回最大值实例函数返回两个值的最大值调用函数两值比较最大值为两值比较最大值为以上代码执行结果为两值比较最大值为两值比较最大值为中我们可以将函数作为参数传递给函数如下实例实例这是打印函数调用传递的函数参数函数作为参数传递以上代码执行结果为这是打印函数这是打印函数多返回值函数可以返回多个结果值比如其返回匹配串开始和结束的下标如果不存在匹配串返回函数中在后列出要返回的值的列表即可返回多值如实例最大值索引最大值以上代码执行结果为可变参数函数可以接受可变数目的参数和语言类似在函数参数列表中使用三点表示函数有可变的参数表示一个由所有变长参数构成的数组我们可以将可变参数赋值给一个变量例如我们计算几个数的平均值实例为一个表局部变量总共传入个数平均值为以上代码执行结果为总共传入个数平均值为我们也可以通过来获取可变参数的数量实例总共传入个数平均值为以上代码执行结果为总共传入个数平均值为有时候我们可能需要几个固定参数加上可变参数固定参数必须放在变长参数之前实例固定的参数没有变长参数变长参数为和输出结果为通常在遍历变长参数的时候只需要使用然而变长参数可能会包含一些那么就可以用函数来访问变长参数了或者返回可变参数的长度用于返回从起点开始到结束位置的所有参数列表调用时必须传入一个固定实参选择开关和一系列变长参数如果为数字那么返回参数列表中从索引开始到结束位置的所有参数列表否则只能为字符串这样返回变长参数的总数实例从第三个位置开始变量对应右边变量列表的第一个参数打印所有列表参数输出结果为实例获取参数总数读取参数对应的是右边变量列表的第一个参数输出结果为运算符运算符是一个特殊的符号用于告诉解释器执行特定的数学或逻辑运算提供了以下几种运算符类型算术运算符关系运算符逻辑运算符其他运算符算术运算符下表列出了语言中的常用算术运算符设定的值为的值为操作符描述实例加法输出结果减法输出结果乘法输出结果除法输出结果取余输出结果乘幂输出结果负号输出结果整除运算符输出结果实例我们可以通过以下实例来更加透彻的理解算术运算符的应用实例的值为的值为的值为的值为的值为的值为的值为以上程序执行结果为的值为的值为的值为的值为的值为的值为的值为在中用作除法运算计算结果包含小数部分用作整除运算计算结果不包含小数部分实例除法运算的值为整除运算的值为以上程序执行结果为除法运算的值为整除运算的值为关系运算符下表列出了语言中的常用关系运算符设定的值为的值为操作符描述实例等于检测两个值是否相等相等返回否则返回为不等于检测两个值是否相等不相等返回否则返回为大于如果左边的值大于右边的值返回否则返回为小于如果左边的值大于右边的值返回否则返回为大于等于如果左边的值大于等于右边的值返回否则返回返回小于等于如果左边的值小于等于右边的值返回否则返回返回实例我们可以通过以下实例来更加透彻的理解关系运算符的应用实例等于不等于不等于等于小于大于等于大于小于等于修改和的值小于等于大于等于以上程序执行结果为不等于不等于大于等于大于小于等于大于等于逻辑运算符下表列出了语言中的常用逻辑运算符设定的值为的值为操作符描述实例逻辑与操作符若为则返回否则返回为逻辑或操作符若为则返回否则返回为逻辑非操作符与逻辑运算结果相反如果条件为逻辑非为为实例我们可以通过以下实例来更加透彻的理解逻辑运算符的应用实例条件为条件为分割线修改和的值条件为条件为条件为条件为以上程序执行结果为条件为条件为分割线条件为条件为其他运算符下表列出了语言中的连接运算符与计算表或字符串长度的运算符操作符描述实例连接两个字符串其中为为输出结果为一元运算符返回字符串或表的长度返回实例我们可以通过以下实例来更加透彻的理解连接运算符与计算表或字符串长度的运算符的应用实例连接字符串和字符串长度字符串长度菜鸟教程网址长度以上程序执行结果为连接字符串和字符串长度字符串长度菜鸟教程网址长度运算符优先级从高到低的顺序除了和外所有的二元运算符都是左连接的实例我们可以通过以下实例来更加透彻的了解语言运算符的优先级实例运算值为运算值为运算值为运算值为以上程序执行结果为运算值为运算值为运算值为运算值为字符串字符串或串是由数字字母下划线组成的一串字符在中字符串是一种基本的数据类型用于存储文本数据中的字符串可以包含任意字符包括字母数字符号空格以及其他特殊字符语言中字符串可以使用以下三种方式来表示单引号间的一串字符双引号间的一串字符创建一个新的字符串并将其赋值给输出与间的一串字符以上三种方式的字符串实例如下实例字符串是字符串是教程字符串是以上代码执行输出结果为字符串是字符串是字符串是教程字符串长度计算在中要计算字符串的长度即字符串中字符的个数你可以使用函数或函数包含中文的一般用函数用于计算只包含字符串的长度实例计算字符串的长度字符个数输出以上实例的字符串只包含字符因此函数可以准确地返回字符串的长度包含中文的字符串使用函数实例世界计算字符串的长度字符个数输出函数会导致结果不准确输出输出结果为转义字符用于表示不能直接显示的字符比如后退键回车键等如在字符串转换双引号可以使用所有的转义字符和所对应的意义转义字符意义码值十进制响铃退格将当前位置移到前一列换页将当前位置移到下页开头换行将当前位置移到下一行开头回车将当前位置移到本行开头水平制表跳到下一个位置垂直制表代表一个反斜线字符代表一个单引号撇号字符代表一个双引号字符空字符到位八进制数所代表的任意字符三位八进制到位十六进制所代表的任意字符二位十六进制字符串操作提供了很多的方法来支持字符串的操作序号方法用途字符串全部转为大写字母字符串全部转为小写字母在字符串中替换为要操作的字符串为被替换的字符要替换的字符替换次数可以忽略则全部替换如在一个指定的目标字符串中搜索指定的内容如果找到了一个匹配的子串就会返回这个子串的起始索引和结束索引不存在则返回指定了搜索的起始位置默认为可以一个负数表示从后往前数的字符个数表示是否使用简单模式默认为只做简单的查找子串的操作表示使用使用正则模式匹配以下实例查找字符串的起始索引和结束索引位置字符串反转返回一个类似的格式化字符串和将整型数字转成字符并连接转换字符为整数值可以指定某个字符默认第一个字符计算字符串长度返回字符串的个拷贝链接两个字符串返回一个迭代器函数每一次调用这个函数返回一个在字符串找到的下一个符合描述的子串如果参数描述的字符串没有找到迭代函数返回只寻找源字串中的第一个配对参数可选指定搜寻过程的起点默认为在成功配对时函数将返回配对表达式中的所有捕获结果如果没有设置捕获标记则返回整个配对字符串当没有成功的配对时返回字符串截取字符串截取使用方法用于截取字符串原型为参数说明要截取的字符串截取开始位置截取结束位置默认为最后一个字符实例字符串原始字符串截取部分第个到第个第一次截取取字符串前缀第个到第个第二次截取截取最后个第三次截取索引越界输出原始字符串第四次截取以上代码执行结果为原始字符串第一次截取第二次截取第三次截取第四次截取字符串大小写转换以下实例演示了如何对字符串大小写进行转换实例以上代码执行结果为字符串查找与反转以下实例演示了如何对字符串进行查找与反转操作实例查找字符串新字符串为以上代码执行结果为新字符串为字符串格式化提供了函数来生成具有特定格式的字符串函数的第一个参数是格式之后是对应格式中每个代号的各种数据由于格式字符串的存在使得产生的长字符串可读性大大提高了这个函数的格式很像语言中的以下实例演示了如何对字符串进行格式化操作格式字符串可能包含以下的转义码接受一个数字并将其转化为码表中对应的字符接受一个数字并将其转化为有符号的整数格式接受一个数字并将其转化为八进制数格式接受一个数字并将其转化为无符号整数格式接受一个数字并将其转化为十六进制数格式使用小写字母接受一个数字并将其转化为十六进制数格式使用大写字母接受一个数字并将其转化为科学记数法格式使用小写字母接受一个数字并将其转化为科学记数法格式使用大写字母接受一个数字并将其转化为浮点数格式接受一个数字并将其转化为对应及中较短的一种格式接受一个字符串并将其转化为可安全被编译器读入的格式接受一个字符串并按照给定的参数格式化该字符串为进一步细化格式可以在号后添加参数参数将以如下的顺序读入符号一个号表示其后的数字转义符将让正数显示正号默认情况下只有负数显示符号占位符一个在后面指定了字串宽度时占位用不填时的默认占位符是空格对齐标识在指定了字串宽度时默认为右对齐增加号可以改为左对齐宽度数值小数位数字串裁切在宽度数值后增加的小数部分若后接浮点数转义符如则设定该浮点数的小数只保留位若后接字符串转义符如则设定该字符串只显示前位实例基本字符串格式化基本格式化日期格式化日期格式化十进制格式化以上代码执行结果为基本格式化日期格式化其他例子实例输出输出输出输出输出输出输出输出输出输出输出输出输出输出字符与整数相互转换以下实例演示了字符与整数相互转换实例字符转换转换第一个字符转换第三个字符转换末尾第一个字符第二个字符转换末尾第二个字符整数码转换为字符以上代码执行结果为其他常用函数以下实例演示了其他字符串操作如计算字符串长度字符串连接字符串复制等实例使用进行字符串连接连接字符串字符串长度字符串长度字符串复制次以上代码执行结果为连接字符串字符串长度匹配模式中的匹配模式直接用常规的字符串来描述它用于模式匹配函数你还可以在模式串中使用字符类字符类指可以匹配一个特定字符集合内任何字符的模式项比如字符类匹配任意数字所以你可以使用模式串搜索格式的日期实例下面的表列出了支持的所有字符类单个字符除外与该字符自身配对点与任何字符配对与任何字母配对与任何控制符配对例如与任何数字配对与任何小写字母配对与任何标点配对与空白字符配对与任何大写字母配对与任何字母数字配对与任何十六进制数配对与任何代表的字符配对此处是非字母非数字字符与字符配对主要用来处理表达式中有功能的字符的配对问题例如与配对数个字符类与任何中包含的字符类配对例如与任何字母数字或下划线符号配对数个字符类与任何不包含在中的字符类配对例如与任何非空白字符配对当上述的字符类用大写书写时表示与非此字符类的任何字符配对例如表示与任何非空白字符配对例如非字母的字符数字不是字符串结果的一部分他是返回的第二个结果代表发生替换的次数在模式匹配中有一些特殊字符他们有特殊的意义中的特殊字符如下用作特殊字符的转义字符因此匹配点匹配字符转义字符不仅可以用来转义特殊字符还可以用于所有的非字母的字符模式条目可以是单个字符类匹配该类别中任意单个字符单个字符类跟一个将匹配零或多个该类的字符这个条目总是匹配尽可能长的串单个字符类跟一个将匹配一或更多个该类的字符这个条目总是匹配尽可能长的串单个字符类跟一个将匹配零或更多个该类的字符和不同这个条目总是匹配尽可能短的串单个字符类跟一个将匹配零或一个该类的字符只要有可能它会匹配一个这里的可以从到这个条目匹配一个等于号捕获物后面有描述的子串这里的和是两个明确的字符这个条目匹配以开始结束且其中和保持平衡的字符串意思是如果从左到右读这个字符串对每次读到一个就读到一个就最终结束处的那个是第一个记数到的举个例子条目可以匹配到括号平衡的表达式指边境模式这个条目会匹配到一个位于内某个字符之前的一个空串且这个位置的前一个字符不属于集合的含义如前面所述匹配出的那个空串之开始和结束点的计算就看成该处有个字符一样模式模式指一个模式条目的序列在模式最前面加上符号将锚定从字符串的开始处做匹配在模式最后面加上符号将使匹配过程锚定到字符串的结尾如果和出现在其它位置它们均没有特殊含义只表示自身捕获模式可以在内部用小括号括起一个子模式这些子模式被称为捕获物当匹配成功时由捕获物匹配到的字符串中的子串被保存起来用于未来的用途捕获物以它们左括号的次序来编号例如对于模式字符串中匹配到的部分保存在第一个捕获物中因此是编号由匹配到的字符是号捕获物匹配到的那部分是号作为一个特例空的捕获将捕获到当前字符串的位置它是一个数字例如如果将模式作用到字符串上将产生两个捕获物和数组数组就是相同数据类型的元素按一定顺序排列的集合可以是一维数组和多维数组在中数组不是一种特定的数据类型而是一种用来存储一组值的数据结构实际上中并没有专门的数组类型而是使用一种被称为的数据结构来实现数组的功能数组的索引键值可以使用整数表示数组的大小不是固定的在索引值是以为起始但你也可以指定开始一维数组一维数组是最简单的数组其逻辑结构是线性表使用索引访问数组元素实例创建一个数组访问数组元素输出输出以上代码执行输出结果为要计算数组的长度即数组中元素的个数你可以使用操作符实例计算数组长度输出以上代码执行输出结果为一维数组可以用循环出数组中的元素如下实例实例创建一个数组循环遍历数组以上代码执行输出结果为索引默认从开始实例以上代码执行输出结果为正如你所看到的我们可以使用整数索引来访问数组元素如果指定的索引没有值则返回除此外我们还可以以负数为数组索引值实例以上代码执行输出结果为我们也可以修改数组中元素实例创建一个数组修改数组元素循环遍历数组以上代码执行输出结果为我们也可以向数组中添加元素实例创建一个数组添加新元素到数组末尾循环遍历数组以上代码执行输出结果为我们也可以删除数组中元素实例创建一个数组删除第三个元素循环遍历数组以上代码执行输出结果为多维数组多维数组即数组中包含数组或一维数组的索引键对应一个数组以下是一个三行三列的阵列多维数组实例初始化数组访问数组以上代码执行输出结果为不同索引键的三行三列阵列多维数组实例初始化数组访问数组以上代码执行输出结果为正如你所看到的以上的实例中数组设定了指定的索引值这样可以避免出现值有利于节省内存空间迭代器迭代器是一种对象它能够用来遍历标准模板库容器中的部分或全部元素每个迭代器对象代表容器中的确定的地址在中迭代器是一种支持指针类型的结构它可以遍历集合的每一个元素泛型迭代器泛型在自己内部保存迭代函数实际上它保存三个值迭代函数状态常量控制变量泛型迭代器提供了集合的对语法格式如下上面代码中为变量列表为表达式列表查看以下实例实例以上代码执行输出结果为以上实例中我们使用了默认提供的迭代函数下面我们看看泛型的执行过程首先初始化计算后面表达式的值表达式应该返回泛型需要的三个值迭代函数状态常量控制变量与多值赋值一样如果表达式返回的结果个数不足三个会自动用补足多出部分会被忽略第二将状态常量和控制变量作为参数调用迭代函数注意对于结构来说状态常量没有用处仅仅在初始化时获取他的值并传递给迭代函数第三将迭代函数返回的值赋给变量列表第四如果返回的第一个值为循环结束否则执行循环体第五回到第二步再次调用迭代函数在中我们常常使用函数来描述迭代器每次调用该函数就返回集合的下一个元素的迭代器包含以下两种类型无状态的迭代器多状态的迭代器无状态的迭代器无状态的迭代器是指不保留任何状态的迭代器因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价每一次迭代迭代函数都是用两个变量状态常量和控制变量的值作为参数被调用一个无状态的迭代器只利用这两个值可以获取下一个元素这种无状态迭代器的典型的简单的例子是它遍历数组的每一个元素元素的索引需要是数值以下实例我们使用了一个简单的函数来实现迭代器实现数字的平方实例以上实例输出结果为迭代的状态包括被遍历的表循环过程中不会改变的状态常量和当前的索引下标控制变量和迭代函数都很简单我们在中可以这样实现实例当调用开始循环时他获取三个值迭代函数状态常量控制变量初始值然后调用返回除非第二次迭代调用返回直到第一个元素多状态的迭代器很多情况下迭代器需要保存多个状态信息而不是简单的状态常量和控制变量最简单的方法是使用闭包还有一种方法就是将所有的状态信息封装到内将作为迭代器的状态常量因为这种情况下可以将所有的信息存放在内所以迭代函数通常不需要第二个参数以下实例我们创建了自己的迭代器实例闭包函数返回迭代器的当前元素以上实例输出结果为以上实例中我们可以看到内使用了闭包函数实现计算集合大小并输出各个元素表是的一种数据结构用来帮助我们创建不同的数据类型如数组字典等使用关联型数组你可以用任意类型的值来作数组的索引但这个值不能是是不固定大小的你可以根据自己需要进行扩容也是通过来解决模块包和对象的例如表示使用来索引表的构造构造器是创建和初始化表的表达式表是特有的功能强大的东西最简单的构造函数是用来创建一个空表可以直接初始化数组初始化表指定值移除引用垃圾回收会释放内存当我们为并设置元素然后将赋值给则与都指向同一个内存如果设置为则同样能访问的元素如果没有指定的变量指向的垃圾回收机制会清理相对应的内存以下实例演示了以上的描述情况实例简单的的类型是修改前索引为的元素是索引为的元素是和的是指同一个索引为的元素是索引为的元素是修改后索引为的元素是释放变量是仍然可以访问索引为的元素是是以上代码执行结果为的类型是索引为的元素是索引为的元素是修改前索引为的元素是索引为的元素是修改前索引为的元素是修改后是索引为的元素是修改后是操作以下列出了操作常用的方法序号方法用途是连锁连接的缩写函数列出参数中指定的数组部分从位置到位置的所有元素元素间以指定的分隔符隔开在的数组部分指定位置插入值为的一个元素参数可选默认为数组部分末尾指定中所有正数值中最大的值如果不存在值为正数的元素则返回之后该方法已经不存在了本文使用了自定义函数实现返回数组部分位于位置的元素其后的元素会被前移参数可选默认为长度即从最后一个元素删起对给定的进行升序排序接下来我们来看下这几个方法的实例连接我们可以使用输出一个列表中元素连接成的字符串实例返回连接后的字符串连接后的字符串指定连接字符连接后的字符串指定索引来连接连接后的字符串执行以上代码输出结果为连接后的字符串连接后的字符串连接后的字符串插入和移除以下实例演示了的插入和移除操作实例在末尾插入索引为的元素为在索引为的键处插入索引为的元素为最后一个元素为移除后最后一个元素为执行以上代码输出结果为索引为的元素为索引为的元素为最后一个元素为移除后最后一个元素为排序以下实例演示了方法的使用用于对进行排序实例排序前排序后执行以上代码输出结果为排序前排序后最大值在之后该方法已经不存在了我们定义了方法来实现以下实例演示了如何获取中的最大值实例最大值长度执行以上代码输出结果为最大值长度注意当我们获取的长度的时候无论是使用还是其都会在索引中断的地方停止计数而导致无法正确取得的长度可以使用以下方法来代替模块与包模块类似于一个封装库从开始加入了标准的模块管理机制可以把一些公用的代码放在一个文件里以接口的形式在其他地方调用有利于代码的重用和降低代码耦合度的模块是由变量函数等已知元素组成的因此创建一个模块很简单就是创建一个然后把需要导出的常量函数放入其中最后返回这个就行以下为创建自定义模块文件代码格式如下文件名为定义一个名为的模块定义一个常量这是一个常量定义一个函数这是一个公有函数这是一个私有函数由上可知模块的结构就是一个的结构因此可以像操作调用里的元素那样来操作调用模块里的常量或函数上面的声明为程序块的局部变量即表示一个私有函数因此是不能从外部访问模块里的这个私有函数必须通过模块里的公有函数来调用函数提供了一个名为的函数用来加载模块要加载一个模块只需要简单地调用就可以了例如模块名或者模块名执行后会返回一个由模块常量或函数组成的并且还会定义一个包含该的全局变量文件文件模块为上文提到到以上代码执行结果为这是一个常量这是一个私有函数或者给加载的模块定义一个别名变量方便调用文件文件模块为上文提到到别名变量以上代码执行结果为这是一个常量这是一个私有函数加载机制对于自定义的模块模块文件不是放在哪个文件目录都行函数有它自己的文件路径加载策略它会尝试从文件或程序库中加载模块用于搜索文件的路径是存放在全局变量中当启动后会以环境变量的值来初始这个环境变量如果没有找到该环境变量则使用一个编译时定义的默认路径来初始化当然如果没有这个环境变量也可以自定义设置在当前用户根目录下打开文件没有则创建打开文件也可以例如把路径加入环境变量里文件路径以号分隔最后的个表示新加的路径后面加上原来的默认路径接着更新环境变量参数使之立即生效这时假设的值是那么调用时就会尝试打开以下文件目录去搜索目标如果找过目标文件则会调用来加载模块否则就会去找程序库搜索的文件路径是从全局变量获取而这个变量则是通过环境变量来初始搜索的策略跟上面的一样只不过现在换成搜索的是或类型的文件如果找得到那么就会通过来加载它包和是很容易结合的使用为写包与中写包不同包在使用以前必须首先加载并连接在大多数系统中最容易的实现方式是通过动态连接库机制在一个叫的函数内提供了所有的动态连接的功能这个函数有两个参数库的绝对路径和初始化函数所以典型的调用的例子如下函数加载指定的库并且连接到然而它并不打开库也就是说没有调用初始化函数反之他返回初始化函数作为的一个函数这样我们就可以直接在中调用他如果加载动态库或者查找初始化函数时出错将返回和错误信息我们可以修改前面一段代码使其检测错误然后调用初始化函数或者这是平台下真正打开库一般情况下我们期望二进制的发布库包含一个与前面代码段相似的文件安装二进制库的时候可以随便放在某个目录只需要修改文件对应二进制库的实际路径即可将文件所在的目录加入到这样设定后就可以使用函数加载库了元表在中我们可以访问对应的来得到值但是却无法对两个进行操作比如相加因此提供了元表允许我们改变的行为每个行为关联了对应的元方法例如使用元表我们可以定义如何计算两个的相加操作当试图对两个表进行相加时先检查两者之一是否有元表之后检查是否有一个叫的字段若找到则调用对应的值等即时字段其对应的值往往是一个函数或是就是元方法有两个很重要的函数来处理元表对指定设置元表如果元表中存在键值会失败返回对象的元表以下实例演示了如何对指定的表设置元表普通表元表把设为的元表以上代码也可以直接写成一行以下为返回对象元表这会返回元方法这是最常用的键当你通过键来访问的时候如果这个键没有值那么就会寻找该的假定有中的键如果包含一个表格会在表格中查找相应的键我们可以在使用命令进入交互模式查看如果包含一个函数的话就会调用那个函数和键会作为参数传递给函数元方法查看表中元素是否存在如果不存在返回结果为如果存在则由返回结果实例实例输出结果为实例解析表赋值为设置了元表元方法为在表中查找如果找到返回该元素找不到则继续在表中查找如果找到返回找不到则继续判断元表有没有方法如果方法是一个函数则调用该函数元方法中查看是否传入键的参数已设置如果传入参数返回否则返回对应的键值我们可以将以上代码简单写成总结查找一个表元素时的规则其实就是如下个步骤在表中查找如果找到返回该元素找不到则继续判断该表是否有元表如果没有元表返回有元表则继续判断元表有没有方法如果方法为则返回如果方法是一个表则重复如果方法是一个函数则返回该函数的返回值该部分内容来自作者寰子元方法元方法用来对表更新则用来对表访问当你给表的一个缺少的索引赋值解释器就会查找元方法如果存在则调用这个函数而不进行赋值操作以下实例演示了元方法的应用实例新值新值以上实例执行输出结果为新值新值以上实例中表设置了元方法在对新索引键赋值时新值会调用元方法而不进行赋值而如果对已存在的索引键则会进行赋值而不调用元方法以下实例使用了函数来更新表实例以上实例执行输出结果为为表添加操作符以下实例演示了两表相加操作实例计算表中最大值在以上版本中已无法使用自定义计算表中最大键值函数即返回表最大键值两表相加操作以上实例执行输出结果为键包含在元表中并进行相加操作表中对应的操作列表如下注意是两个下划线模式描述对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符对应的运算符元方法元方法在调用一个值时调用以下实例演示了计算表中元素的和实例计算表中最大值在以上版本中已无法使用自定义计算表中最大键值函数即计算表的元素个数定义元方法以上实例执行输出结果为元方法元方法用于修改表的输出行为以下实例我们自定义了表的输出内容实例表所有元素的和为以上实例执行输出结果为表所有元素的和为从本文中我们可以知道元表可以很好的简化我们的代码功能所以了解的元表可以让我们写出更加简单优秀的代码协同程序什么是协同协同程序与线程比较类似拥有独立的堆栈独立的局部变量独立的指令指针同时又与其它协同程序共享全局变量和其它大部分东西协同程序可以理解为一种特殊的线程可以暂停和恢复其执行从而允许非抢占式的多任务处理协同是非常强大的功能但是用起来也很复杂基本语法同程序由模块提供支持使用协同程序你可以在函数中使用创建一个新的协同程序对象并使用启动它的执行协同程序可以通过调用来主动暂停自己的执行并将控制权交还给调用者方法描述创建返回参数是一个函数当和配合使用的时候就唤醒函数调用重启和配合使用挂起将设置为挂起状态这个和配合使用能有很多有用的效果查看的状态注的状态有三种具体什么时候有这样的状态请参考下面的程序创建返回一个函数一旦你调用这个函数就进入和功能重复返回正在跑的一个就是一个线程当使用的时候就是返回一个的线程号以下实例演示了如何使用协同程序实例协同程序开始执行暂停的执行协同程序恢复执行传入的值为协同程序结束执行创建协同程序启动协同程序输出暂停的执行恢复协同程序的执行并传入一个值输出协同程序恢复执行传入的值为以上实例中我们定义了一个名为的函数作为协同程序在函数中我们使用暂停了协同程序的执行并返回了一个值在主程序中我们使用创建了一个协同程序对象并使用启动了它的执行在第一次调用后协同程序执行到处暂停并将值返回给主程序然后我们再次调用并传入一个值作为协同程序恢复执行时的参数执行以上代码输出结果为协同程序开始执行暂停的执行协同程序恢复执行传入的值为协同程序结束执行需要注意的是协同程序的状态可以通过函数获取通过检查状态可以确定协同程序的执行情况如运行中已挂起已结束等以下实例演示了以上各个方法的用法实例文件创建了一个新的协同程序对象其中协同程序函数打印传入的参数使用启动协同程序的执行并传入参数协同程序开始执行打印输出为通过检查协同程序的状态输出为表示协同程序已经执行完毕使用创建了一个协同程序包装器将协同程序函数转换为一个可直接调用的函数对象创建了另一个协同程序对象其中的协同程序函数通过循环打印数字到在循环到的时候输出当前协同程序的状态和正在运行的线程连续调用启动协同程序的执行通过检查协同程序的状态输出为表示协同程序暂停执行以上实例执行输出结果为就可以看出来在底层实现就是一个线程当一个的时候就是在新线程中注册了一个事件当使用触发事件的时候的函数就被执行了当遇到的时候就代表挂起当前线程等候再次触发事件接下来我们分析一个更详细的实例实例函数输出返回的值第一次协同程序执行输出第二次协同程序执行输出的值为第一次调用协同程序时传入第三次协同程序执行输出结束协同程序的值为第二次调用协同程序时传入分割线分割线分割线分割线以上实例执行输出结果为第一次协同程序执行输出函数输出分割线第二次协同程序执行输出分割线第三次协同程序执行输出结束协同程序分割线分割线以上实例接下如下调用将协同程序唤醒操作成功返回否则返回协同程序运行运行到语句挂起协同程序第一次返回注意此处返回参数是的参数第二次再次唤醒协同程序注意此处的参数中除了第一个参数剩下的参数将作为的参数返回协同程序继续运行如果使用的协同程序继续运行完成后继续调用方法则输出和的配合强大之处在于处于主程中它将外部状态数据传入到协同程序内部而则将内部的状态数据返回到主程中生产者消费者问题现在我就使用的协同程序来完成生产者消费者这一经典问题实例将生产的物品发送给消费者从生产者那里得到物品表示需要发送的值值返回以后就挂起该协同程序启动程序以上实例执行输出结果为线程和协同程序区别线程与协同程序的主要区别在于一个具有多个线程的程序可以同时运行几个线程而协同程序却需要彼此协作的运行在任一指定时刻只有一个协同程序在运行并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起协同程序有点类似同步的多线程在等待同一个线程锁的几个线程有点类似协同主要区别归纳如下调度方式线程通常由操作系统的调度器进行抢占式调度操作系统会在不同线程之间切换执行权而协同程序是非抢占式调度的它们由程序员显式地控制执行权的转移并发性线程是并发执行的多个线程可以同时运行在多个处理器核心上或者通过时间片轮转在单个核心上切换执行协同程序则是协作式的只有一个协同程序处于运行状态其他协同程序必须等待当前协同程序主动放弃执行权内存占用线程通常需要独立的堆栈和上下文环境因此线程的创建和销毁会带来额外的开销而协同程序可以共享相同的堆栈和上下文因此创建和销毁协同程序的开销较小数据共享线程之间可以共享内存空间但需要注意线程安全性和同步问题协同程序通常通过参数传递和返回值来进行数据共享不同协同程序之间的数据隔离性较好调试和错误处理线程通常在调试和错误处理方面更复杂因为多个线程之间的交互和并发执行可能导致难以调试的问题协同程序则在调试和错误处理方面相对简单因为它们是由程序员显式地控制执行流程的总体而言线程适用于需要并发执行的场景例如在多核处理器上利用并行性加快任务的执行速度而协同程序适用于需要协作和协调的场景例如状态机事件驱动编程或协作式任务处理选择使用线程还是协同程序取决于具体的应用需求和编程模型文件库用于读取和处理文件分为简单模式和一样完全模式简单模式拥有一个当前输入文件和一个当前输出文件并且提供针对这些文件相关的操作完全模式使用外部的文件句柄来实现它以一种面对对象的形式将所有的文件操作定义为文件句柄的方法简单模式在做一些简单的文件操作时较为合适但是在进行一些高级的文件操作的时候简单模式就显得力不从心例如同时读取多个文件这样的操作使用完全模式则较为合适打开文件操作语句如下的值有模式描述以只读方式打开文件该文件必须存在打开只写文件若文件存在则文件长度清为即该文件内容会消失若文件不存在则建立该文件以附加的方式打开只写文件若文件不存在则会建立该文件如果文件存在写入的数据会被加到文件尾即文件原先的内容会被保留符保留以可读写方式打开文件该文件必须存在打开可读写文件若文件存在则文件长度清为零即该文件内容会消失若文件不存在则建立该文件与类似但此文件可读可写二进制模式如果文件是二进制文件可以加上号表示对文件既可以读也可以写简单模式简单模式使用标准的或使用一个当前输入文件和一个当前输出文件以下为文件代码操作的文件为如果没有你需要创建该文件代码如下实例以只读方式打开文件设置默认输入文件为输出文件第一行关闭打开的文件以附加的方式打开只写文件设置默认输出文件为在文件最后一行添加注释文件末尾注释关闭打开的文件执行以上代码你会发现输出了文件的第一行信息并在该文件最后一行添加了的注释如我这边输出的是文件在以上实例中我们使用了方法其中中我们没有带参数参数可以是下表中的一个模式描述读取一个数字并返回它例从当前位置读取整个文件例默认读取下一行在文件尾处返回例返回一个指定字符个数的字符串或在时返回例其他的方法有返回一个临时文件句柄该文件以更新模式打开程序结束时自动删除检测是否一个可用的文件句柄向文件写入缓冲中的所有数据返回一个迭代函数每次调用将获得文件中的一行内容当到文件尾时将返回但不关闭文件完全模式通常我们需要在同一时间处理多个文件我们需要使用来代替方法以下实例演示了如何同时处理同一个文件实例以只读方式打开文件输出文件第一行关闭打开的文件以附加的方式打开只写文件在文件最后一行添加注释关闭打开的文件执行以上代码你会发现输出了文件的第一行信息并在该文件最后一行添加了的注释如我这边输出的是文件的参数与简单模式一致其他方法设置和获取当前文件位置成功则返回最终的文件位置按字节失败则返回加错误信息参数值可以是从文件头开始从当前位置开始默认从文件尾开始默认为不带参数则返回当前位置则定位到文件头则定位到文件尾并返回文件大小向文件写入缓冲中的所有数据打开指定的文件为读模式并返回一个迭代函数每次调用将获得文件中的一行内容当到文件尾时将返回并自动关闭文件若不带参数时读取默认输入设备的内容但结束时不关闭文件如以下实例使用了方法定位到文件倒数第个位置并使用方法的参数即从当前位置倒数第个位置读取整个文件实例以只读方式打开文件关闭打开的文件我这边输出的结果是文件末尾错误处理程序运行中错误处理是必要的在我们进行文件操作数据转移及调用过程中都会出现不可预期的错误如果不注重错误信息的处理就会造成信息泄露程序无法运行等情况任何程序语言中都需要错误处理错误类型有语法错误运行错误语法错误语法错误通常是由于对程序的组件如运算符表达式使用不当引起的一个简单的实例如下文件以上代码执行结果为正如你所看到的以上出现了语法错误一个号跟两个号是有区别的一个是赋值表达式两个是比较运算另外一个实例实例执行以上程序会出现如下错误语法错误比程序运行错误更简单运行错误无法定位具体错误而语法错误我们可以很快的解决如以上实例我们只要在语句下添加即可实例运行错误运行错误是程序可以正常执行但是会输出报错信息如下实例由于参数输入错误程序执行时报错当我们编译运行以下代码时编译是可以成功的但在运行的时候会产生如下错误里调用函数时即使实参列表和形参列表不一致也能成功调用多余的参数会被舍弃缺少的参数会被补为以上报错信息是由于参数被补为后参与了运算假如函数内不是而是的话结果会变成不会报错错误处理我们可以使用两个函数和来处理错误实例如下实例不是一个数字不是一个数字执行以上程序会出现如下错误不是一个数字实例中首先检查第一个参数若没问题不做任何事情否则以第二个参数作为错误信息抛出函数语法格式功能终止正在执行的函数并返回的内容作为错误信息函数永远都不会返回通常情况下会附加一些错误位置的信息到头部参数指示获得错误的位置默认为调用位置文件行号指出哪个调用的函数的函数不添加错误位置信息和中处理错误可以使用函数来包装需要执行的代码接收一个函数和要传递给后者的参数并执行执行结果有错误无错误返回值或者或语法格式如下没有错误一些错误简单实例实例以一种保护模式来调用第一个参数因此可以捕获函数执行中的任何错误通常在错误发生时希望落得更多的调试信息而不只是发生错误的位置但返回时它已经销毁了调用桟的部分内容提供了函数接收第二个参数一个错误处理函数当错误发生时会在调用桟展开前调用错误处理函数于是就可以在这个函数中使用库来获取关于错误的额外信息了库提供了两个通用的错误处理函数提供一个提示符让用户来检查错误的原因根据调用桟来构建一个扩展的错误消息使用实例实例执行以上程序会出现如下错误调试提供了库用于提供创建我们自定义调试器的功能本身并未有内置的调试器但很多开发者共享了他们的调试器代码中库包含以下函数序号方法用途进入一个用户交互模式运行用户输入的每个字符串使用简单的命令以及其它调试设置用户可以检阅全局变量和局部变量改变变量的值计算一些表达式等等输入一行仅包含的字符串将结束这个函数这样调用者就可以继续向下运行返回对象的环境变量返回三个表示线程钩子设置的值当前钩子函数当前钩子掩码当前钩子计数返回关于一个函数信息的表你可以直接提供该函数也可以用一个数字表示该函数数字表示运行在指定线程的调用栈对应层次上的函数层表示当前函数自身层表示调用的函数除非是尾调用这种情况不计入栈等等如果是一个比活动函数数量还大的数字返回此函数返回在栈的层处函数的索引为的局部变量的名字和值这个函数不仅用于访问显式定义的局部变量也包括形参临时变量等把给定索引指向的值的元表压入堆栈如果索引无效或是这个值没有元表函数将返回并且不会向栈上压任何东西返回注册表表这是一个预定义出来的表可以用来保存任何代码想保存的值此函数返回函数的第个上值的名字和值如果该函数没有那个上值返回以开括号打头的变量名表示没有名字的变量去除了调试信息的代码块将一个函数作为钩子函数设入字符串以及数字决定了钩子将在何时调用掩码是由下列字符组合成的字符串每个字符有其含义每当调用一个函数时调用钩子每当从一个函数内返回时调用钩子每当进入新的一行时调用钩子这个函数将赋给栈上第层函数的第个局部变量如果没有那个变量函数返回如果越界抛出一个错误将的元表设为可以是返回这个函数将设为函数的第个上值如果函数没有那个上值返回否则返回该上值的名字如果有且不是字符串或函数不做任何处理直接返回否则它返回调用栈的栈回溯信息字符串可选项被添加在栈回溯信息的开头数字可选项指明从栈的哪一层开始回溯默认为即调用的那里上表列出了我们常用的调试函数接下来我们可以看些简单的例子实例执行以上代码输出结果为在以实例中我们使用到了库的和函数函数用于返回函数信息的表另一个实例我们经常需要调试函数的内的局部变量我们可以使用函数来设置这些局部变量实例如下实例执行以上代码输出结果为在以上实例中计数器在每次调用时都会自增实例中我们使用了函数查看局部变量的当前状态我们可以设置局部变量为新值实例中在设置前的值为使用函数将其设置为现在我们调用函数执行后输出为而不是调试类型命令行调试图形界面调试命令行调试器有图形界调试器有垃圾回收采用了自动内存管理这意味着你不用操心新创建的对象需要的内存如何分配出来也不用考虑在对象不再被使用后怎样释放它们所占用的内存运行了一个垃圾收集器来收集所有死对象即在中不可能再访问到的对象来完成自动内存管理的工作中所有用到的内存如字符串表用户数据函数线程内部结构等都服从自动管理实现了一个增量标记扫描收集器它使用这两个数字来控制垃圾收集循环垃圾收集器间歇率和垃圾收集器步进倍率这两个数字都使用百分数为单位例如值在内部表示垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久增大这个值会减少收集器的积极性当这个值比小的时候收集器在开启新的循环前不会有等待设置这个值为就会让收集器等到总内存使用量达到之前的两倍时才开始新的循环垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率增大这个值不仅会让收集器更加积极还会增加每个增量步骤的长度不要把这个值设得小于那样的话收集器就工作的太慢了以至于永远都干不完一个循环默认值是这表示收集器以内存分配的两倍速工作如果你把步进倍率设为一个非常大的数字比你的程序可能用到的字节数还大收集器的行为就像一个收集器接着你若把间歇率设为收集器的行为就和过去的版本一样了每次使用的内存翻倍时就做一次完整的收集垃圾回收器函数提供了以下函数用来控制自动内存管理做一次完整的垃圾收集循环通过参数它提供了一组不同的功能以字节数为单位返回使用的总内存数这个值有小数部分所以只需要乘上就能得到使用的准确字节数除非溢出重启垃圾收集器的自动运行将设为收集器的间歇率返回间歇率的前一个值返回步进倍率的前一个值单步运行垃圾收集器步长大小由控制传入时收集器步进不可分割的一步传入非值收集器收集相当于分配这些多字节内存的工作如果收集器结束一个循环将返回停止垃圾收集器的运行在调用重启前收集器只会因显式的调用运行以下演示了一个简单的垃圾回收实例实例执行以上程序输出结果如下注意内存使用的变化面向对象面向对象编程是一种非常流行的计算机编程架构以下几种编程语言都支持面向对象编程面向对象特征封装指能够把一个实体的信息功能响应都装入一个单独的对象中的特性继承继承的方法允许在不改动原程序的基础上对其进行扩充这样使得原功能得以保存而新功能也得以扩展这有利于减少重复编码提高软件的开发效率多态同一操作作用于不同的对象可以有不同的解释产生不同的执行结果在运行时可以通过指向基类的指针来调用实现派生类中的方法抽象抽象是简化复杂的现实问题的途径它可以为具体问题找到最恰当的类定义并且可以在最恰当的继承级别解释问题中面向对象我们知道对象由属性和方法组成中最基本的结构是所以需要用来描述对象的属性中的可以用来表示方法那么中的类可以通过模拟出来至于继承可以通过模拟出来不推荐用只模拟最基本的对象大部分实现够用了中的表不仅在某种意义上是一种对象像对象一样表也有状态成员变量也有与对象的值独立的本性特别是拥有两个不同值的对象代表两个不同的对象一个对象在不同的时候也可以有不同的值但他始终是一个对象与对象类似表的生命周期与其由什么创建在哪创建没有关系对象有他们的成员函数表也有这个定义创建了一个新的函数并且保存在对象的域内下面我们可以这样调用一个简单实例以下简单的类包含了三个属性和方法用于打印计算结果实例元类派生类的方法派生类的方法矩形面积为创建对象创建对象是为类的实例分配内存的过程每个类都有属于自己的内存并共享公共数据访问属性我们可以使用点号来访问类的属性访问成员函数我们可以使用冒号来访问类的成员函数内存在对象初始化时分配完整实例以下我们演示了面向对象的完整实例实例元类基础类方法基础类方法面积为创建对象执行以上程序输出结果为面积为继承继承是指一个对象直接使用另一对象的属性和方法可用于扩展基础类的属性和方法以下演示了一个简单的继承实例实例基础类方法基础类方法面积为接下来的实例对象继承了类实例完整实例以下实例我们继承了一个简单的类来扩展派生类的方法派生类中保留了继承类的成员变量和方法实例基础类方法基础类方法面积为创建对象派生类方法派生类方法正方形面积为创建对象派生类方法派生类方法矩形面积为创建对象执行以上代码输出结果为面积为正方形面积为矩形面积为函数重写中我们可以重写基础类的函数在派生类中定义自己的实现方式派生类方法正方形面积数据库访问本文主要为大家介绍数据库的操作库他是开源的支持的数据库有和本文为大家介绍的数据库连接可以使用来安装可以根据需要安装你需要的数据库驱动安装方法下安装安装不同数据库驱动你也可以使用源码安装方式源码地址连接数据库实例创建环境对象连接数据库数据库名用户名密码地址端口设置数据库的编码格式执行数据库操作文件对象的创建关闭文件对象关闭数据库连接关闭数据库环境',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-29 23:27:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 22 || hour >= 7
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/welcome.css"><link rel="stylesheet" href="/css/home.css"><link rel="stylesheet" href="/css/books.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-copymarkdown@1.0.4/lib/reprint.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pic.imgdb.cn/item/64e42d1b661c6c8e54a18cd7.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://search.ecnu.cf/" title="Google镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/google.ico" alt="Google镜像"/><span class="back-menu-item-text">Google镜像</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh.wikipedia.ecnu.cf/" title="Wikipedia镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/Wikipedia.ico" alt="Wikipedia镜像"/><span class="back-menu-item-text">Wikipedia镜像</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://hub.nuaa.cf/" title="Github镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/github.ico" alt="Github镜像"/><span class="back-menu-item-text">Github镜像</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://fastgit.282994.xyz/" title="GitHub文件加速"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/fastgit.ico" alt="GitHub文件加速"/><span class="back-menu-item-text">GitHub文件加速</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">AmeのBlog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 分享</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size: 0.9em;"></i><span> 图书</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/resources/"><i class="anzhiyufont anzhiyu-icon-inbox faa-tada" style="font-size: 0.9em;"></i><span> 资源</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=168314790&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 说说</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-calendar-days faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友链</span></a></li></ul></div></div></div><div id="nav-right"><!--if theme.nav.travelling--><!--  .nav-button.only-home#travellings_button(title='随机前往一个开往项目网站')--><!--    a.site-page(onclick='anzhiyu.totraveling()', title='随机前往一个开往项目网站', href='javascript:void(0);', rel='external nofollow', data-pjax-state='external')--><!--      i.anzhiyufont.anzhiyu-icon-train  --><div class="nav-button" id="randomPost_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button only-home" id="travellings_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Github/" style="font-size: 1.05rem;">Github<sup>2</sup></a><a href="/tags/OpenAI/" style="font-size: 1.05rem;">OpenAI<sup>1</sup></a><a href="/tags/PyTorch/" style="font-size: 1.05rem;">PyTorch<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>13</sup></a><a href="/tags/SpaceX/" style="font-size: 1.05rem;">SpaceX<sup>2</sup></a><a href="/tags/Windows/" style="font-size: 1.05rem;">Windows<sup>1</sup></a><a href="/tags/huggingface/" style="font-size: 1.05rem;">huggingface<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">云服务<sup>2</sup></a><a href="/tags/%E5%8E%9F%E7%A5%9E/" style="font-size: 1.05rem;">原神<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">图床<sup>3</sup></a><a href="/tags/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/" style="font-size: 1.05rem;">圆锥曲线<sup>4</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC/" style="font-size: 1.05rem;">安知鱼<sup>6</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 1.05rem;">小说<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>1</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 1.05rem;">硬件<sup>2</sup></a><a href="/tags/%E7%A1%AC%E7%9B%98/" style="font-size: 1.05rem;">硬盘<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 1.05rem;">网盘<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">网络<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 1.05rem;">计算机<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url">学习</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Lua笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-08-06T14:34:39.000Z" title="发表于 2023-08-06 22:34:39">2023-08-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-12-29T15:27:05.303Z" title="更新于 2023-12-29 23:27:05">2023-12-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">27.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>101分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Lua笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>成都</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2023/08/06/Lua%E7%AC%94%E8%AE%B0/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cn.mcecy.com/image/20231229/2e2933416d77bbc721603da53c02025a.webp?_r_=33c48a4b-31d1-3f62-9619-e53f1a18441b"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url">学习</a><h1 id="CrawlerTitle" itemprop="name headline">Lua笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Ame</span><time itemprop="dateCreated datePublished" datetime="2023-08-06T14:34:39.000Z" title="发表于 2023-08-06 22:34:39">2023-08-06</time><time itemprop="dateCreated datePublished" datetime="2023-12-29T15:27:05.303Z" title="更新于 2023-12-29 23:27:05">2023-12-29</time></header><h1 id="Lua笔记"><a href="#Lua笔记" class="headerlink" title="Lua笔记"></a>Lua笔记</h1><h2 id="第一个-Lua-程序"><a href="#第一个-Lua-程序" class="headerlink" title="第一个 Lua 程序"></a>第一个 Lua 程序</h2><span id="more"></span>

<h3 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h3><p>Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。</p>
<p>Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua -i </span><br><span class="line">$ Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>在命令行中，输入以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(&quot;Hello World！&quot;)</span><br></pre></td></tr></table></figure>

<p>接着我们按下回车键，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(&quot;Hello World！&quot;)</span><br><span class="line">Hello World！</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><p>我们可以将 Lua 程序代码保存到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello World！&quot;)</span><br><span class="line">print(&quot;www.runoob.com&quot;)</span><br></pre></td></tr></table></figure>

<p>使用 lua 名执行以上脚本，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua hello.lua</span><br><span class="line">Hello World！</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<p>我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;lua）：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/**local**/bin/lua</span><br><span class="line"></span><br><span class="line">print(&quot;Hello World！&quot;)</span><br><span class="line">print(&quot;www.runoob.com&quot;)</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们指定了 Lua 的解释器 &#x2F;usr&#x2F;local&#x2F;bin directory。加上 # 号标记解释器会忽略它。接下来我们为脚本添加可执行权限，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./hello.lua </span><br><span class="line">Hello World！</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>两个减号是单行注释:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--</span><br></pre></td></tr></table></figure>

<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--[[</span><br><span class="line"> 多行注释</span><br><span class="line"> 多行注释</span><br><span class="line"> --]]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h2><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 <strong>_</strong> 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。</p>
<p>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>Lua 不允许使用特殊字符如 <strong>@</strong>, <strong>$</strong>, 和 <strong>%</strong> 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Runoob 与 runoob 是两个不同的标示符。以下列出了一些正确的标示符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd         zara      abc     move_name    a_123</span><br><span class="line">myname50     _temp     j       a23b9        retVal</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>以下列出了 Lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<hr>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在默认情况下，变量总是认为是全局的。</p>
<p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(b)</span><br><span class="line">nil</span><br><span class="line">&gt; b=10</span><br><span class="line">&gt; print(b)</span><br><span class="line">10</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>如果你想删除一个全局变量，只需要将变量赋值为nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = nil</span><br><span class="line">print(b)      --&gt; nil</span><br></pre></td></tr></table></figure>

<p>这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于nil时，这个变量即存在。</p>
<hr>
<h1 id="Lua-数据类型"><a href="#Lua-数据类型" class="headerlink" title="Lua 数据类型"></a>Lua 数据类型</h1><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nil</td>
<td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">包含两个值：false和true。</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="left">userdata</td>
<td align="left">表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<p>我们可以使用 type 函数测试给定变量或者值的类型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(type(&quot;Hello world&quot;))    *--&gt; string*</span><br><span class="line">print(type(10.4*3))       *--&gt; number*</span><br><span class="line">print(type(print))        *--&gt; function*</span><br><span class="line">print(type(type))        *--&gt; function*</span><br><span class="line">print(type(true))        *--&gt; boolean*</span><br><span class="line">print(type(nil))         *--&gt; nil*</span><br><span class="line">print(type(type(X)))       *--&gt; string*</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="nil（空）"><a href="#nil（空）" class="headerlink" title="nil（空）"></a>nil（空）</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(type(a))</span><br><span class="line">nil</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tab1 = &#123; key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; &#125;</span><br><span class="line">for k, v in pairs(tab1) do</span><br><span class="line">    print(k .. &quot; - &quot; .. v)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">tab1.key1 = nil</span><br><span class="line">for k, v in pairs(tab1) do</span><br><span class="line">    print(k .. &quot; - &quot; .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>nil 作比较时应该加上双引号 <code>&quot;</code>：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; type(X)</span><br><span class="line">nil</span><br><span class="line">&gt; type(X)==nil</span><br><span class="line">false</span><br><span class="line">&gt; type(X)==&quot;nil&quot;</span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p><strong>type(X)&#x3D;&#x3D;nil</strong> 结果为 <strong>false</strong> 的原因是 type(X) 实质是返回的 <strong>“nil”</strong> 字符串，是一个 string 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(type(X))==string</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(type(true))</span><br><span class="line">print(type(false))</span><br><span class="line">print(type(nil))</span><br><span class="line"> </span><br><span class="line">if false or nil then</span><br><span class="line">    print(&quot;至少有一个是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;false 和 nil 都为 false&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if 0 then</span><br><span class="line">    print(&quot;数字 0 是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;数字 0 为 false&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lua test.lua </span><br><span class="line">boolean</span><br><span class="line">boolean</span><br><span class="line">nil</span><br><span class="line">false 和 nil 都为 false</span><br><span class="line">数字 0 是 true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(type(2))</span><br><span class="line">print(type(2.2))</span><br><span class="line">print(type(0.2))</span><br><span class="line">print(type(2e+1))</span><br><span class="line">print(type(0.2e-1))</span><br><span class="line">print(type(7.8263692594256e-06))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1 = &quot;this is string1&quot;</span><br><span class="line">string2 = &#x27;this is string2&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html = [[</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">]]</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>

<p>以下代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(&quot;2&quot; + 6)</span><br><span class="line">8.0</span><br><span class="line">&gt; print(&quot;2&quot; + &quot;6&quot;)</span><br><span class="line">8.0</span><br><span class="line">&gt; print(&quot;2 + 6&quot;)</span><br><span class="line">2 + 6</span><br><span class="line">&gt; print(&quot;-2e2&quot; * &quot;6&quot;)</span><br><span class="line">-1200.0</span><br><span class="line">&gt; print(&quot;error&quot; + 1)</span><br><span class="line">stdin:1: attempt to perform arithmetic on a string value</span><br><span class="line">stack traceback:</span><br><span class="line">        stdin:1: in main chunk</span><br><span class="line">        [C]: in ?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码中”error” + 1执行报错了，字符串连接使用的是 .. ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(&quot;a&quot; .. &#x27;b&#x27;)</span><br><span class="line">ab</span><br><span class="line">&gt; print(157 .. 428)</span><br><span class="line">157428</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>使用 # 来计算字符串的长度，放在字符串前面，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; len = &quot;www.runoob.com&quot;</span><br><span class="line">&gt; print(#len)</span><br><span class="line">14</span><br><span class="line">&gt; print(#&quot;www.runoob.com&quot;)</span><br><span class="line">14</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="table（表）"><a href="#table（表）" class="headerlink" title="table（表）"></a>table（表）</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个空的 table</span><br><span class="line">local tbl1 = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 直接初始表</span><br><span class="line">local tbl2 = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- table_test.lua 脚本文件</span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a[&quot;key&quot;] = &quot;value&quot;</span><br><span class="line">key = 10</span><br><span class="line">a[key] = 22</span><br><span class="line">a[key] = a[key] + 11</span><br><span class="line">for k, v in pairs(a) do</span><br><span class="line">    print(k .. &quot; : &quot; .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua table_test.lua </span><br><span class="line">key : value</span><br><span class="line">10 : 33</span><br></pre></td></tr></table></figure>

<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- table_test2.lua 脚本文件</span><br><span class="line">local tbl = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br><span class="line">for key, val in pairs(tbl) do</span><br><span class="line">    print(&quot;Key&quot;, key)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lua table_test2.lua </span><br><span class="line">Key    1</span><br><span class="line">Key    2</span><br><span class="line">Key    3</span><br><span class="line">Key    4</span><br></pre></td></tr></table></figure>

<p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- table_test3.lua 脚本文件</span><br><span class="line">a3 = &#123;&#125;</span><br><span class="line">for i = 1, 10 do</span><br><span class="line">    a3[i] = i</span><br><span class="line">end</span><br><span class="line">a3[&quot;key&quot;] = &quot;val&quot;</span><br><span class="line">print(a3[&quot;key&quot;])</span><br><span class="line">print(a3[&quot;none&quot;])</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua table_test3.lua </span><br><span class="line">val</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="function（函数）"><a href="#function（函数）" class="headerlink" title="function（函数）"></a>function（函数）</h2><p>在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- function_test.lua 脚本文件</span><br><span class="line">function factorial1(n)</span><br><span class="line">    if n == 0 then</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        return n * factorial1(n - 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">print(factorial1(5))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line">print(factorial2(5))</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua function_test.lua </span><br><span class="line">120</span><br><span class="line">120</span><br></pre></td></tr></table></figure>

<p>function 可以以匿名函数（anonymous function）的方式通过参数传递:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- function_test2.lua 脚本文件</span><br><span class="line">function testFun(tab,fun)</span><br><span class="line">        for k ,v in pairs(tab) do</span><br><span class="line">                print(fun(k,v));</span><br><span class="line">        end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab=&#123;key1=&quot;val1&quot;,key2=&quot;val2&quot;&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line">function(key,val)--匿名函数</span><br><span class="line">        return key..&quot;=&quot;..val;</span><br><span class="line">end</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua function_test2.lua </span><br><span class="line">key1=val1</span><br><span class="line">key2=val2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a>thread（线程）</h2><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p>
<p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p>
<hr>
<h2 id="userdata（自定义类型）"><a href="#userdata（自定义类型）" class="headerlink" title="userdata（自定义类型）"></a>userdata（自定义类型）</h2><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>
<hr>
<h1 id="Lua-变量"><a href="#Lua-变量" class="headerlink" title="Lua 变量"></a>Lua 变量</h1><p>变量在使用前，需要在代码中进行声明，即创建该变量。</p>
<p>编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</p>
<p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p>Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p>
<p>局部变量的作用域为从声明位置开始到所在语句块结束。</p>
<p>变量的默认值均为 nil。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- test.lua 文件脚本</span><br><span class="line">a = 5               -- 全局变量</span><br><span class="line">local b = 5         -- 局部变量</span><br><span class="line"></span><br><span class="line">function joke()</span><br><span class="line">    c = 5           -- 全局变量</span><br><span class="line">    local d = 6     -- 局部变量</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line">print(c,d)          --&gt; 5 nil</span><br><span class="line"></span><br><span class="line">do </span><br><span class="line">    local a = 6     -- 局部变量</span><br><span class="line">    b = 6           -- 对局部变量重新赋值</span><br><span class="line">    print(a,b);     --&gt; 6 6</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(a,b)      --&gt; 5 6</span><br></pre></td></tr></table></figure>

<p>执行以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lua test.lua </span><br><span class="line">5    nil</span><br><span class="line">6    6</span><br><span class="line">5    6</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>赋值是改变一个变量的值和改变表域的最基本的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot; .. &quot;world&quot;</span><br><span class="line">t.n = t.n + 1</span><br></pre></td></tr></table></figure>

<p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = 10, 2*x       &lt;--&gt;       a=10; b=2*x</span><br></pre></td></tr></table></figure>

<p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     -- swap &#x27;x&#x27; for &#x27;y&#x27;</span><br><span class="line">a[i], a[j] = a[j], a[i]         -- swap &#x27;a[i]&#x27; for &#x27;a[j]&#x27;</span><br></pre></td></tr></table></figure>

<p>当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 变量个数 &gt; 值的个数             按变量个数补足nil</span><br><span class="line">b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = 0, 1</span><br><span class="line">print(a,b,c)             --&gt; 0   1   nil</span><br><span class="line"> </span><br><span class="line">a, b = a+1, b+1, b+2     -- value of b+2 is ignored</span><br><span class="line">print(a,b)               --&gt; 1   2</span><br><span class="line"> </span><br><span class="line">a, b, c = 0</span><br><span class="line">print(a,b,c)             --&gt; 0   nil   nil</span><br></pre></td></tr></table></figure>

<p>上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = 0, 0, 0</span><br><span class="line">print(a,b,c)             --&gt; 0   0   0</span><br></pre></td></tr></table></figure>

<p>多值赋值经常用来交换变量，或将函数调用返回给变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = f()</span><br></pre></td></tr></table></figure>

<p>f()返回两个值，第一个赋给a，第二个赋给b。</p>
<p>应该尽可能的使用局部变量，有两个好处：</p>
<ul>
<li>避免命名冲突。</li>
<li>访问局部变量的速度比全局变量更快。</li>
</ul>
<hr>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t.i                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line">gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; site = &#123;&#125;</span><br><span class="line">&gt; site[&quot;key&quot;] = &quot;www.runoob.com&quot;</span><br><span class="line">&gt; print(site[&quot;key&quot;])</span><br><span class="line">www.runoob.com</span><br><span class="line">&gt; print(site.key)</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-循环"><a href="#Lua-循环" class="headerlink" title="Lua 循环"></a>Lua 循环</h1><p>很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。</p>
<p>一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</p>
<p>循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</p>
<p>循环语句是由循环体及循环的终止条件两部分组成的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231125/4cba73cc1f9607e5a15a44f3c82607e1.jpg"></p>
<p>Lua 语言提供了以下几种循环处理方式：</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-while-loop.html">while 循环</a></td>
<td align="left">在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-for-loop.html">for 循环</a></td>
<td align="left">重复执行指定语句，重复次数可在 for 语句中控制。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-repeat-until-loop.html">repeat…until</a></td>
<td align="left">重复执行循环，直到 指定的条件为真时为止</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-nested-loops.html">循环嵌套</a></td>
<td align="left">可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;）</td>
</tr>
</tbody></table>
<hr>
<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。</p>
<p>Lua 支持以下循环控制语句：</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-break-statement.html">break 语句</a></td>
<td align="left">退出当前循环或语句，并开始脚本执行紧接着的语句。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-goto.html">goto 语句</a></td>
<td align="left">将程序的控制点转移到一个标签处。</td>
</tr>
</tbody></table>
<hr>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while( true )</span><br><span class="line">do</span><br><span class="line">   print(&quot;循环将永远执行下去&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-流程控制"><a href="#Lua-流程控制" class="headerlink" title="Lua 流程控制"></a>Lua 流程控制</h1><p>Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。</p>
<p>以下是典型的流程控制流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231125/22b59a95458bd3f9cf3a5e912e93aa1a.jpg"></p>
<p>控制结构的条件表达式结果可以是任何值，Lua认为false和nil为假，true和非nil为真。</p>
<p>要注意的是Lua中 0 为 true：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--[ 0 为 true ]</span><br><span class="line">if(0)</span><br><span class="line">then</span><br><span class="line">    print(&quot;0 为 true&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 为 true</span><br></pre></td></tr></table></figure>

<p>Lua 提供了以下控制结构语句：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/if-statement-in-lua.html">if 语句</a></td>
<td align="left"><strong>if 语句</strong> 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/if-else-statement-in-lua.html">if…else 语句</a></td>
<td align="left"><strong>if 语句</strong> 可以与 <strong>else 语句</strong>搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/nested-if-statements-in-lua.html">if 嵌套语句</a></td>
<td align="left">你可以在<strong>if</strong> 或 <strong>else if</strong>中使用一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句 。</td>
</tr>
</tbody></table>
<hr>
<h1 id="Lua-函数"><a href="#Lua-函数" class="headerlink" title="Lua 函数"></a>Lua 函数</h1><p>在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。</p>
<p>Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。</p>
<p>Lua 函数主要有两种用途：</p>
<ul>
<li>完成指定的任务，这种情况下函数作为调用语句使用；</li>
<li>计算并返回值，这种情况下函数作为赋值语句的表达式使用。</li>
</ul>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Lua 编程语言函数定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)</span><br><span class="line">    function_body</span><br><span class="line">    return result_params_comma_separated</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li><strong>optional_function_scope:</strong> 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</li>
<li><strong>function_name:</strong> 指定函数名称。</li>
<li><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</li>
<li><strong>result_params_comma_separated:</strong> 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<p>以下实例定义了函数 **max()**，参数为 num1, num2，用于比较两值的大小，并返回最大值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--[[ 函数返回两个值的最大值 --]]</span><br><span class="line">function max(num1, num2)</span><br><span class="line"></span><br><span class="line">   if (num1 &gt; num2) then</span><br><span class="line">      result = num1;</span><br><span class="line">   else</span><br><span class="line">      result = num2;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return result; </span><br><span class="line">end</span><br><span class="line">-- 调用函数</span><br><span class="line">print(&quot;两值比较最大值为 &quot;,max(10,4))</span><br><span class="line">print(&quot;两值比较最大值为 &quot;,max(5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两值比较最大值为     10</span><br><span class="line">两值比较最大值为     6</span><br></pre></td></tr></table></figure>

<p>Lua 中我们可以将函数作为参数传递给函数，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">myprint = function(param)</span><br><span class="line">   print(&quot;这是打印函数 -   ##&quot;,param,&quot;##&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function add(num1,num2,functionPrint)</span><br><span class="line">   result = num1 + num2</span><br><span class="line">   -- 调用传递的函数参数</span><br><span class="line">   functionPrint(result)</span><br><span class="line">end</span><br><span class="line">myprint(10)</span><br><span class="line">-- myprint 函数作为参数传递</span><br><span class="line">add(2,5,myprint)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是打印函数 -   ##    10    ##</span><br><span class="line">这是打印函数 -   ##    7    ##</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; s, e = string.find(&quot;www.runoob.com&quot;, &quot;runoob&quot;) </span><br><span class="line">&gt; print(s, e)</span><br><span class="line">5    10</span><br></pre></td></tr></table></figure>

<p>Lua函数中，在return后列出要返回的值的列表即可返回多值，如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function maximum (a)</span><br><span class="line">    local mi = 1             -- 最大值索引</span><br><span class="line">    local m = a[mi]          -- 最大值</span><br><span class="line">    for i,val in ipairs(a) do</span><br><span class="line">       if val &gt; m then</span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line">    return m, mi</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(maximum(&#123;8,10,23,12,5&#125;))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23    3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 <strong>…</strong> 表示函数有可变的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">local s = 0  </span><br><span class="line">  for i, v in ipairs&#123;...&#125; do   --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s = s + v  </span><br><span class="line">  end  </span><br><span class="line">  return s  </span><br><span class="line">end  </span><br><span class="line">print(add(3,4,5,6,7))  ---&gt;25</span><br></pre></td></tr></table></figure>

<p>我们可以将可变参数赋值给一个变量。</p>
<p>例如，我们计算几个数的平均值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   result = 0</span><br><span class="line">   local arg=&#123;...&#125;    --&gt; arg 为一个表，局部变量</span><br><span class="line">   for i,v in ipairs(arg) do</span><br><span class="line">      result = result + v</span><br><span class="line">   end</span><br><span class="line">   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)</span><br><span class="line">   return result/#arg</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;平均值为&quot;,average(10,5,3,4,5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总共传入 6 个数</span><br><span class="line">平均值为    5.5</span><br></pre></td></tr></table></figure>

<p>我们也可以通过 select(“#”,…) 来获取可变参数的数量:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   result = 0</span><br><span class="line">   local arg=&#123;...&#125;</span><br><span class="line">   for i,v in ipairs(arg) do</span><br><span class="line">      result = result + v</span><br><span class="line">   end</span><br><span class="line">   print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)</span><br><span class="line">   return result/select(&quot;#&quot;,...)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;平均值为&quot;,average(10,5,3,4,5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总共传入 6 个数</span><br><span class="line">平均值为    5.5</span><br></pre></td></tr></table></figure>

<p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fwrite(fmt, ...)  ---&gt; 固定的参数fmt</span><br><span class="line">    return io.write(string.format(fmt, ...))     </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fwrite(&quot;runoob\n&quot;)       ---&gt;fmt = &quot;runoob&quot;, 没有变长参数。  </span><br><span class="line">fwrite(&quot;%d%d\n&quot;, 1, 2)   ---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>通常在遍历变长参数的时候只需要使用 <strong>{…}<strong>，然而变长参数可能会包含一些 <strong>nil</strong>，那么就可以用 <strong>select</strong> 函数来访问变长参数了：</strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p>
<ul>
<li><strong>select(‘#’, …)</strong> 返回可变参数的长度。</li>
<li><strong>select(n, …)</strong> 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li>
</ul>
<p>调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 <strong>n</strong> 开始到结束位置的所有参数列表，否则只能为字符串 **#**，这样 select 返回变长参数的总数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(...)</span><br><span class="line">    a = select(3,...)  --&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span><br><span class="line">    print (a)</span><br><span class="line">    print (select(3,...)) --&gt;打印所有列表参数</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">f(0,1,2,3,4,5)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2       3       4       5</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">do  </span><br><span class="line">    function foo(...)  </span><br><span class="line">        for i = 1, select(&#x27;#&#x27;, ...) do  --&gt;获取参数总数</span><br><span class="line">            local arg = select(i, ...); --&gt;读取参数，arg 对应的是右边变量列表的第一个参数</span><br><span class="line">            print(&quot;arg&quot;, arg);  </span><br><span class="line">        end  </span><br><span class="line">    end  </span><br><span class="line">  </span><br><span class="line">    foo(1, 2, 3, 4);  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg    1</span><br><span class="line">arg    2</span><br><span class="line">arg    3</span><br><span class="line">arg    4</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-运算符"><a href="#Lua-运算符" class="headerlink" title="Lua 运算符"></a>Lua 运算符</h1><p>运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>其他运算符</li>
</ul>
<hr>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left">A + B 输出结果 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left">A - B 输出结果 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left">A * B 输出结果 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除法</td>
<td align="left">B &#x2F; A 输出结果 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left">B % A 输出结果 0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">乘幂</td>
<td align="left">A^2 输出结果 100</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">负号</td>
<td align="left">-A 输出结果 -10</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;</td>
<td align="left">整除运算符(&gt;&#x3D;lua5.3)</td>
<td align="left"><strong>5&#x2F;&#x2F;2</strong> 输出结果 2</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解算术运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line">c = a + b</span><br><span class="line">print(&quot;Line 1 - c 的值为 &quot;, c )</span><br><span class="line">c = a - b</span><br><span class="line">print(&quot;Line 2 - c 的值为 &quot;, c )</span><br><span class="line">c = a * b</span><br><span class="line">print(&quot;Line 3 - c 的值为 &quot;, c )</span><br><span class="line">c = a / b</span><br><span class="line">print(&quot;Line 4 - c 的值为 &quot;, c )</span><br><span class="line">c = a % b</span><br><span class="line">print(&quot;Line 5 - c 的值为 &quot;, c )</span><br><span class="line">c = a^2</span><br><span class="line">print(&quot;Line 6 - c 的值为 &quot;, c )</span><br><span class="line">c = -a</span><br><span class="line">print(&quot;Line 7 - c 的值为 &quot;, c )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - c 的值为     31</span><br><span class="line">Line 2 - c 的值为     11</span><br><span class="line">Line 3 - c 的值为     210</span><br><span class="line">Line 4 - c 的值为     2.1</span><br><span class="line">Line 5 - c 的值为     1</span><br><span class="line">Line 6 - c 的值为     441</span><br><span class="line">Line 7 - c 的值为     -21</span><br></pre></td></tr></table></figure>

<p>在 lua 中，**&#x2F;** 用作除法运算，计算结果包含小数部分，**&#x2F;&#x2F;** 用作整除运算，计算结果不包含小数部分：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 2</span><br><span class="line"></span><br><span class="line">print(&quot;除法运算 - a/b 的值为 &quot;, a / b )</span><br><span class="line">print(&quot;整除运算 - a//b 的值为 &quot;, a // b )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除法运算 - a/b 的值为   2.5</span><br><span class="line">整除运算 - a//b 的值为  2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">等于，检测两个值是否相等，相等返回 true，否则返回 false</td>
<td align="left">(A &#x3D;&#x3D; B) 为 false。</td>
</tr>
<tr>
<td align="left">~&#x3D;</td>
<td align="left">不等于，检测两个值是否相等，不相等返回 true，否则返回 false</td>
<td align="left">(A ~&#x3D; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于，如果左边的值大于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt; B) 为 false。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于，如果左边的值大于右边的值，返回 false，否则返回 true</td>
<td align="left">(A &lt; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt;&#x3D; B) 返回 false。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &lt;&#x3D; B) 返回 true。</td>
</tr>
</tbody></table>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解关系运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line">if( a == b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 1 - a 等于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 1 - a 不等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if( a ~= b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 2 - a 不等于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 2 - a 等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a &lt; b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 3 - a 小于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 3 - a 大于等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a &gt; b ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 4 - a 大于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 5 - a 小于等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 修改 a 和 b 的值</span><br><span class="line">a = 5</span><br><span class="line">b = 20</span><br><span class="line">if ( a &lt;= b ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 5 - a 小于等于  b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( b &gt;= a ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 6 - b 大于等于 a&quot; )</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Line 1 - a 不等于 b</span><br><span class="line">Line 2 - a 不等于 b</span><br><span class="line">Line 3 - a 大于等于 b</span><br><span class="line">Line 4 - a 大于 b</span><br><span class="line">Line 5 - a 小于等于  b</span><br><span class="line">Line 6 - b 大于等于 a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td>
<td align="left">(A and B) 为 false。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。</td>
<td align="left">(A or B) 为 true。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td>
<td align="left">not(A and B) 为 true。</td>
</tr>
</tbody></table>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解逻辑运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a = true</span><br><span class="line">b = true</span><br><span class="line"></span><br><span class="line">if ( a and b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a and b - 条件为 true&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a or b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a or b - 条件为 true&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;---------分割线---------&quot; )</span><br><span class="line"></span><br><span class="line">-- 修改 a 和 b 的值</span><br><span class="line">a = false</span><br><span class="line">b = true</span><br><span class="line"></span><br><span class="line">if ( a and b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a and b - 条件为 true&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;a and b - 条件为 false&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( not( a and b) )</span><br><span class="line">then</span><br><span class="line">   print(&quot;not( a and b) - 条件为 true&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;not( a and b) - 条件为 false&quot; )</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a and b - 条件为 true</span><br><span class="line">a or b - 条件为 true</span><br><span class="line">---------分割线---------</span><br><span class="line">a and b - 条件为 false</span><br><span class="line">not( a and b) - 条件为 true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">..</td>
<td align="left">连接两个字符串</td>
<td align="left">a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">一元运算符，返回字符串或表的长度。</td>
<td align="left">#”Hello” 返回 5</td>
</tr>
</tbody></table>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解连接运算符与计算表或字符串长度的运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;Hello &quot;</span><br><span class="line">b = &quot;World&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;连接字符串 a 和 b &quot;, a..b )</span><br><span class="line"></span><br><span class="line">print(&quot;b 字符串长度 &quot;,#b )</span><br><span class="line"></span><br><span class="line">print(&quot;字符串 Test 长度 &quot;,#&quot;Test&quot; )</span><br><span class="line"></span><br><span class="line">print(&quot;菜鸟教程网址长度 &quot;,#&quot;www.runoob.com&quot; )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">连接字符串 a 和 b     Hello World</span><br><span class="line">b 字符串长度     5</span><br><span class="line">字符串 Test 长度     4</span><br><span class="line">菜鸟教程网址长度     14</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>从高到低的顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^</span><br><span class="line">not    - (unary)</span><br><span class="line">*      /       %</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure>

<p>除了 <strong>^</strong> 和 <strong>..</strong> 外所有的二元运算符都是左连接的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a+i &lt; b/2+1          &lt;--&gt;       (a+i) &lt; ((b/2)+1)</span><br><span class="line">5+x^2*8              &lt;--&gt;       5+((x^2)*8)</span><br><span class="line">a &lt; y and y &lt;= z     &lt;--&gt;       (a &lt; y) and (y &lt;= z)</span><br><span class="line">-x^2                 &lt;--&gt;       -(x^2)</span><br><span class="line">x^y^z                &lt;--&gt;       x^(y^z)</span><br></pre></td></tr></table></figure>

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的了解 Lua 语言运算符的优先级：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">c = 15</span><br><span class="line">d = 5</span><br><span class="line"></span><br><span class="line">e = (a + b) * c / d;-- ( 30 * 15 ) / 5</span><br><span class="line">print(&quot;(a + b) * c / d 运算值为  :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = ((a + b) * c) / d; -- (30 * 15 ) / 5</span><br><span class="line">print(&quot;((a + b) * c) / d 运算值为 :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = (a + b) * (c / d);-- (30) * (15/5)</span><br><span class="line">print(&quot;(a + b) * (c / d) 运算值为 :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = a + (b * c) / d;  -- 20 + (150/5)</span><br><span class="line">print(&quot;a + (b * c) / d 运算值为   :&quot;,e )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) * c / d 运算值为  :    90.0</span><br><span class="line">((a + b) * c) / d 运算值为 :    90.0</span><br><span class="line">(a + b) * (c / d) 运算值为 :    90.0</span><br><span class="line">a + (b * c) / d 运算值为   :    50.0</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-字符串"><a href="#Lua-字符串" class="headerlink" title="Lua 字符串"></a>Lua 字符串</h1><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。</p>
<p>在 Lua 中，字符串是一种基本的数据类型，用于存储文本数据。</p>
<p>Lua 中的字符串可以包含任意字符，包括字母、数字、符号、空格以及其他特殊字符。</p>
<p>Lua 语言中字符串可以使用以下三种方式来表示：</p>
<ul>
<li><p>单引号间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local str1 = &#x27;This is a string.&#x27;</span><br><span class="line">local str2 = &quot;This is also a string.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双引号间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local str = &quot;Hello, &quot;</span><br><span class="line">str = str .. &quot;World!&quot;  -- 创建一个新的字符串并将其赋值给str</span><br><span class="line">print(str)  -- 输出 &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local multilineString = [[</span><br><span class="line">This is a multiline string.</span><br><span class="line">It can contain multiple lines of text.</span><br><span class="line">No need for escape characters.</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line">print(multilineString)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上三种方式的字符串实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;</span><br><span class="line">print(&quot;\&quot;字符串 1 是\&quot;&quot;,string1)</span><br><span class="line">string2 = &#x27;runoob.com&#x27;</span><br><span class="line">print(&quot;字符串 2 是&quot;,string2)</span><br><span class="line"></span><br><span class="line">string3 = [[&quot;Lua 教程&quot;]]</span><br><span class="line">print(&quot;字符串 3 是&quot;,string3)</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;字符串 1 是&quot;    Lua</span><br><span class="line">字符串 2 是    runoob.com</span><br><span class="line">字符串 3 是    &quot;Lua 教程&quot;</span><br></pre></td></tr></table></figure>

<h2 id="字符串长度计算"><a href="#字符串长度计算" class="headerlink" title="字符串长度计算"></a>字符串长度计算</h2><p>在 Lua 中，要计算字符串的长度（即字符串中字符的个数），你可以使用 <strong>string.len</strong>函数或 <strong>utf8.len</strong> 函数，包含中文的一般用 <strong>utf8.len</strong>，<strong>string.len</strong> 函数用于计算只包含 ASCII 字符串的长度。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local myString = &quot;Hello, RUNOOB!&quot;</span><br><span class="line"></span><br><span class="line">-- 计算字符串的长度（字符个数）</span><br><span class="line">local length = string.len(myString)</span><br><span class="line"></span><br><span class="line">print(length) -- 输出 14</span><br></pre></td></tr></table></figure>

<p>以上实例的 myString 字符串只包含 ASCII 字符，因此 <strong>string.len</strong> 函数可以准确地返回字符串的长度。</p>
<p>包含中文的字符串使用 <strong>utf8.len</strong>函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local myString = &quot;Hello, 世界!&quot;</span><br><span class="line"></span><br><span class="line">-- 计算字符串的长度（字符个数）</span><br><span class="line">local length1 = utf8.len(myString)</span><br><span class="line">print(length1) -- 输出 9</span><br><span class="line"></span><br><span class="line">-- string.len 函数会导致结果不准确</span><br><span class="line">local length2 = string.len(myString)</span><br><span class="line">print(length2) -- 输出 14</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<p>转义字符用于表示不能直接显示的字符，比如后退键，回车键等，如在字符串转换双引号可以使用 ****。</p>
<p>所有的转义字符和所对应的意义：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<hr>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Lua 提供了很多的方法来支持字符串的操作：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>string.upper(argument):</strong> 字符串全部转为大写字母。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>string.lower(argument):</strong> 字符串全部转为小写字母。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">**string.gsub(mainString,findString,replaceString,num)**在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：<code>&gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3); zzza  3</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>string.find (str, substr, [init, [plain]])</strong> 在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。<strong>init</strong> 指定了搜索的起始位置，默认为 1，可以一个负数，表示从后往前数的字符个数。<strong>plain</strong> 表示是否使用简单模式，默认为 false，true 只做简单的查找子串的操作，false 表示使用使用正则模式匹配。以下实例查找字符串 “Lua” 的起始索引和结束索引位置：<code>&gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)  7  9</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>string.reverse(arg)</strong> 字符串反转<code>&gt; string.reverse(&quot;Lua&quot;) auL</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>string.format(…)</strong> 返回一个类似printf的格式化字符串<code>&gt; string.format(&quot;the value is:%d&quot;,4) the value is:4</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>string.char(arg) 和 string.byte(arg[,int])</strong> char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。<code>&gt; string.char(97,98,99,100) abcd &gt; string.byte(&quot;ABCD&quot;,4) 68 &gt; string.byte(&quot;ABCD&quot;) 65 &gt;</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>string.len(arg)</strong> 计算字符串长度。<code>string.len(&quot;abc&quot;) 3</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>string.rep(string, n)</strong> 返回字符串string的n个拷贝<code>&gt; string.rep(&quot;abcd&quot;,2) abcdabcd</code></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>..</strong> 链接两个字符串<code>&gt; print(&quot;www.runoob.&quot;..&quot;com&quot;) www.runoob.com</code></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>string.gmatch(str, pattern)</strong> 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。<code>&gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end Hello Lua user</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>string.match(str, pattern, init)</strong> string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。<code>&gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;) 2 questions &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;)) 2, &quot;questions&quot;</code></td>
</tr>
</tbody></table>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>字符串截取使用 sub() 方法。</p>
<p>string.sub() 用于截取字符串，原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.sub(s, i [, j])</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>s：要截取的字符串。</li>
<li>i：截取开始位置。</li>
<li>j：截取结束位置，默认为 -1，最后一个字符。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 字符串</span><br><span class="line">local sourcestr = &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br><span class="line">print(&quot;\n原始字符串&quot;, string.format(&quot;%q&quot;, sourcestr))</span><br><span class="line"></span><br><span class="line">-- 截取部分，第4个到第15个</span><br><span class="line">local first_sub = string.sub(sourcestr, 4, 15)</span><br><span class="line">print(&quot;\n第一次截取&quot;, string.format(&quot;%q&quot;, first_sub))</span><br><span class="line"></span><br><span class="line">-- 取字符串前缀，第1个到第8个</span><br><span class="line">local second_sub = string.sub(sourcestr, 1, 8)</span><br><span class="line">print(&quot;\n第二次截取&quot;, string.format(&quot;%q&quot;, second_sub))</span><br><span class="line"></span><br><span class="line">-- 截取最后10个</span><br><span class="line">local third_sub = string.sub(sourcestr, -10)</span><br><span class="line">print(&quot;\n第三次截取&quot;, string.format(&quot;%q&quot;, third_sub))</span><br><span class="line"></span><br><span class="line">-- 索引越界，输出原始字符串</span><br><span class="line">local fourth_sub = string.sub(sourcestr, -100)</span><br><span class="line">print(&quot;\n第四次截取&quot;, string.format(&quot;%q&quot;, fourth_sub))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">原始字符串    &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br><span class="line"></span><br><span class="line">第一次截取    &quot;fix--runoobg&quot;</span><br><span class="line"></span><br><span class="line">第二次截取    &quot;prefix--&quot;</span><br><span class="line"></span><br><span class="line">第三次截取    &quot;ao--suffix&quot;</span><br><span class="line"></span><br><span class="line">第四次截取    &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><p>以下实例演示了如何对字符串大小写进行转换：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;;</span><br><span class="line">print(string.upper(string1))</span><br><span class="line">print(string.lower(string1))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LUA</span><br><span class="line">lua</span><br></pre></td></tr></table></figure>

<h3 id="字符串查找与反转"><a href="#字符串查找与反转" class="headerlink" title="字符串查找与反转"></a>字符串查找与反转</h3><p>以下实例演示了如何对字符串进行查找与反转操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;Lua Tutorial&quot;</span><br><span class="line">-- 查找字符串</span><br><span class="line">print(string.find(string,&quot;Tutorial&quot;))</span><br><span class="line">reversedString = string.reverse(string)</span><br><span class="line">print(&quot;新字符串为&quot;,reversedString)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5    12</span><br><span class="line">新字符串为    lairotuT auL</span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Lua 提供了 <strong>string.format()</strong> 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p>
<p>由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p>
<p>以下实例演示了如何对字符串进行格式化操作：</p>
<p>格式字符串可能包含以下的转义码:</p>
<ul>
<li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li>
<li>%o - 接受一个数字并将其转化为八进制数格式</li>
<li>%u - 接受一个数字并将其转化为无符号整数格式</li>
<li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li>%f - 接受一个数字并将其转化为浮点数格式</li>
<li>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li>
<li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<p>为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p>
<ul>
<li>(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li>
<li>(2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li>
<li>(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li>
<li>(4) 宽度数值</li>
<li>(5) 小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;</span><br><span class="line">string2 = &quot;Tutorial&quot;</span><br><span class="line">number1 = 10</span><br><span class="line">number2 = 20</span><br><span class="line">-- 基本字符串格式化</span><br><span class="line">print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))</span><br><span class="line">-- 日期格式化</span><br><span class="line">date = 2; month = 1; year = 2014</span><br><span class="line">print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))</span><br><span class="line">-- 十进制格式化</span><br><span class="line">print(string.format(&quot;%.4f&quot;,1/3))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本格式化 Lua Tutorial</span><br><span class="line">日期格式化 02/01/2014</span><br><span class="line">0.3333</span><br></pre></td></tr></table></figure>

<p>其他例子：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string.format(&quot;%c&quot;, 83)                 -- 输出S</span><br><span class="line">string.format(&quot;%+d&quot;, 17.0)              -- 输出+17</span><br><span class="line">string.format(&quot;%05d&quot;, 17)               -- 输出00017</span><br><span class="line">string.format(&quot;%o&quot;, 17)                 -- 输出21</span><br><span class="line">string.format(&quot;%u&quot;, 3.14)               -- 输出3</span><br><span class="line">string.format(&quot;%x&quot;, 13)                 -- 输出d</span><br><span class="line">string.format(&quot;%X&quot;, 13)                 -- 输出D</span><br><span class="line">string.format(&quot;%e&quot;, 1000)               -- 输出1.000000e+03</span><br><span class="line">string.format(&quot;%E&quot;, 1000)               -- 输出1.000000E+03</span><br><span class="line">string.format(&quot;%6.3f&quot;, 13)              -- 输出13.000</span><br><span class="line">string.format(&quot;%q&quot;, &quot;One\nTwo&quot;)         -- 输出&quot;One\</span><br><span class="line">                                        -- 　　Two&quot;</span><br><span class="line">string.format(&quot;%s&quot;, &quot;monkey&quot;)           -- 输出monkey</span><br><span class="line">string.format(&quot;%10s&quot;, &quot;monkey&quot;)         -- 输出    monkey</span><br><span class="line">string.format(&quot;%5.3s&quot;, &quot;monkey&quot;)        -- 输出  mon</span><br></pre></td></tr></table></figure>

<h3 id="字符与整数相互转换"><a href="#字符与整数相互转换" class="headerlink" title="字符与整数相互转换"></a>字符与整数相互转换</h3><p>以下实例演示了字符与整数相互转换：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 字符转换</span><br><span class="line">-- 转换第一个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;))</span><br><span class="line">-- 转换第三个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,3))</span><br><span class="line">-- 转换末尾第一个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,-1))</span><br><span class="line">-- 第二个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,2))</span><br><span class="line">-- 转换末尾第二个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,-2))</span><br><span class="line"></span><br><span class="line">-- 整数 ASCII 码转换为字符</span><br><span class="line">print(string.char(97))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">76</span><br><span class="line">97</span><br><span class="line">97</span><br><span class="line">117</span><br><span class="line">117</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><p>以下实例演示了其他字符串操作，如计算字符串长度，字符串连接，字符串复制等：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string1 = &quot;www.&quot;</span><br><span class="line">string2 = &quot;runoob&quot;</span><br><span class="line">string3 = &quot;.com&quot;</span><br><span class="line">-- 使用 .. 进行字符串连接</span><br><span class="line">print(&quot;连接字符串&quot;,string1..string2..string3)</span><br><span class="line"></span><br><span class="line">-- 字符串长度</span><br><span class="line">print(&quot;字符串长度 &quot;,string.len(string2))</span><br><span class="line"></span><br><span class="line">-- 字符串复制 2 次</span><br><span class="line">repeatedString = string.rep(string2,2)</span><br><span class="line">print(repeatedString)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接字符串    www.runoob.com</span><br><span class="line">字符串长度     6</span><br><span class="line">runoobrunoob</span><br></pre></td></tr></table></figure>

<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 <strong>string.find, string.gmatch, string.gsub, string.match</strong>。</p>
<p>你还可以在模式串中使用字符类。</p>
<p>字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 <strong>%d</strong> 匹配任意数字。所以你可以使用模式串 <strong>%d%d&#x2F;%d%d&#x2F;%d%d%d%d</strong> 搜索 <strong>dd&#x2F;mm&#x2F;yyyy</strong> 格式的日期：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;Deadline is 30/05/1999, firm&quot;</span><br><span class="line">date = &quot;%d%d/%d%d/%d%d%d%d&quot;</span><br><span class="line">print(string.sub(s, string.find(s, date)))    --&gt; 30/05/1999</span><br></pre></td></tr></table></figure>

<p>下面的表列出了Lua支持的所有字符类：</p>
<p>单个字符(除 <strong>^$()%.[]*+-?</strong> 外): 与该字符自身配对</p>
<ul>
<li><p>.(点): 与任何字符配对</p>
</li>
<li><p>%a: 与任何字母配对</p>
</li>
<li><p>%c: 与任何控制符配对(例如\n)</p>
</li>
<li><p>%d: 与任何数字配对</p>
</li>
<li><p>%l: 与任何小写字母配对</p>
</li>
<li><p>%p: 与任何标点(punctuation)配对</p>
</li>
<li><p>%s: 与空白字符配对</p>
</li>
<li><p>%u: 与任何大写字母配对</p>
</li>
<li><p>%w: 与任何字母&#x2F;数字配对</p>
</li>
<li><p>%x: 与任何十六进制数配对</p>
</li>
<li><p>%z: 与任何代表0的字符配对</p>
</li>
<li><p>%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对</p>
</li>
<li><p>[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母&#x2F;数字, 或下划线符号(_)配对</p>
</li>
<li><p>[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对</p>
</li>
</ul>
<p>当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))</span><br><span class="line">hello..up.down.    4</span><br></pre></td></tr></table></figure>

<p>数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。</p>
<p>在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) . % + - * ? [ ^ $</span><br></pre></td></tr></table></figure>

<p>‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%’不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。</p>
<p><strong>模式条目可以是：</strong></p>
<ul>
<li>单个字符类匹配该类别中任意单个字符；</li>
<li>单个字符类跟一个 ‘<code>*</code>‘， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>+</code>‘， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>-</code>‘， 将匹配零或更多个该类的字符。 和 ‘<code>*</code>‘ 不同， 这个条目总是匹配尽可能短的串；</li>
<li>单个字符类跟一个 ‘<code>?</code>‘， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；</li>
<li><code>%*n*</code>， 这里的 <em>n</em> 可以从 1 到 9； 这个条目匹配一个等于 <em>n</em> 号捕获物（后面有描述）的子串。</li>
<li><code>%b*xy*</code>， 这里的 <em>x</em> 和 <em>y</em> 是两个明确的字符； 这个条目匹配以 <em>x</em> 开始 <em>y</em> 结束， 且其中 <em>x</em> 和 <em>y</em> 保持 <em>平衡</em> 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 <em>x</em> 就 <em>+1</em> ，读到一个 <em>y</em> 就 <em>-1</em>， 最终结束处的那个 <em>y</em> 是第一个记数到 0 的 <em>y</em>。 举个例子，条目 <code>%b()</code> 可以匹配到括号平衡的表达式。</li>
<li><code>%f[*set*]</code>， 指 <em>边境模式</em>； 这个条目会匹配到一个位于 <em>set</em> 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 <em>set</em> 。 集合 <em>set</em> 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘<code>\0</code>‘ 一样。</li>
</ul>
<p><strong>模式：</strong></p>
<p><em>模式</em> 指一个模式条目的序列。 在模式最前面加上符号 ‘<code>^</code>‘ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘<code>$</code>‘ 将使匹配过程锚定到字符串的结尾。 如果 ‘<code>^</code>‘ 和 ‘<code>$</code>‘ 出现在其它位置，它们均没有特殊含义，只表示自身。</p>
<p><strong>捕获：</strong></p>
<p>模式可以在内部用小括号括起一个子模式； 这些子模式被称为 <em>捕获物</em>。 当匹配成功时，由 <em>捕获物</em> 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 <code>&quot;(a*(.)%w(%s*))&quot;</code> ， 字符串中匹配到 <code>&quot;a*(.)%w(%s*)&quot;</code> 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “<code>.</code>“ 匹配到的字符是 2 号捕获物， 匹配到 “<code>%s*</code>“ 的那部分是 3 号。</p>
<p>作为一个特例，空的捕获 <code>()</code> 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 <code>&quot;()aa()&quot;</code> 作用到字符串 <code>&quot;flaaap&quot;</code> 上，将产生两个捕获物： 3 和 5 。</p>
<hr>
<h1 id="Lua-数组"><a href="#Lua-数组" class="headerlink" title="Lua 数组"></a>Lua 数组</h1><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。</p>
<p>在 Lua 中，数组不是一种特定的数据类型，而是一种用来存储一组值的数据结构。</p>
<p>实际上，Lua 中并没有专门的数组类型，而是使用一种被称为 <strong>“table”</strong> 的数据结构来实现数组的功能。</p>
<p>Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p>
<p>在 Lua 索引值是以 <strong>1</strong> 为起始，但你也可以指定 0 开始。</p>
<hr>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>一维数组是最简单的数组，其逻辑结构是线性表。</p>
<p>使用索引访问数组元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 访问数组元素</span><br><span class="line">print(myArray[1])  -- 输出 10</span><br><span class="line">print(myArray[3])  -- 输出 30</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<p>要计算数组的长度（即数组中元素的个数），你可以使用 <strong>#</strong> 操作符：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 计算数组长度</span><br><span class="line">local length = #myArray</span><br><span class="line"></span><br><span class="line">print(length) -- 输出 5</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>一维数组可以用 <strong>for</strong> 循环出数组中的元素，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>lua 索引默认从 1 开始：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&quot;Lua&quot;, &quot;Tutorial&quot;&#125;</span><br><span class="line"></span><br><span class="line">for i= 0, 2 do</span><br><span class="line">   print(array[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nil</span><br><span class="line">Lua</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，我们可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 <strong>nil</strong>。</p>
<p>除此外我们还可以以负数为数组索引值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for i= -2, 2 do</span><br><span class="line">   array[i] = i *2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = -2,2 do</span><br><span class="line">   print(array[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-4</span><br><span class="line">-2</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>我们也可以修改数组中元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 修改数组元素</span><br><span class="line">myArray[2] = 25</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">25</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>我们也可以向数组中添加元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 添加新元素到数组末尾</span><br><span class="line">myArray[#myArray + 1] = 60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br><span class="line">60</span><br></pre></td></tr></table></figure>

<p>我们也可以删除数组中元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 删除第三个元素</span><br><span class="line">table.remove(myArray, 3)</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组即数组中包含数组或一维数组的索引键对应一个数组。</p>
<p>以下是一个三行三列的阵列多维数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化数组</span><br><span class="line">array = &#123;&#125;</span><br><span class="line">for i=1,3 do</span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      for j=1,3 do</span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 访问数组</span><br><span class="line">for i=1,3 do</span><br><span class="line">   for j=1,3 do</span><br><span class="line">      print(array[i][j])</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>不同索引键的三行三列阵列多维数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化数组</span><br><span class="line">array = &#123;&#125;</span><br><span class="line">maxRows = 3</span><br><span class="line">maxColumns = 3</span><br><span class="line">for row=1,maxRows do</span><br><span class="line">   for col=1,maxColumns do</span><br><span class="line">      array[row*maxColumns +col] = row*col</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 访问数组</span><br><span class="line">for row=1,maxRows do</span><br><span class="line">   for col=1,maxColumns do</span><br><span class="line">      print(array[row*maxColumns +col])</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，以上的实例中，数组设定了指定的索引值，这样可以避免出现 nil 值，有利于节省内存空间。</p>
<hr>
<h1 id="Lua-迭代器"><a href="#Lua-迭代器" class="headerlink" title="Lua 迭代器"></a>Lua 迭代器</h1><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p>
<p>在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p>
<hr>
<h2 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h2><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p>
<p>泛型 for 迭代器提供了集合的 key&#x2F;value 对，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for k, v in pairs(t) do</span><br><span class="line">    print(k, v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p>
<p>查看以下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line"></span><br><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1  Google</span><br><span class="line">2  Runoob</span><br></pre></td></tr></table></figure>

<p>以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。</p>
<p>下面我们看看泛型 for 的执行过程：</p>
<ul>
<li>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<p>在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：</p>
<ul>
<li>无状态的迭代器</li>
<li>多状态的迭代器</li>
</ul>
<hr>
<h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p>
<p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素，元素的索引需要是数值。</p>
<p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function square(iteratorMaxCount,currentNumber)</span><br><span class="line">   if currentNumber&lt;iteratorMaxCount</span><br><span class="line">   then</span><br><span class="line">      currentNumber = currentNumber+1</span><br><span class="line">   return currentNumber, currentNumber*currentNumber</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i,n in square,3,0</span><br><span class="line">do</span><br><span class="line">   print(i,n)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1    1</span><br><span class="line">2    4</span><br><span class="line">3    9</span><br></pre></td></tr></table></figure>

<p>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs 和迭代函数都很简单，我们在 Lua 中可以这样实现：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function iter (a, i)</span><br><span class="line">    i = i + 1</span><br><span class="line">    local v = a[i]</span><br><span class="line">    if v then</span><br><span class="line">       return i, v</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function ipairs (a)</span><br><span class="line">    return iter, a, 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]&#x3D;nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p>
<hr>
<h2 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h2><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p>
<p>以下实例我们创建了自己的迭代器：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line"></span><br><span class="line">function elementIterator (collection)</span><br><span class="line">   local index = 0</span><br><span class="line">   local count = #collection</span><br><span class="line">   -- 闭包函数</span><br><span class="line">   return function ()</span><br><span class="line">      index = index + 1</span><br><span class="line">      if index &lt;= count</span><br><span class="line">      then</span><br><span class="line">         --  返回迭代器的当前元素</span><br><span class="line">         return collection[index]</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for element in elementIterator(array)</span><br><span class="line">do</span><br><span class="line">   print(element)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>

<p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p>
<hr>
<h1 id="Lua-table-表"><a href="#Lua-table-表" class="headerlink" title="Lua table(表)"></a>Lua table(表)</h1><p>table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。</p>
<p>Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。</p>
<p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p>
<p>Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。</p>
<hr>
<h2 id="table-表-的构造"><a href="#table-表-的构造" class="headerlink" title="table(表)的构造"></a>table(表)的构造</h2><p>构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化表</span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- 指定值</span><br><span class="line">mytable[1]= &quot;Lua&quot;</span><br><span class="line"></span><br><span class="line">-- 移除引用</span><br><span class="line">mytable = nil</span><br><span class="line">-- lua 垃圾回收会释放内存</span><br></pre></td></tr></table></figure>

<p>当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。</p>
<p>以下实例演示了以上的描述情况：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 简单的 table</span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line">print(&quot;mytable 的类型是 &quot;,type(mytable))</span><br><span class="line"></span><br><span class="line">mytable[1]= &quot;Lua&quot;</span><br><span class="line">mytable[&quot;wow&quot;] = &quot;修改前&quot;</span><br><span class="line">print(&quot;mytable 索引为 1 的元素是 &quot;, mytable[1])</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">-- alternatetable和mytable的是指同一个 table</span><br><span class="line">alternatetable = mytable</span><br><span class="line"></span><br><span class="line">print(&quot;alternatetable 索引为 1 的元素是 &quot;, alternatetable[1])</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, alternatetable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">alternatetable[&quot;wow&quot;] = &quot;修改后&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">-- 释放变量</span><br><span class="line">alternatetable = nil</span><br><span class="line">print(&quot;alternatetable 是 &quot;, alternatetable)</span><br><span class="line"></span><br><span class="line">-- mytable 仍然可以访问</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">mytable = nil</span><br><span class="line">print(&quot;mytable 是 &quot;, mytable)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mytable 的类型是     table</span><br><span class="line">mytable 索引为 1 的元素是     Lua</span><br><span class="line">mytable 索引为 wow 的元素是     修改前</span><br><span class="line">alternatetable 索引为 1 的元素是     Lua</span><br><span class="line">mytable 索引为 wow 的元素是     修改前</span><br><span class="line">mytable 索引为 wow 的元素是     修改后</span><br><span class="line">alternatetable 是     nil</span><br><span class="line">mytable 索引为 wow 的元素是     修改后</span><br><span class="line">mytable 是     nil</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><p>以下列出了 Table 操作常用的方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">**table.concat (table [, sep [, start [, end]]]):**concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">**table.insert (table, [pos,] value):**在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">**table.maxn (table)**指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">**table.remove (table [, pos])**返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">**table.sort (table [, comp])**对给定的table进行升序排序。</td>
</tr>
</tbody></table>
<p>接下来我们来看下这几个方法的实例。</p>
<h3 id="Table-连接"><a href="#Table-连接" class="headerlink" title="Table 连接"></a>Table 连接</h3><p>我们可以使用 concat() 输出一个列表中元素连接成的字符串:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line">-- 返回 table 连接后的字符串</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits))</span><br><span class="line"></span><br><span class="line">-- 指定连接字符</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))</span><br><span class="line"></span><br><span class="line">-- 指定索引来连接 table</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接后的字符串     bananaorangeapple</span><br><span class="line">连接后的字符串     banana, orange, apple</span><br><span class="line">连接后的字符串     orange, apple</span><br></pre></td></tr></table></figure>

<h3 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h3><p>以下实例演示了 table 的插入和移除操作:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line"></span><br><span class="line">-- 在末尾插入</span><br><span class="line">table.insert(fruits,&quot;mango&quot;)</span><br><span class="line">print(&quot;索引为 4 的元素为 &quot;,fruits[4])</span><br><span class="line"></span><br><span class="line">-- 在索引为 2 的键处插入</span><br><span class="line">table.insert(fruits,2,&quot;grapes&quot;)</span><br><span class="line">print(&quot;索引为 2 的元素为 &quot;,fruits[2])</span><br><span class="line"></span><br><span class="line">print(&quot;最后一个元素为 &quot;,fruits[5])</span><br><span class="line">table.remove(fruits)</span><br><span class="line">print(&quot;移除后最后一个元素为 &quot;,fruits[5])</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">索引为 4 的元素为     mango</span><br><span class="line">索引为 2 的元素为     grapes</span><br><span class="line">最后一个元素为     mango</span><br><span class="line">移除后最后一个元素为     nil</span><br></pre></td></tr></table></figure>

<h3 id="Table-排序"><a href="#Table-排序" class="headerlink" title="Table 排序"></a>Table 排序</h3><p>以下实例演示了 sort() 方法的使用，用于对 Table 进行排序：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;&#125;</span><br><span class="line">print(&quot;排序前&quot;)</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">        print(k,v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">table.sort(fruits)</span><br><span class="line">print(&quot;排序后&quot;)</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">        print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">1    banana</span><br><span class="line">2    orange</span><br><span class="line">3    apple</span><br><span class="line">4    grapes</span><br><span class="line">排序后</span><br><span class="line">1    apple</span><br><span class="line">2    banana</span><br><span class="line">3    grapes</span><br><span class="line">4    orange</span><br></pre></td></tr></table></figure>

<h3 id="Table-最大值"><a href="#Table-最大值" class="headerlink" title="Table 最大值"></a>Table 最大值</h3><p>table.maxn 在 Lua5.2 之后该方法已经不存在了，我们定义了 table_maxn 方法来实现。</p>
<p>以下实例演示了如何获取 table 中的最大值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function table_maxn(t)</span><br><span class="line">  local mn=nil;</span><br><span class="line">  for k, v in pairs(t) do</span><br><span class="line">    if(mn==nil) then</span><br><span class="line">      mn=v</span><br><span class="line">    end</span><br><span class="line">    if mn &lt; v then</span><br><span class="line">      mn = v</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  return mn</span><br><span class="line">end</span><br><span class="line">tbl = &#123;[1] = 2, [2] = 6, [3] = 34, [26] =5&#125;</span><br><span class="line">print(&quot;tbl 最大值：&quot;, table_maxn(tbl))</span><br><span class="line">print(&quot;tbl 长度 &quot;, #tbl)</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tbl 最大值：    34</span><br><span class="line">tbl 长度     3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>当我们获取 table 的长度的时候无论是使用 <strong>#</strong> 还是 <strong>table.getn</strong> 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p>
<p>可以使用以下方法来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function table_leng(t)</span><br><span class="line">local leng=0</span><br><span class="line">for k, v in pairs(t) do</span><br><span class="line"> leng=leng+1</span><br><span class="line">end</span><br><span class="line">return leng;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h1 id="Lua-模块与包"><a href="#Lua-模块与包" class="headerlink" title="Lua 模块与包"></a>Lua 模块与包</h1><p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>
<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 文件名为 module.lua</span><br><span class="line">-- 定义一个名为 module 的模块</span><br><span class="line">module = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 定义一个常量</span><br><span class="line">module.constant = &quot;这是一个常量&quot;</span><br><span class="line"> </span><br><span class="line">-- 定义一个函数</span><br><span class="line">function module.func1()</span><br><span class="line">    io.write(&quot;这是一个公有函数！\n&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">local function func2()</span><br><span class="line">    print(&quot;这是一个私有函数！&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function module.func3()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return module</span><br></pre></td></tr></table></figure>

<p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p>
<p>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>
<hr>
<h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h2><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;&lt;模块名&gt;&quot;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &quot;&lt;模块名&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p>
<p><strong>test_module.lua 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- test_module.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(module.constant)</span><br><span class="line"> </span><br><span class="line">module.func3()</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>

<p>或者给加载的模块定义一个别名变量，方便调用：</p>
<p><strong>test_module2.lua 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- test_module2.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">-- 别名变量 m</span><br><span class="line">local m = require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>

<h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p>
<p>require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p>
<p>当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 “~&#x2F;lua&#x2F;“ 路径加入 LUA_PATH 环境变量里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#LUA_PATH</span><br><span class="line">export LUA_PATH=&quot;~/lua/?.lua;;&quot;</span><br></pre></td></tr></table></figure>

<p>文件路径以 “;” 号分隔，最后的 2 个 “;;” 表示新加的路径后面加上原来的默认路径。</p>
<p>接着，更新环境变量参数，使之立即生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>

<p>这时假设 package.path 的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/dengjoe/lua/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua</span><br></pre></td></tr></table></figure>

<p>那么调用 require(“module”) 时就会尝试打开以下文件目录去搜索目标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Users/dengjoe/lua/module.lua;</span><br><span class="line">./module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module/init.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module/init.lua</span><br></pre></td></tr></table></figure>

<p>如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。</p>
<p>搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p>
<p>搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p>
<hr>
<h2 id="C-包"><a href="#C-包" class="headerlink" title="C 包"></a>C 包</h2><p>Lua和C是很容易结合的，使用 C 为 Lua 写包。</p>
<p>与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p>
<p>Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local path = &quot;/usr/local/lua/lib/libluasocket.so&quot;</span><br><span class="line">local f = loadlib(path, &quot;luaopen_socket&quot;)</span><br></pre></td></tr></table></figure>

<p>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。</p>
<p>如果加载动态库或者查找初始化函数时出错，loadlib 将返回 nil 和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local path = &quot;/usr/local/lua/lib/libluasocket.so&quot;</span><br><span class="line">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Windows 平台下</span><br><span class="line">local f = assert(loadlib(path, &quot;luaopen_socket&quot;))</span><br><span class="line">f()  -- 真正打开库</span><br></pre></td></tr></table></figure>

<p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的 stub 文件，安装二进制库的时候可以随便放在某个目录，只需要修改 stub 文件对应二进制库的实际路径即可。</p>
<p>将 stub 文件所在的目录加入到 LUA_PATH，这样设定后就可以使用 require 函数加载 C 库了。</p>
<hr>
<h1 id="Lua-元表-Metatable"><a href="#Lua-元表-Metatable" class="headerlink" title="Lua 元表(Metatable)"></a>Lua 元表(Metatable)</h1><p>在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作(比如相加)。</p>
<p>因此 Lua 提供了元表(Metatable)，允许我们改变 table 的行为，每个行为关联了对应的元方法。</p>
<p>例如，使用元表我们可以定义 Lua 如何计算两个 table 的相加操作 a+b。</p>
<p>当 Lua 试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫 <strong>__add</strong> 的字段，若找到，则调用对应的值。 <strong>__add</strong> 等即时字段，其对应的值（往往是一个函数或是 table）就是”元方法”。</p>
<p>有两个很重要的函数来处理元表：</p>
<ul>
<li><strong>setmetatable(table,metatable):</strong> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li>
<li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li>
</ul>
<p>以下实例演示了如何对指定的表设置元表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mytable = &#123;&#125;                          -- 普通表 </span><br><span class="line">mymetatable = &#123;&#125;                      -- 元表</span><br><span class="line">setmetatable(mytable,mymetatable)     -- 把 mymetatable 设为 mytable 的元表</span><br></pre></td></tr></table></figure>

<p>以上代码也可以直接写成一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mytable = setmetatable(&#123;&#125;,&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>以下为返回对象元表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getmetatable(mytable)                 -- 这会返回 mymetatable</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h2><p>这是 metatable 最常用的键。</p>
<p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。</p>
<p>我们可以在使用 lua 命令进入交互模式查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; other = &#123; foo = 3 &#125; </span><br><span class="line">&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;) </span><br><span class="line">&gt; t.foo</span><br><span class="line">3</span><br><span class="line">&gt; t.bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。</p>
<p>__index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;</span><br><span class="line">  __index = function(mytable, key)</span><br><span class="line">    if key == &quot;key2&quot; then</span><br><span class="line">      return &quot;metatablevalue&quot;</span><br><span class="line">    else</span><br><span class="line">      return nil</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<p>实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value1    metatablevalue</span><br></pre></td></tr></table></figure>

<p>实例解析：</p>
<ul>
<li>mytable 表赋值为 **{key1 &#x3D; “value1”}**。</li>
<li>mytable 设置了元表，元方法为 __index。</li>
<li>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</li>
<li>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</li>
<li>判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。</li>
<li>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 “metatablevalue”，否则返回 mytable 对应的键值。</li>
</ul>
<p>我们可以将以上代码简单写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __index = &#123; key2 = &quot;metatablevalue&quot; &#125; &#125;)</span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p>
<ul>
<li>1.在表中查找，如果找到，返回该元素，找不到则继续</li>
<li>2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li>
<li>3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li>
</ul>
<p>该部分内容来自作者寰子：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xocoder/article/details/9028347">https://blog.csdn.net/xocoder/article/details/9028347</a></p>
</blockquote>
<hr>
<h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p>__newindex 元方法用来对表更新，__index则用来对表访问 。</p>
<p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。</p>
<p>以下实例演示了 __newindex 元方法的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1)</span><br><span class="line"></span><br><span class="line">mytable.newkey = &quot;新值2&quot;</span><br><span class="line">print(mytable.newkey,mymetatable.newkey)</span><br><span class="line"></span><br><span class="line">mytable.key1 = &quot;新值1&quot;</span><br><span class="line">print(mytable.key1,mymetatable.key1)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value1</span><br><span class="line">nil    新值2</span><br><span class="line">新值1    nil</span><br></pre></td></tr></table></figure>

<p>以上实例中表设置了元方法__newindex，在对新索引键（newkey）赋值时（mytable.newkey &#x3D; “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p>
<p>以下实例使用了 rawset 函数来更新表：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;</span><br><span class="line">    __newindex = function(mytable, key, value)</span><br><span class="line">        rawset(mytable, key, &quot;\&quot;&quot;..value..&quot;\&quot;&quot;)</span><br><span class="line">    end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mytable.key1 = &quot;new value&quot;</span><br><span class="line">mytable.key2 = 4</span><br><span class="line"></span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new value    &quot;4&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="为表添加操作符"><a href="#为表添加操作符" class="headerlink" title="为表添加操作符"></a>为表添加操作符</h2><p>以下实例演示了两表相加操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即返回表最大键值</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn = 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn = k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 两表相加操作</span><br><span class="line">mytable = setmetatable(&#123; 1, 2, 3 &#125;, &#123;</span><br><span class="line">  __add = function(mytable, newtable)</span><br><span class="line">    for i = 1, table_maxn(newtable) do</span><br><span class="line">      table.insert(mytable, table_maxn(mytable)+1,newtable[i])</span><br><span class="line">    end</span><br><span class="line">    return mytable</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">secondtable = &#123;4,5,6&#125;</span><br><span class="line"></span><br><span class="line">mytable = mytable + secondtable</span><br><span class="line">        for k,v in ipairs(mytable) do</span><br><span class="line">print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">5    5</span><br><span class="line">6    6</span><br></pre></td></tr></table></figure>

<p>__add 键包含在元表中，并进行相加操作。 表中对应的操作列表如下：(**注意：__是两个下划线)</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__add</td>
<td align="left">对应的运算符 ‘+’.</td>
</tr>
<tr>
<td align="left">__sub</td>
<td align="left">对应的运算符 ‘-‘.</td>
</tr>
<tr>
<td align="left">__mul</td>
<td align="left">对应的运算符 ‘*’.</td>
</tr>
<tr>
<td align="left">__div</td>
<td align="left">对应的运算符 ‘&#x2F;‘.</td>
</tr>
<tr>
<td align="left">__mod</td>
<td align="left">对应的运算符 ‘%’.</td>
</tr>
<tr>
<td align="left">__unm</td>
<td align="left">对应的运算符 ‘-‘.</td>
</tr>
<tr>
<td align="left">__concat</td>
<td align="left">对应的运算符 ‘..’.</td>
</tr>
<tr>
<td align="left">__eq</td>
<td align="left">对应的运算符 ‘&#x3D;&#x3D;’.</td>
</tr>
<tr>
<td align="left">__lt</td>
<td align="left">对应的运算符 ‘&lt;’.</td>
</tr>
<tr>
<td align="left">__le</td>
<td align="left">对应的运算符 ‘&lt;&#x3D;’.</td>
</tr>
</tbody></table>
<hr>
<h2 id="call-元方法"><a href="#call-元方法" class="headerlink" title="__call 元方法"></a>__call 元方法</h2><p>__call 元方法在 Lua 调用一个值时调用。以下实例演示了计算表中元素的和：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn = 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn = k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 定义元方法__call</span><br><span class="line">mytable = setmetatable(&#123;10&#125;, &#123;</span><br><span class="line">  __call = function(mytable, newtable)</span><br><span class="line">        sum = 0</span><br><span class="line">        for i = 1, table_maxn(mytable) do</span><br><span class="line">                sum = sum + mytable[i]</span><br><span class="line">        end</span><br><span class="line">    for i = 1, table_maxn(newtable) do</span><br><span class="line">                sum = sum + newtable[i]</span><br><span class="line">        end</span><br><span class="line">        return sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">newtable = &#123;10,20,30&#125;</span><br><span class="line">print(mytable(newtable))</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="tostring-元方法"><a href="#tostring-元方法" class="headerlink" title="__tostring 元方法"></a>__tostring 元方法</h2><p>__tostring 元方法用于修改表的输出行为。以下实例我们自定义了表的输出内容：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mytable = setmetatable(&#123; 10, 20, 30 &#125;, &#123;</span><br><span class="line">  __tostring = function(mytable)</span><br><span class="line">    sum = 0</span><br><span class="line">    for k, v in pairs(mytable) do</span><br><span class="line">                sum = sum + v</span><br><span class="line">        end</span><br><span class="line">    return &quot;表所有元素的和为 &quot; .. sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">print(mytable)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表所有元素的和为 60</span><br></pre></td></tr></table></figure>

<p>从本文中我们可以知道元表可以很好的简化我们的代码功能，所以了解 Lua 的元表，可以让我们写出更加简单优秀的 Lua 代码。</p>
<hr>
<h1 id="Lua-协同程序-coroutine"><a href="#Lua-协同程序-coroutine" class="headerlink" title="Lua 协同程序(coroutine)"></a>Lua 协同程序(coroutine)</h1><hr>
<h2 id="什么是协同-coroutine-？"><a href="#什么是协同-coroutine-？" class="headerlink" title="什么是协同(coroutine)？"></a>什么是协同(coroutine)？</h2><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p>
<p>协同程序可以理解为一种特殊的线程，可以暂停和恢复其执行，从而允许非抢占式的多任务处理。</p>
<p>协同是非常强大的功能，但是用起来也很复杂。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>同程序由 <strong>coroutine</strong> 模块提供支持。</p>
<p>使用协同程序，你可以在函数中使用 <strong>coroutine.create</strong> 创建一个新的协同程序对象，并使用 <strong>coroutine.resume</strong> 启动它的执行。协同程序可以通过调用 <strong>coroutine.yield</strong> 来主动暂停自己的执行，并将控制权交还给调用者。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">coroutine.create()</td>
<td align="left">创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td>
</tr>
<tr>
<td align="left">coroutine.resume()</td>
<td align="left">重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td align="left">coroutine.yield()</td>
<td align="left">挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
</tr>
<tr>
<td align="left">coroutine.status()</td>
<td align="left">查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
</tr>
<tr>
<td align="left">coroutine.wrap（）</td>
<td align="left">创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td align="left">coroutine.running()</td>
<td align="left">返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 coroutine 的线程号</td>
</tr>
</tbody></table>
<p>以下实例演示了如何使用 Lua 协同程序：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo()</span><br><span class="line">    print(&quot;协同程序 foo 开始执行&quot;)</span><br><span class="line">    local value = coroutine.yield(&quot;暂停 foo 的执行&quot;)</span><br><span class="line">    print(&quot;协同程序 foo 恢复执行，传入的值为: &quot; .. tostring(value))</span><br><span class="line">    print(&quot;协同程序 foo 结束执行&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建协同程序</span><br><span class="line">local co = coroutine.create(foo)</span><br><span class="line"></span><br><span class="line">-- 启动协同程序</span><br><span class="line">local status, result = coroutine.resume(co)</span><br><span class="line">print(result) -- 输出: 暂停 foo 的执行</span><br><span class="line"></span><br><span class="line">-- 恢复协同程序的执行，并传入一个值</span><br><span class="line">status, result = coroutine.resume(co, 42)</span><br><span class="line">print(result) -- 输出: 协同程序 foo 恢复执行，传入的值为: 42</span><br></pre></td></tr></table></figure>

<p>以上实例中，我们定义了一个名为 foo 的函数作为协同程序。在函数中，我们使用 coroutine.yield 暂停了协同程序的执行，并返回了一个值</p>
<p>。在主程序中，我们使用 coroutine.create 创建了一个协同程序对象，并使用 coroutine.resume 启动了它的执行。</p>
<p>在第一次调用 coroutine.resume 后，协同程序执行到 coroutine.yield 处暂停，并将值返回给主程序。然后，我们再次调用 coroutine.resume，并传入一个值作为协同程序恢复执行时的参数。</p>
<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">协同程序 foo 开始执行</span><br><span class="line">暂停 foo 的执行</span><br><span class="line">协同程序 foo 恢复执行，传入的值为: 42</span><br><span class="line">协同程序 foo 结束执行</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>需要注意的是，协同程序的状态可以通过 coroutine.status 函数获取，通过检查状态可以确定协同程序的执行情况（如运行中、已挂起、已结束等）。</p>
<p><strong>以下实例演示了以上各个方法的用法：</strong></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-- coroutine_test.lua 文件</span><br><span class="line">-- 创建了一个新的协同程序对象 co，其中协同程序函数打印传入的参数 i</span><br><span class="line">co = coroutine.create(</span><br><span class="line">    function(i)</span><br><span class="line">        print(i);</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line">-- 使用 coroutine.resume 启动协同程序 co 的执行，并传入参数 1。协同程序开始执行，打印输出为 1</span><br><span class="line">coroutine.resume(co, 1)   -- 1</span><br><span class="line"></span><br><span class="line">-- 通过 coroutine.status 检查协同程序 co 的状态，输出为 dead，表示协同程序已经执行完毕</span><br><span class="line">print(coroutine.status(co))  -- dead</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line"></span><br><span class="line">-- 使用 coroutine.wrap 创建了一个协同程序包装器，将协同程序函数转换为一个可直接调用的函数对象</span><br><span class="line">co = coroutine.wrap(</span><br><span class="line">    function(i)</span><br><span class="line">        print(i);</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">co(1)</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line">-- 创建了另一个协同程序对象 co2，其中的协同程序函数通过循环打印数字 1 到 10，在循环到 3 的时候输出当前协同程序的状态和正在运行的线程</span><br><span class="line">co2 = coroutine.create(</span><br><span class="line">    function()</span><br><span class="line">        for i=1,10 do</span><br><span class="line">            print(i)</span><br><span class="line">            if i == 3 then</span><br><span class="line">                print(coroutine.status(co2))  --running</span><br><span class="line">                print(coroutine.running()) --thread:XXXXXX</span><br><span class="line">            end</span><br><span class="line">            coroutine.yield()</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 连续调用 coroutine.resume 启动协同程序 co2 的执行</span><br><span class="line">coroutine.resume(co2) --1</span><br><span class="line">coroutine.resume(co2) --2</span><br><span class="line">coroutine.resume(co2) --3</span><br><span class="line"></span><br><span class="line">-- 通过 coroutine.status 检查协同程序 co2 的状态，输出为 suspended，表示协同程序暂停执行</span><br><span class="line">print(coroutine.status(co2))   -- suspended</span><br><span class="line">print(coroutine.running())</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">dead</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">running</span><br><span class="line">thread: 0x7fb801c05868    false</span><br><span class="line">suspended</span><br><span class="line">thread: 0x7fb801c04c88    true</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p>
<p>当create一个coroutine的时候就是在新线程中注册了一个事件。</p>
<p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p>
<p>接下来我们分析一个更详细的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function foo (a)</span><br><span class="line">    print(&quot;foo 函数输出&quot;, a)</span><br><span class="line">    return coroutine.yield(2 * a) -- 返回  2*a 的值</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">co = coroutine.create(function (a , b)</span><br><span class="line">    print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10</span><br><span class="line">    local r = foo(a + 1)</span><br><span class="line">     </span><br><span class="line">    print(&quot;第二次协同程序执行输出&quot;, r)</span><br><span class="line">    local r, s = coroutine.yield(a + b, a - b)  -- a，b的值为第一次调用协同程序时传入</span><br><span class="line">     </span><br><span class="line">    print(&quot;第三次协同程序执行输出&quot;, r, s)</span><br><span class="line">    return b, &quot;结束协同程序&quot;                   -- b的值为第二次调用协同程序时传入</span><br><span class="line">end)</span><br><span class="line">        </span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4</span><br><span class="line">print(&quot;--分割线----&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 end</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutine</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一次协同程序执行输出    1    10</span><br><span class="line">foo 函数输出    2</span><br><span class="line">main    true    4</span><br><span class="line">--分割线----</span><br><span class="line">第二次协同程序执行输出    r</span><br><span class="line">main    true    11    -9</span><br><span class="line">---分割线---</span><br><span class="line">第三次协同程序执行输出    x    y</span><br><span class="line">main    true    10    结束协同程序</span><br><span class="line">---分割线---</span><br><span class="line">main    false    cannot resume dead coroutine</span><br><span class="line">---分割线---</span><br></pre></td></tr></table></figure>

<p>以上实例接下如下：</p>
<ul>
<li>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；</li>
<li>协同程序运行；</li>
<li>运行到yield语句；</li>
<li>yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）</li>
<li>第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）</li>
<li>yield返回；</li>
<li>协同程序继续运行；</li>
<li>如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine</li>
</ul>
<p>resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p>
<hr>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>现在我就使用Lua的协同程序来完成生产者-消费者这一经典问题。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">local newProductor</span><br><span class="line"></span><br><span class="line">function productor()</span><br><span class="line">     local i = 0</span><br><span class="line">     while true do</span><br><span class="line">          i = i + 1</span><br><span class="line">          send(i)     -- 将生产的物品发送给消费者</span><br><span class="line">     end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function consumer()</span><br><span class="line">     while true do</span><br><span class="line">          local i = receive()     -- 从生产者那里得到物品</span><br><span class="line">          print(i)</span><br><span class="line">     end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function receive()</span><br><span class="line">     local status, value = coroutine.resume(newProductor)</span><br><span class="line">     return value</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function send(x)</span><br><span class="line">     coroutine.yield(x)     -- x表示需要发送的值，值返回以后，就挂起该协同程序</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 启动程序</span><br><span class="line">newProductor = coroutine.create(productor)</span><br><span class="line">consumer()</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程和协同程序区别"><a href="#线程和协同程序区别" class="headerlink" title="线程和协同程序区别"></a>线程和协同程序区别</h2><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p>
<p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p>
<p>主要区别归纳如下：</p>
<ul>
<li>调度方式：线程通常由操作系统的调度器进行抢占式调度，操作系统会在不同线程之间切换执行权。而协同程序是非抢占式调度的，它们由程序员显式地控制执行权的转移。</li>
<li>并发性：线程是并发执行的，多个线程可以同时运行在多个处理器核心上，或者通过时间片轮转在单个核心上切换执行。协同程序则是协作式的，只有一个协同程序处于运行状态，其他协同程序必须等待当前协同程序主动放弃执行权。</li>
<li>内存占用：线程通常需要独立的堆栈和上下文环境，因此线程的创建和销毁会带来额外的开销。而协同程序可以共享相同的堆栈和上下文，因此创建和销毁协同程序的开销较小。</li>
<li>数据共享：线程之间可以共享内存空间，但需要注意线程安全性和同步问题。协同程序通常通过参数传递和返回值来进行数据共享，不同协同程序之间的数据隔离性较好。</li>
<li>调试和错误处理：线程通常在调试和错误处理方面更复杂，因为多个线程之间的交互和并发执行可能导致难以调试的问题。协同程序则在调试和错误处理方面相对简单，因为它们是由程序员显式地控制执行流程的。</li>
</ul>
<p>总体而言，线程适用于需要并发执行的场景，例如在多核处理器上利用并行性加快任务的执行速度。而协同程序适用于需要协作和协调的场景，例如状态机、事件驱动编程或协作式任务处理。选择使用线程还是协同程序取决于具体的应用需求和编程模型。</p>
<hr>
<h1 id="Lua-文件-I-O"><a href="#Lua-文件-I-O" class="headerlink" title="Lua 文件 I&#x2F;O"></a>Lua 文件 I&#x2F;O</h1><p>Lua I&#x2F;O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。</p>
<ul>
<li>简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li>
<li>完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法</li>
</ul>
<p>简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。</p>
<p>打开文件操作语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = io.open (filename [, mode])</span><br></pre></td></tr></table></figure>

<p>mode 的值有：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">以可读写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">与a类似，但此文件可读可写</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">二进制模式，如果文件是二进制文件，可以加上b</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">号表示对文件既可以读也可以写</td>
</tr>
</tbody></table>
<hr>
<h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><p>简单模式使用标准的 I&#x2F;O 或使用一个当前输入文件和一个当前输出文件。</p>
<p>以下为 file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">-- 设置默认输入文件为 test.lua</span><br><span class="line">io.input(file)</span><br><span class="line"></span><br><span class="line">-- 输出文件第一行</span><br><span class="line">print(io.read())</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">io.close(file)</span><br><span class="line"></span><br><span class="line">-- 以附加的方式打开只写文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">-- 设置默认输出文件为 test.lua</span><br><span class="line">io.output(file)</span><br><span class="line"></span><br><span class="line">-- 在文件最后一行添加 Lua 注释</span><br><span class="line">io.write(&quot;--  test.lua 文件末尾注释&quot;)</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">io.close(file)</span><br></pre></td></tr></table></figure>

<p>执行以上代码，你会发现，输出了 test.lua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- test.lua 文件</span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 io.”x” 方法，其中 io.read() 中我们没有带参数，参数可以是下表中的一个：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“*n”</td>
<td align="left">读取一个数字并返回它。例：file.read(“*n”)</td>
</tr>
<tr>
<td align="left">“*a”</td>
<td align="left">从当前位置读取整个文件。例：file.read(“*a”)</td>
</tr>
<tr>
<td align="left">“*l”（默认）</td>
<td align="left">读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read(“*l”)</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)</td>
</tr>
</tbody></table>
<p>其他的 io 方法有：</p>
<ul>
<li>**io.tmpfile():**返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</li>
<li><strong>io.type(file):</strong> 检测obj是否一个可用的文件句柄</li>
<li><strong>io.flush():</strong> 向文件写入缓冲中的所有数据</li>
<li><strong>io.lines(optional file name):</strong> 返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，但不关闭文件。</li>
</ul>
<hr>
<h2 id="完全模式"><a href="#完全模式" class="headerlink" title="完全模式"></a>完全模式</h2><p>通常我们需要在同一时间处理多个文件。我们需要使用 file:function_name 来代替 io.function_name 方法。以下实例演示了如何同时处理同一个文件:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">-- 输出文件第一行</span><br><span class="line">print(file:read())</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br><span class="line"></span><br><span class="line">-- 以附加的方式打开只写文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">-- 在文件最后一行添加 Lua 注释</span><br><span class="line">file:write(&quot;--test&quot;)</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br></pre></td></tr></table></figure>

<p>执行以上代码，你会发现，输出了 test.lua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- test.lua 文件</span><br></pre></td></tr></table></figure>

<p>read 的参数与简单模式一致。</p>
<p>其他方法:</p>
<ul>
<li><p><strong>file:seek(optional whence, optional offset):</strong> 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:</p>
<ul>
<li>“set”: 从文件头开始</li>
<li>“cur”: 从当前位置开始[默认]</li>
<li>“end”: 从文件尾开始</li>
<li>offset:默认为0</li>
</ul>
<p>不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</p>
</li>
<li><p><strong>file:flush():</strong> 向文件写入缓冲中的所有数据</p>
</li>
<li><p><strong>io.lines(optional file name):</strong> 打开指定的文件 filename 为读模式并返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，并自动关闭文件。<br>若不带参数时io.lines() &lt;&#x3D;&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for line in io.lines(&quot;main.lua&quot;) do</span><br><span class="line"></span><br><span class="line">　　print(line)</span><br><span class="line"></span><br><span class="line">　　end</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当前位置(倒数第 25 个位置)读取整个文件。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">file:seek(&quot;end&quot;,-25)</span><br><span class="line">print(file:read(&quot;*a&quot;))</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br></pre></td></tr></table></figure>

<p>我这边输出的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st.lua 文件末尾--test</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-错误处理"><a href="#Lua-错误处理" class="headerlink" title="Lua 错误处理"></a>Lua 错误处理</h1><p>程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。</p>
<p>任何程序语言中，都需要错误处理。错误类型有：</p>
<ul>
<li>语法错误</li>
<li>运行错误</li>
</ul>
<hr>
<h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- test.lua 文件</span><br><span class="line">a == 2</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: test.lua:2: syntax error near &#x27;==&#x27;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，以上出现了语法错误，一个 “&#x3D;” 号跟两个 “&#x3D;” 号是有区别的。一个 “&#x3D;” 是赋值表达式两个 “&#x3D;” 是比较运算。</p>
<p>另外一个实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: test2.lua:2: &#x27;do&#x27; expected near &#x27;print&#x27;</span><br></pre></td></tr></table></figure>

<p>语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">do</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h2><p>运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)</span><br><span class="line">   return a+b</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add(10)</span><br></pre></td></tr></table></figure>

<p>当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lua: test2.lua:2: attempt to perform arithmetic on local &#x27;b&#x27; (a nil value)</span><br><span class="line">stack traceback:</span><br><span class="line">    test2.lua:2: in function &#x27;add&#x27;</span><br><span class="line">    test2.lua:5: in main chunk</span><br><span class="line">    [C]: ?</span><br></pre></td></tr></table></figure>

<p>lua 里调用函数时，即使实参列表和形参列表不一致也能成功调用，多余的参数会被舍弃，缺少的参数会被补为 nil。</p>
<p>以上报错信息是由于参数 b 被补为 nil 后，nil 参与了 + 运算。</p>
<p>假如 <strong>add</strong> 函数内不是 <strong>“return a+b”</strong> 而是 <strong>“print(a,b)”</strong> 的话，结果会变成 <strong>“10 nil”</strong> 不会报错。</p>
<hr>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>我们可以使用两个函数：assert 和 error 来处理错误。实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local function add(a,b)</span><br><span class="line">   assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)</span><br><span class="line">   assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)</span><br><span class="line">   return a+b</span><br><span class="line">end</span><br><span class="line">add(10)</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lua: test.lua:3: b 不是一个数字</span><br><span class="line">stack traceback:</span><br><span class="line">    [C]: in function &#x27;assert&#x27;</span><br><span class="line">    test.lua:3: in local &#x27;add&#x27;</span><br><span class="line">    test.lua:6: in main chunk</span><br><span class="line">    [C]: in ?</span><br></pre></td></tr></table></figure>

<p>实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。</p>
<h3 id="error函数"><a href="#error函数" class="headerlink" title="error函数"></a>error函数</h3><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error (message [, level])</span><br></pre></td></tr></table></figure>

<p>功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)</p>
<p>通常情况下，error会附加一些错误位置的信息到message头部。</p>
<p>Level参数指示获得错误的位置:</p>
<ul>
<li>Level&#x3D;1[默认]：为调用error位置(文件+行号)</li>
<li>Level&#x3D;2：指出哪个调用error的函数的函数</li>
<li>Level&#x3D;0:不添加错误位置信息</li>
</ul>
<hr>
<h2 id="pcall-和-xpcall、debug"><a href="#pcall-和-xpcall、debug" class="headerlink" title="pcall 和 xpcall、debug"></a>pcall 和 xpcall、debug</h2><p>Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。</p>
<p>pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。</p>
<p>语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if pcall(function_name, ….) then</span><br><span class="line">-- 没有错误</span><br><span class="line">else</span><br><span class="line">-- 一些错误</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>简单实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; =pcall(function(i) print(i) end, 33)</span><br><span class="line">33</span><br><span class="line">true</span><br><span class="line">   </span><br><span class="line">&gt; =pcall(function(i) print(i) error(&#x27;error..&#x27;) end, 33)</span><br><span class="line">33</span><br><span class="line">false        stdin:1: error..</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; function f() return false,2 end</span><br><span class="line">&gt; if f() then print &#x27;1&#x27; else print &#x27;0&#x27; end</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>pcall以一种”保护模式”来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。</p>
<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。</p>
<p>Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>
<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
<li>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</li>
<li>debug.traceback：根据调用桟来构建一个扩展的错误消息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;=xpcall(function(i) print(i) error(&#x27;error..&#x27;) end, function() print(debug.traceback()) end, 33)</span><br><span class="line">33</span><br><span class="line">stack traceback:</span><br><span class="line">stdin:1: in function &lt;stdin:1&gt;</span><br><span class="line">[C]: in function &#x27;error&#x27;</span><br><span class="line">stdin:1: in function &lt;stdin:1&gt;</span><br><span class="line">[C]: in function &#x27;xpcall&#x27;</span><br><span class="line">stdin:1: in main chunk</span><br><span class="line">[C]: in ?</span><br><span class="line">false        nil</span><br></pre></td></tr></table></figure>

<p>xpcall 使用实例 2:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function myfunction ()</span><br><span class="line">   n = n/nil</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function myerrorhandler( err )</span><br><span class="line">   print( &quot;ERROR:&quot;, err )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">status = xpcall( myfunction, myerrorhandler )</span><br><span class="line">print( status )</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:    test2.lua:2: attempt to perform arithmetic on global &#x27;n&#x27; (a nil value)</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-调试-Debug"><a href="#Lua-调试-Debug" class="headerlink" title="Lua 调试(Debug)"></a>Lua 调试(Debug)</h1><p>Lua 提供了 debug 库用于提供创建我们自定义调试器的功能。Lua 本身并未有内置的调试器，但很多开发者共享了他们的 Lua 调试器代码。</p>
<p>Lua 中 debug 库包含以下函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.</td>
<td align="left">**debug():**进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。</td>
</tr>
<tr>
<td align="left">2.</td>
<td align="left">**getfenv(object):**返回对象的环境变量。</td>
</tr>
<tr>
<td align="left">3.</td>
<td align="left">**gethook(optional thread):**返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数</td>
</tr>
<tr>
<td align="left">4.</td>
<td align="left">**getinfo ([thread,] f [, what]):**返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。</td>
</tr>
<tr>
<td align="left">5.</td>
<td align="left">**debug.getlocal ([thread,] f, local):**此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。</td>
</tr>
<tr>
<td align="left">6.</td>
<td align="left">**getmetatable(value):**把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。</td>
</tr>
<tr>
<td align="left">7.</td>
<td align="left">**getregistry():**返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</td>
</tr>
<tr>
<td align="left">8.</td>
<td align="left">**getupvalue (f, up)**此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。 以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</td>
</tr>
<tr>
<td align="left">10.</td>
<td align="left"><strong>sethook ([thread,] hook, mask [, count]):<strong>将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：</strong>‘<code>c</code>‘:</strong> 每当 Lua 调用一个函数时，调用钩子；**’<code>r</code>‘:** 每当 Lua 从一个函数内返回时，调用钩子；**’<code>l</code>‘:** 每当 Lua 进入新的一行时，调用钩子。</td>
</tr>
<tr>
<td align="left">11.</td>
<td align="left">**setlocal ([thread,] level, local, value):**这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。</td>
</tr>
<tr>
<td align="left">12.</td>
<td align="left">**setmetatable (value, table):**将 value 的元表设为 table （可以是 nil）。 返回 value。</td>
</tr>
<tr>
<td align="left">13.</td>
<td align="left">**setupvalue (f, up, value):**这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</td>
</tr>
<tr>
<td align="left">14.</td>
<td align="left">**traceback ([thread,] [message [, level]]):**如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。</td>
</tr>
</tbody></table>
<p>上表列出了我们常用的调试函数，接下来我们可以看些简单的例子：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function myfunction ()</span><br><span class="line">print(debug.traceback(&quot;Stack trace&quot;))</span><br><span class="line">print(debug.getinfo(1))</span><br><span class="line">print(&quot;Stack trace end&quot;)</span><br><span class="line">        return 10</span><br><span class="line">end</span><br><span class="line">myfunction ()</span><br><span class="line">print(debug.getinfo(1))</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack trace</span><br><span class="line">stack traceback:</span><br><span class="line">    test2.lua:2: in function &#x27;myfunction&#x27;</span><br><span class="line">    test2.lua:8: in main chunk</span><br><span class="line">    [C]: ?</span><br><span class="line">table: 0054C6C8</span><br><span class="line">Stack trace end</span><br></pre></td></tr></table></figure>

<p>在以实例中，我们使用到了 debug 库的 traceback 和 getinfo 函数， getinfo 函数用于返回函数信息的表。</p>
<p><strong>另一个实例</strong></p>
<p>我们经常需要调试函数的内的局部变量。我们可以使用 setupvalue 函数来设置这些局部变量。实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function newCounter ()</span><br><span class="line">  local n = 0</span><br><span class="line">  local k = 0</span><br><span class="line">  return function ()</span><br><span class="line">    k = n</span><br><span class="line">    n = n + 1</span><br><span class="line">    return n</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">counter = newCounter ()</span><br><span class="line">print(counter())</span><br><span class="line">print(counter())</span><br><span class="line"></span><br><span class="line">local i = 1</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">  name, val = debug.getupvalue(counter, i)</span><br><span class="line">  if name then</span><br><span class="line">    print (&quot;index&quot;, i, name, &quot;=&quot;, val)</span><br><span class="line">        if(name == &quot;n&quot;) then</span><br><span class="line">                debug.setupvalue (counter,2,10)</span><br><span class="line">        end</span><br><span class="line">    i = i + 1</span><br><span class="line">  end -- if</span><br><span class="line">until not name</span><br><span class="line"></span><br><span class="line">print(counter())</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">index    1    k    =    1</span><br><span class="line">index    2    n    =    2</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>在以上实例中，计数器在每次调用时都会自增1。实例中我们使用了 getupvalue 函数查看局部变量的当前状态。我们可以设置局部变量为新值。实例中，在设置前 n 的值为 2,使用 setupvalue 函数将其设置为 10。现在我们调用函数，执行后输出为 11 而不是 3。</p>
<hr>
<h2 id="调试类型"><a href="#调试类型" class="headerlink" title="调试类型"></a>调试类型</h2><ul>
<li>命令行调试</li>
<li>图形界面调试</li>
</ul>
<p>命令行调试器有：RemDebug、clidebugger、ctrace、xdbLua、LuaInterface - Debugger、Rldb、ModDebug。</p>
<p>图形界调试器有：SciTE、Decoda、ZeroBrane Studio、akdebugger、luaedit。</p>
<hr>
<h1 id="Lua-垃圾回收"><a href="#Lua-垃圾回收" class="headerlink" title="Lua 垃圾回收"></a>Lua 垃圾回收</h1><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p>
<p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p>
<p>Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p>
<p>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</p>
<p>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的”两倍”速工作。</p>
<p>如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。</p>
<hr>
<h2 id="垃圾回收器函数"><a href="#垃圾回收器函数" class="headerlink" title="垃圾回收器函数"></a>垃圾回收器函数</h2><p>Lua 提供了以下函数**collectgarbage ([opt [, arg]])**用来控制自动内存管理:</p>
<ul>
<li><strong>collectgarbage(“collect”):</strong> 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</li>
<li><strong>collectgarbage(“count”):</strong> 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</li>
<li><strong>collectgarbage(“restart”):</strong> 重启垃圾收集器的自动运行。</li>
<li><strong>collectgarbage(“setpause”):</strong> 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。</li>
<li><strong>collectgarbage(“setstepmul”):</strong> 返回 步进倍率 的前一个值。</li>
<li><strong>collectgarbage(“step”):</strong> 单步运行垃圾收集器。 步长”大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</li>
<li><strong>collectgarbage(“stop”):</strong> 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</li>
</ul>
<p>以下演示了一个简单的垃圾回收实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mytable = &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br><span class="line"></span><br><span class="line">mytable = nil</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;collect&quot;))</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下(注意内存使用的变化)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">20.9560546875</span><br><span class="line">20.9853515625</span><br><span class="line">0</span><br><span class="line">19.4111328125</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-面向对象"><a href="#Lua-面向对象" class="headerlink" title="Lua 面向对象"></a>Lua 面向对象</h1><p>面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。</p>
<p>以下几种编程语言都支持面向对象编程：</p>
<ul>
<li>C++</li>
<li>Java</li>
<li>Objective-C</li>
<li>Smalltalk</li>
<li>C#</li>
<li>Ruby</li>
</ul>
<hr>
<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul>
<li>1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。</li>
<li>2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。</li>
<li>3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</li>
<li>4）抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</li>
</ul>
<hr>
<h2 id="Lua-中面向对象"><a href="#Lua-中面向对象" class="headerlink" title="Lua 中面向对象"></a>Lua 中面向对象</h2><p>我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</p>
<p>lua 中的 function 可以用来表示方法。那么LUA中的类可以通过 table + function 模拟出来。</p>
<p>至于继承，可以通过 metetable 模拟出来（不推荐用，只模拟最基本的对象大部分实现够用了）。</p>
<p>Lua 中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Account = &#123;balance = 0&#125;</span><br><span class="line">function Account.withdraw (v)</span><br><span class="line">    Account.balance = Account.balance - v</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Account.withdraw(100.00)</span><br></pre></td></tr></table></figure>

<h3 id="一个简单实例"><a href="#一个简单实例" class="headerlink" title="一个简单实例"></a>一个简单实例</h3><p>以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 元类</span><br><span class="line">Rectangle = &#123;area = 0, length = 0, breadth = 0&#125;</span><br><span class="line"></span><br><span class="line">-- 派生类的方法 new</span><br><span class="line">function Rectangle:new (o,length,breadth)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  self.length = length or 0</span><br><span class="line">  self.breadth = breadth or 0</span><br><span class="line">  self.area = length*breadth;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类的方法 printArea</span><br><span class="line">function Rectangle:printArea ()</span><br><span class="line">  print(&quot;矩形面积为 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = Rectangle:new(nil,10,20)</span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>我们可以使用点号(.)来访问类的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(r.length)</span><br></pre></td></tr></table></figure>

<h3 id="访问成员函数"><a href="#访问成员函数" class="headerlink" title="访问成员函数"></a>访问成员函数</h3><p>我们可以使用冒号 <strong>:</strong> 来访问类的成员函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r:printArea()</span><br></pre></td></tr></table></figure>

<p>内存在对象初始化时分配。</p>
<h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><p>以下我们演示了 Lua 面向对象的完整实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 元类</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line"></span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line"></span><br><span class="line">myshape:printArea()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面积为     100</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lua-继承"><a href="#Lua-继承" class="headerlink" title="Lua 继承"></a>Lua 继承</h2><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p>
<p>以下演示了一个简单的继承实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- Meta class</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>接下来的实例，Square 对象继承了 Shape 类:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Square = Shape:new()</span><br><span class="line">-- Derived class method new</span><br><span class="line">function Square:new (o,side)</span><br><span class="line">  o = o or Shape:new(o,side)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  return o</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="完整实例-1"><a href="#完整实例-1" class="headerlink" title="完整实例"></a>完整实例</h3><p>以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-- Meta class</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line">myshape:printArea()</span><br><span class="line"></span><br><span class="line">Square = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Square:new (o,side)</span><br><span class="line">  o = o or Shape:new(o,side)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Square:printArea ()</span><br><span class="line">  print(&quot;正方形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">mysquare = Square:new(nil,10)</span><br><span class="line">mysquare:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Rectangle:new (o,length,breadth)</span><br><span class="line">  o = o or Shape:new(o)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  self.area = length * breadth</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Rectangle:printArea ()</span><br><span class="line">  print(&quot;矩形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myrectangle = Rectangle:new(nil,10,20)</span><br><span class="line">myrectangle:printArea()</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面积为     100</span><br><span class="line">正方形面积为     100</span><br><span class="line">矩形面积为     200</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p>Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Square:printArea ()</span><br><span class="line">  print(&quot;正方形面积 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-数据库访问"><a href="#Lua-数据库访问" class="headerlink" title="Lua 数据库访问"></a>Lua 数据库访问</h1><p>本文主要为大家介绍 Lua 数据库的操作库：<a target="_blank" rel="noopener" href="http://luaforge.net/projects/luasql/">LuaSQL</a>。他是开源的，支持的数据库有：ODBC, ADO, Oracle, MySQL, SQLite 和 PostgreSQL。</p>
<p>本文为大家介绍MySQL的数据库连接。</p>
<p>LuaSQL 可以使用 <a target="_blank" rel="noopener" href="https://luarocks.org/">LuaRocks</a> 来安装可以根据需要安装你需要的数据库驱动。</p>
<p>LuaRocks 安装方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz</span><br><span class="line">$ tar zxpf luarocks-2.2.1.tar.gz</span><br><span class="line">$ cd luarocks-2.2.1</span><br><span class="line">$ ./configure; sudo make bootstrap</span><br><span class="line">$ sudo luarocks install luasocket</span><br><span class="line">$ lua</span><br><span class="line">Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; require &quot;socket&quot;</span><br></pre></td></tr></table></figure>

<p>Window 下安装 LuaRocks：<a target="_blank" rel="noopener" href="https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows">https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows</a></p>
<p>安装不同数据库驱动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">luarocks install luasql-sqlite3</span><br><span class="line">luarocks install luasql-postgres</span><br><span class="line">luarocks install luasql-mysql</span><br><span class="line">luarocks install luasql-sqlite</span><br><span class="line">luarocks install luasql-odbc</span><br></pre></td></tr></table></figure>

<p>你也可以使用源码安装方式，Lua Github 源码地址：<a target="_blank" rel="noopener" href="https://github.com/keplerproject/luasql">https://github.com/keplerproject/luasql</a></p>
<p>Lua 连接MySql 数据库：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">require &quot;luasql.mysql&quot;</span><br><span class="line"></span><br><span class="line">--创建环境对象</span><br><span class="line">env = luasql.mysql()</span><br><span class="line"></span><br><span class="line">--连接数据库</span><br><span class="line">conn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)</span><br><span class="line"></span><br><span class="line">--设置数据库的编码格式</span><br><span class="line">conn:execute&quot;SET NAMES UTF8&quot;</span><br><span class="line"></span><br><span class="line">--执行数据库操作</span><br><span class="line">cur = conn:execute(&quot;select * from role&quot;)</span><br><span class="line"></span><br><span class="line">row = cur:fetch(&#123;&#125;,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">--文件对象的创建</span><br><span class="line">file = io.open(&quot;role.txt&quot;,&quot;w+&quot;);</span><br><span class="line"></span><br><span class="line">while row do</span><br><span class="line">    var = string.format(&quot;%d %s\n&quot;, row.id, row.name)</span><br><span class="line"></span><br><span class="line">    print(var)</span><br><span class="line"></span><br><span class="line">    file:write(var)</span><br><span class="line"></span><br><span class="line">    row = cur:fetch(row,&quot;a&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file:close()  --关闭文件对象</span><br><span class="line">conn:close()  --关闭数据库连接</span><br><span class="line">env:close()   --关闭数据库环境</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/64e42d1b661c6c8e54a18cd7.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/64e42d1b661c6c8e54a18cd7.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Ame</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/')">Lua笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://blog.282994.xyz/2023/08/06/Lua%E7%AC%94%E8%AE%B0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.282994.xyz" target="_blank">AmeのBlog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://cn.mcecy.com/image/20231229/e8215887f22375c1bbce2bdd980324a6.webp?_r_=7da1ae19-cb80-1532-7c9d-0ecf432ec7ee" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/13/pythonOS/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/2e2933416d77bbc721603da53c02025a.webp?_r_=dd03dd8e-296c-38a3-6268-62e31cf3d5a5" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python3 OS</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/10/%E5%B7%A5%E4%B8%9A%E5%92%8C%E4%BF%A1%E6%81%AF%E5%8C%96%E9%83%A8%E5%85%B3%E4%BA%8E%E5%BC%80%E5%B1%95%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%87%E6%A1%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%80%9A%E7%9F%A5/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/1e035616dcfd615f08f27a1e088b23da.webp?_r_=0e11becd-ea21-ddfc-479f-cd14611c7e57" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">工业和信息化部关于开展移动互联网应用程序备案工作的通知</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.imgdb.cn/item/64e42d1b661c6c8e54a18cd7.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">愛は、科学と論理では永遠に説明できないプログラムです。</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Ame</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/yousaforever" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="mailto:yousaforever@qq.com" target="_blank" title="E-mail"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content"><div id="welcome-info"></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Lua笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-Lua-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">第一个 Lua 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">交互式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">脚本式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.1.</span> <span class="toc-text">单行注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">多行注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E7%A4%BA%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">标示符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.5.</span> <span class="toc-text">关键词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.</span> <span class="toc-text">全局变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Lua 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nil%EF%BC%88%E7%A9%BA%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">nil（空）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean%EF%BC%88%E5%B8%83%E5%B0%94%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">boolean（布尔）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#number%EF%BC%88%E6%95%B0%E5%AD%97%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">number（数字）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">string（字符串）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table%EF%BC%88%E8%A1%A8%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">table（表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">function（函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread%EF%BC%88%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">thread（线程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#userdata%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">userdata（自定义类型）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">Lua 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">赋值语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">3.2.</span> <span class="toc-text">索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.</span> <span class="toc-text">Lua 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">循环控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.</span> <span class="toc-text">无限循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">Lua 流程控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">Lua 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">6.2.</span> <span class="toc-text">多返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">Lua 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">7.3.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.4.</span> <span class="toc-text">其他运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">7.4.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.5.</span> <span class="toc-text">运算符优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">7.5.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">Lua 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">8.1.</span> <span class="toc-text">字符串长度计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">8.2.</span> <span class="toc-text">字符串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96"><span class="toc-number">8.2.1.</span> <span class="toc-text">字符串截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.2.</span> <span class="toc-text">字符串大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E4%B8%8E%E5%8F%8D%E8%BD%AC"><span class="toc-number">8.2.3.</span> <span class="toc-text">字符串查找与反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">8.2.4.</span> <span class="toc-text">字符串格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.5.</span> <span class="toc-text">字符与整数相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.6.</span> <span class="toc-text">其他常用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.7.</span> <span class="toc-text">匹配模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%95%B0%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">Lua 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">9.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">9.2.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">Lua 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-for-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">泛型 for 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.2.</span> <span class="toc-text">无状态的迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.3.</span> <span class="toc-text">多状态的迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-table-%E8%A1%A8"><span class="toc-number">11.</span> <span class="toc-text">Lua table(表)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#table-%E8%A1%A8-%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">11.1.</span> <span class="toc-text">table(表)的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Table-%E6%93%8D%E4%BD%9C"><span class="toc-number">11.2.</span> <span class="toc-text">Table 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Table-%E8%BF%9E%E6%8E%A5"><span class="toc-number">11.2.1.</span> <span class="toc-text">Table 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E7%A7%BB%E9%99%A4"><span class="toc-number">11.2.2.</span> <span class="toc-text">插入和移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Table-%E6%8E%92%E5%BA%8F"><span class="toc-number">11.2.3.</span> <span class="toc-text">Table 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Table-%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">11.2.4.</span> <span class="toc-text">Table 最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85"><span class="toc-number">12.</span> <span class="toc-text">Lua 模块与包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#require-%E5%87%BD%E6%95%B0"><span class="toc-number">12.1.</span> <span class="toc-text">require 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">12.1.1.</span> <span class="toc-text">加载机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%8C%85"><span class="toc-number">12.2.</span> <span class="toc-text">C 包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%85%83%E8%A1%A8-Metatable"><span class="toc-number">13.</span> <span class="toc-text">Lua 元表(Metatable)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#index-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">__index 元方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newindex-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">__newindex 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E8%A1%A8%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">13.3.</span> <span class="toc-text">为表添加操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">__call 元方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tostring-%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">13.5.</span> <span class="toc-text">__tostring 元方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F-coroutine"><span class="toc-number">14.</span> <span class="toc-text">Lua 协同程序(coroutine)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%90%8C-coroutine-%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">什么是协同(coroutine)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">14.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">14.3.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E5%90%8C%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB"><span class="toc-number">14.4.</span> <span class="toc-text">线程和协同程序区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%96%87%E4%BB%B6-I-O"><span class="toc-number">15.</span> <span class="toc-text">Lua 文件 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">简单模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">完全模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">Lua 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"><span class="toc-number">16.1.</span> <span class="toc-text">语法错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF"><span class="toc-number">16.2.</span> <span class="toc-text">运行错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">16.3.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#error%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.1.</span> <span class="toc-text">error函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pcall-%E5%92%8C-xpcall%E3%80%81debug"><span class="toc-number">16.4.</span> <span class="toc-text">pcall 和 xpcall、debug</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E8%B0%83%E8%AF%95-Debug"><span class="toc-number">17.</span> <span class="toc-text">Lua 调试(Debug)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.1.</span> <span class="toc-text">调试类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">18.</span> <span class="toc-text">Lua 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">18.1.</span> <span class="toc-text">垃圾回收器函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.</span> <span class="toc-text">Lua 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81"><span class="toc-number">19.1.</span> <span class="toc-text">面向对象特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E4%B8%AD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.2.</span> <span class="toc-text">Lua 中面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">19.2.1.</span> <span class="toc-text">一个简单实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">19.2.2.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">19.2.3.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">19.2.4.</span> <span class="toc-text">访问成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B"><span class="toc-number">19.2.5.</span> <span class="toc-text">完整实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E7%BB%A7%E6%89%BF"><span class="toc-number">19.3.</span> <span class="toc-text">Lua 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">19.3.1.</span> <span class="toc-text">完整实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99"><span class="toc-number">19.4.</span> <span class="toc-text">函数重写</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE"><span class="toc-number">20.</span> <span class="toc-text">Lua 数据库访问</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/30/%E7%95%99%E7%BB%992023%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" title="留给2023的一封信"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/e8215887f22375c1bbce2bdd980324a6.webp?_r_=7da1ae19-cb80-1532-7c9d-0ecf432ec7ee" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="留给2023的一封信"/></a><div class="content"><a class="title" href="/2023/12/30/%E7%95%99%E7%BB%992023%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/" title="留给2023的一封信">留给2023的一封信</a><time datetime="2023-12-30T05:00:53.000Z" title="发表于 2023-12-30 13:00:53">2023-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/23/%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA/" title="本地网盘搭建"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/4568d941df0d36f8f8eef7ff5c9d8adf.webp?_r_=41e0d1f8-5118-4a5b-69b3-3437bc3c81db" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="本地网盘搭建"/></a><div class="content"><a class="title" href="/2023/12/23/%E6%9C%AC%E5%9C%B0%E7%BD%91%E7%9B%98%E6%90%AD%E5%BB%BA/" title="本地网盘搭建">本地网盘搭建</a><time datetime="2023-12-23T04:13:37.000Z" title="发表于 2023-12-23 12:13:37">2023-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/16/2023%C2%B712%C2%B7%E6%95%B0%E5%AD%A6/" title="2023·12·数学"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/447fb6bbf46f51e2db36227fd943acfa.webp?_r_=248aa291-f40d-f64f-fa47-510cc937ce43" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023·12·数学"/></a><div class="content"><a class="title" href="/2023/12/16/2023%C2%B712%C2%B7%E6%95%B0%E5%AD%A6/" title="2023·12·数学">2023·12·数学</a><time datetime="2023-12-16T10:53:13.000Z" title="发表于 2023-12-16 18:53:13">2023-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/16/PC%E4%B8%B2%E6%B5%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BE%E5%A4%87/" title="PC串流移动端设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/e8215887f22375c1bbce2bdd980324a6.webp?_r_=dc3c6722-9395-afc8-1afe-5953971fefeb" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PC串流移动端设备"/></a><div class="content"><a class="title" href="/2023/12/16/PC%E4%B8%B2%E6%B5%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BE%E5%A4%87/" title="PC串流移动端设备">PC串流移动端设备</a><time datetime="2023-12-16T09:43:41.000Z" title="发表于 2023-12-16 17:43:41">2023-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/09/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%C2%B7%E9%98%BF%E5%9F%BA%E7%B1%B3%E5%BE%B7%E4%B8%89%E8%A7%92%E5%BD%A2/" title="圆锥曲线·阿基米德三角形"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cn.mcecy.com/image/20231229/e9912f1cc15f8a6fad38b3531d1cbfd8.webp?_r_=e70a404f-1fc6-6ca7-99f5-61cdf7d36c5b" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="圆锥曲线·阿基米德三角形"/></a><div class="content"><a class="title" href="/2023/12/09/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF%C2%B7%E9%98%BF%E5%9F%BA%E7%B1%B3%E5%BE%B7%E4%B8%89%E8%A7%92%E5%BD%A2/" title="圆锥曲线·阿基米德三角形">圆锥曲线·阿基米德三角形</a><time datetime="2023-12-09T03:20:57.000Z" title="发表于 2023-12-09 11:20:57">2023-12-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="说说" href="/essay/">说说</a><a class="footer-item" title="更新日志" href="/updates/">更新日志</a><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a></div></div><div class="footer-group"><div class="footer-title">文章</div><div class="footer-links"><a class="footer-item" title="归档" href="/archives/">归档</a><a class="footer-item" title="标签" href="/tags/">标签</a><a class="footer-item" title="分类" href="/categories/">分类</a></div></div><div class="footer-group"><div class="footer-title">我的</div><div class="footer-links"><a class="footer-item" title="关于本人" href="/about/">关于本人</a><a class="footer-item" title="音乐馆" href="/music/?id=168314790&amp;server=netease">音乐馆</a><a class="footer-item" title="相册集" href="/album/">相册集</a></div></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2024 By <a class="footer-bar-link" href="/" title="Ame" target="_blank">Ame</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/yousaforever/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://icp.gov.moe/?keyword=20239014" title="萌ICP备20239014号">萌ICP备20239014号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://search.ecnu.cf/" title="Google镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/google.ico" alt="Google镜像"/><span class="back-menu-item-text">Google镜像</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh.wikipedia.ecnu.cf/" title="Wikipedia镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/Wikipedia.ico" alt="Wikipedia镜像"/><span class="back-menu-item-text">Wikipedia镜像</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://hub.nuaa.cf/" title="Github镜像"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/github.ico" alt="Github镜像"/><span class="back-menu-item-text">Github镜像</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://fastgit.282994.xyz/" title="GitHub文件加速"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/fastgit.ico" alt="GitHub文件加速"/><span class="back-menu-item-text">GitHub文件加速</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 分享</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="anzhiyufont anzhiyu-icon-book faa-tada" style="font-size: 0.9em;"></i><span> 图书</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/resources/"><i class="anzhiyufont anzhiyu-icon-inbox faa-tada" style="font-size: 0.9em;"></i><span> 资源</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/?id=168314790&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 说说</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="anzhiyufont anzhiyu-icon-calendar-days faa-tada" style="font-size: 0.9em;"></i><span> 统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友链</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/Github/" style="font-size: 0.88rem;">Github<sup>2</sup></a><a href="/tags/OpenAI/" style="font-size: 0.88rem;">OpenAI<sup>1</sup></a><a href="/tags/PyTorch/" style="font-size: 0.88rem;">PyTorch<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>13</sup></a><a href="/tags/SpaceX/" style="font-size: 0.88rem;">SpaceX<sup>2</sup></a><a href="/tags/Windows/" style="font-size: 0.88rem;">Windows<sup>1</sup></a><a href="/tags/huggingface/" style="font-size: 0.88rem;">huggingface<sup>1</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/" style="font-size: 0.88rem;">云服务<sup>2</sup></a><a href="/tags/%E5%8E%9F%E7%A5%9E/" style="font-size: 0.88rem;">原神<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>3</sup></a><a href="/tags/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF/" style="font-size: 0.88rem;">圆锥曲线<sup>4</sup></a><a href="/tags/%E5%AE%89%E7%9F%A5%E9%B1%BC/" style="font-size: 0.88rem;">安知鱼<sup>6</sup></a><a href="/tags/%E5%B0%8F%E8%AF%B4/" style="font-size: 0.88rem;">小说<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>1</sup></a><a href="/tags/%E7%A1%AC%E4%BB%B6/" style="font-size: 0.88rem;">硬件<sup>2</sup></a><a href="/tags/%E7%A1%AC%E7%9B%98/" style="font-size: 0.88rem;">硬盘<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%9B%98/" style="font-size: 0.88rem;">网盘<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">网络<sup>3</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 0.88rem;">计算机<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="168314790" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=168314790&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2022 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Ame 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://comment.486916.xyz',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://comment.486916.xyz',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://comment.486916.xyz',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@282994.xyz";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script defer="true" src="/js/welcome.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/charts/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start --><script>const copyright_enable = true </script>
<script src="https://unpkg.com/turndown/dist/turndown.js"></script>

<script src="https://cdn.jsdelivr.net/npm/hexo-butterfly-copymarkdown@1.0.4/lib/copyMarkdown.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/hexo-butterfly-copymarkdown@1.0.4/lib/reprint.min.js"></script>
<!-- hexo injector body_end end --></body></html>