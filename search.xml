<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B站视频测试</title>
    <url>/2023/04/02/B%E7%AB%99%E8%A7%86%E9%A2%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>测试</p>
<span id="more"></span>

<div style="position:relative; padding-bottom:75%; width:100%; height:0">
    <iframe src="//player.bilibili.com/player.html?bvid=BV1D24y1B7FA&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"></iframe>
</div>
> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码：</span><br><span class="line">&lt;div style=&quot;position:relative; padding-bottom:75%; width:100%; height:0&quot;&gt;</span><br><span class="line">    &lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1D24y1B7FA&amp;amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position:absolute; height: 100%; width: 100%;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CUDA</title>
    <url>/2023/05/27/CUDA/</url>
    <content><![CDATA[<h1 id="CUDA：并行计算的新时代"><a href="#CUDA：并行计算的新时代" class="headerlink" title="CUDA：并行计算的新时代"></a>CUDA：并行计算的新时代</h1><p>CUDA（Compute Unified Device Architecture，计算统一设备架构）是英伟达公司推出的一种显卡计算框架，它可以利用显卡的并行计算能力，提高计算效率，实现各种复杂的计算任务。本文将简单介绍CUDA的基本原理和应用。</p>
<span id="more"></span>

<h2 id="CUDA的原理"><a href="#CUDA的原理" class="headerlink" title="CUDA的原理"></a>CUDA的原理</h2><p>CUDA的原理是基于GPU（图形处理器）的并行计算能力。GPU在处理图像、视频等高密度数据时的并行能力非常强，因为它内部包含了许多处理核心（CUDA核心），这些核心可以同时处理多个数据。</p>
<p>CUDA使用了一种称为<code>“kernel”</code>的并行计算单元，通过将数据分配给不同的核心，使它们同时处理这些数据，从而提高计算效率。每个核心可以处理一个小片（通常是几百个）数据，这些小片被组合成一个大的任务，通过并行处理这些任务，可以极大地加快计算速度。</p>
<h2 id="CUDA的应用"><a href="#CUDA的应用" class="headerlink" title="CUDA的应用"></a>CUDA的应用</h2><p>CUDA被广泛应用于各种领域的计算任务，包括科学计算、深度学习、人工智能等。</p>
<p>在科学计算中，CUDA可以加速许多计算密集型的任务，比如矩阵运算、大规模数据处理等。借助CUDA并行计算的能力，科学家们可以更快速、更准确地解决各种难题。</p>
<p>在深度学习和人工智能领域，CUDA则被广泛用于训练神经网络。神经网络的训练需要大量的矩阵计算和梯度计算，使用CUDA可以加速这些计算，从而大大提高训练速度和精度。</p>
<h2 id="使用CUDA进行开发"><a href="#使用CUDA进行开发" class="headerlink" title="使用CUDA进行开发"></a>使用CUDA进行开发</h2><p>在使用CUDA进行开发时，需要使用CUDA的编程语言，如CUDA C&#x2F;C++。这个语言和普通的C&#x2F;C++语言类似，但是它包含了一些特殊的语法和API，可以调用GPU上的核心进行并行计算。</p>
]]></content>
  </entry>
  <entry>
    <title>2023高考作文</title>
    <url>/2023/06/07/2023%E9%AB%98%E8%80%83%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<h1 id="全国甲卷"><a href="#全国甲卷" class="headerlink" title="全国甲卷"></a><strong>全国甲卷</strong></h1><span id="more"></span>

<p>试题内容：</p>
<p>阅读下面的材料，根据要求写作。（60分）</p>
<p>人们因技术发展得以更好地掌控时间，但也有人因此成了时间的仆人。</p>
<p>这句话引发了你怎样的联想与思考？请写一篇文章。</p>
<p>要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>“时间”是这道写作试题材料的重要关键词，时间的有限性、不可重复性，构成了探索人生意义的基本前提。人与时间的关系是永恒的主题。如何安排时间、驾驭时间，是人类自我意识的彰显。生活中，对时间的计划、安排与体验，就是时间观念的具体表现；这是考生立意行文时感受与思考的起点，也是入手写作一个最直接的切入点。</p>
<p>“技术”，是材料里的另一个关键词。在人与时间的关系中，“技术”是一个重要变量。怎样通过技术更好地掌控时间？利用像编写计划单、任务书、行程表等一些技术，我们得以更好地规划日程、安排学习；利用工业革命诞生的一些技术，如机器生产、交通工具，我们得以扩大交往范围，拓宽时空界限；利用信息技术及互联网，如智能手机、智能家居、智能物流等，我们得以让经历的时间变得更有质量。</p>
<p>材料中“时间的仆人”是个比喻，指在时间面前没有了自我，本想掌控时间却事与愿违，反倒被时间所左右，丧失掉自己的主体地位。这种情况并不鲜见。因为依赖技术，生活变得机械、刻板，例如拘泥于时间计划表，忽略灵活性、自主性；受日程支配，疲于赶进度，没有自己的独处时间。这的确是不少高中生的备考学习状态，在高中的最后阶段，触及这个话题并不敏感，有必要重新审视人面对时间的态度，“一张一弛”“博观约取”并不是奢侈的想法，是现实中很多好学生已有的学习品质。在知识获取的同时，适度地有一些“放空”的时间，在沉潜思考中去形成自己的思想才是学习的要义。</p>
<p>从材料中，考生可以提炼出“技术发展在人与时间的关系中所起的作用”这样一个论述主题。考生可以围绕这个论题，结合个人体验情境，或社会生活情境，或学科认知情境，观察、梳理相应的现象，通过分析思考，形成自己的认识与观点；考生也可以围绕“技术、时间与人”之间的关系进行探究，思考技术给掌控时间带来的便利与遗憾，还可以就人在时间流逝过程中的主动与被动，以及人掌控时间的方式方法等等进行阐释论证。当然也可以择取一个现象、一个故事、一段经历写记叙文；如有学生能写出富有想象力的科幻小品，也在立意的范围之内。</p>
<p>这道作文题文字简洁，意蕴丰富，给考生写作留下充分的思考空间。它不同于以前限制了写作指向的命题式作文，不同于给定了情境任务的写作，也不同于以往的材料式作文，简洁的导引文字推动学生自己去想象生活中的现象，形成明确观点或相对凝练的感受，并以记叙、抒情、议论等不同方式表达出来，避免面面俱到然而却浅尝辄止或简单罗列正反两面现象然而却没有主见的写作。联想与归纳、实证与推理、批判与发现这些高度综合的思辨能力，在写作过程中得以体现。“解题”的过程正是思维展开的过程，也是学习的过程，考试与教学也就这样统一起来。</p>
<h2 id="文心一言"><a href="#文心一言" class="headerlink" title="文心一言"></a>文心一言</h2><p>标题：时间的驾驭：技术的赠礼与奴役的陷阱</p>
<p>时间，万物之尺度，自古以来即为人类所崇敬与畏惧。尽管如此，人们依然通过技术发展的力量，更好地掌握时间。然此中蕴含的哲理，却值得我们深思。莎士比亚曾写道，“时间是一位伟大的导师，它的时钟不停地教我们如何成长。” 然而，现今社会，技术使我们愈加依赖时间，使我们成为其仆人。</p>
<p>首先，技术使我们能够更好地掌握时间。古语有云，“一寸光阴一寸金，寸金难买寸光阴”。然而，随着科技的进步，我们能够以秒为单位规划生活，最大限度地利用时间。从古代的日晷、漏壶，到现代的电子计时器、智能手机，技术的发展使我们得以更好地掌握时间。在此过程中，我们不仅提高了效率，而且将时间提升为生产力和价值的尺度。</p>
<p>然而，技术也使我们成为了时间的奴隶。当我们在追求效率、掌控时间的道路上越走越远，当我们把时间视为衡量一切的标准，我们便陷入了时间的牢笼，成为了时间的奴隶。古人云，“欲速则不达”，然而在现今社会，我们为了追求速度和效率，往往忽视了生活的质量。我们的生活被无数的任务、邮件、社交媒体填满，以至于我们忘记了生活并非仅仅是为了生存。</p>
<p>此外，技术的发展也让我们失去了对时间的感知。当我们的生活被智能手机的计时器、闹钟所主导，我们便逐渐忘记了自然的时间感。古人云，“日有所思，夜有所梦”。然而，当我们失去了对时间的感知，我们也便失去了对生活的感知。我们不再欣赏日出日落，不再感叹春华秋实，而是陷入了无尽的任务和工作中。</p>
<p>尽管如此，我们仍可以通过审视自身，重新找回对生活的感知。正如塞涅卡所说：“不是因为生活困苦，而是因为你太脆弱。”我们需要学会放慢脚步，去感受生活的美好，去理解时间的真正意义。时间并非我们用以追求效率的工具，而是我们生活的见证者，是我们回忆的载体。</p>
<p>我们要明白的是，技术并非罪恶本身，而是我们如何使用技术的态度决定了我们是否成为时间的奴隶。我们应当审视自己的态度和行为，将技术作为工具而非主宰我们生活的力量。正如埃克苏佩里在《小王子》中写道：“重要的东西是看不见的”，我们应当去寻找那些重要的东西，比如友情、爱情、亲情，比如梦想、信念、希望。这些都是让我们的人生变得丰富和有意义的东西，而非我们成为时间的奴隶的原因。</p>
<p>总之，技术的发展使我们得以更好地掌握时间，但同时也使我们成为了时间的奴隶。因此，我们需要重新审视我们的态度和行为，重新找回对生活的感知。只有这样，我们才能真正地驾驭时间，而非被时间所驾驭。正如莎士比亚在《罗密欧与朱丽叶》中所说：“让时间成为你的指南针，而不是你的监狱门。” 我们应当让时间成为我们的导师，而非我们的牢笼。</p>
<h2 id="GPT-3-5"><a href="#GPT-3-5" class="headerlink" title="GPT-3.5"></a>GPT-3.5</h2><p>随着现代科技的飞速发展，人们的时间管理越来越得心应手。现今的世界，手机、电脑等电子设备的普及，让我们在任何时间、任何地点都能快速地获取信息和联系他人，减少了许多等待和浪费时间的环节。大多数人也都能够巧妙地运用科技和各种工具，让自己的时间得到更好的利用。但是，科技的发展也与此形成了鲜明的对比──有些人就像“时间的仆人”，在这个快节奏的现代社会中忙碌了一生，却始终无法摆脱时间的束缚。</p>
<p>究竟是什么原因造成了这种现象呢？恐怕是因为我们过于依赖科技和工具，而失去了对时间的主动掌控。在疫情期间尤其明显：随着线上办公和远程学习的普及，我们的生活和工作被电子设备彻底占据，仿佛离开了电脑和手机，就无法生存。因此，我们需要反思：到底是科技在为我们服务，还是我们成为了科技的奴隶？</p>
<p>科技的发展并非一日之功，它为我们的生活、工作和娱乐带来了诸多便利，大大缩短了时间和空间的距离。然而，过度依赖科技也会有诸多弊端。首先，时间的使用效率下降。电子产品上繁琐的操作和无数不必要的信息噪音让我们心生厌烦，浪费时间和精力。其次，我们对时间的掌控力也随之减弱。当我们需要下班休息或者学习课程已经结束，却因为沉迷于电子设备而无法自拔；或者我们曾经喜欢的读书、运动等正能量活动因为时间的“不够用”而被搁置，都表明了我们已经处于科技的掌控之下。</p>
<p>因此，我们需要转变观念，从被动的时间管理者变为主动的时间管理者，协调好科技和传统时代的平衡。从媒体报道和现实生活中我们可以看到，一些人成功地做到了这一点。他们有着良好的时间管理能力，能够通过规划自己的时间来做到高效工作和生活；他们也对科技的使用有明确的目的和限度，能够合理地利用电子设备带来的便利。这一切都源于他们对时间的重视和对自己的规划。</p>
<p>在这个发展万物的时代，我们需要反思科技发展的本质，思考如何用科技带来好处，而不是将其作为我们的走狗。时间是我们的资源，我们应该尊重它，花费在有价值的事情上，而不是在无聊的事情上浪费。未来，让我们成为真正的时间主人，掌控好自己的时间，过上更加高质量、充实、健康的生活。</p>
<hr>
<h1 id="全国乙卷"><a href="#全国乙卷" class="headerlink" title="全国乙卷"></a><strong>全国乙卷</strong></h1><p>试题内容：</p>
<p>阅读下面的材料，根据要求写作。（60分）</p>
<p>吹灭别人的灯，并不会让自己更加光明；阻挡别人的路，也不会让自己行得更远。</p>
<p>“一花独放不是春，百花齐放春满园。”如果世界上只有一种花朵，就算这种花朵再美，那也是单调的。</p>
<p>以上两则材料出自习近平总书记的讲话，以生动形象的语言说出了普遍的道理。请据此写一篇文章，体现你的认识与思考。</p>
<p>要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>2023年3月15日，习近平总书记在北京出席中国共产党与世界政党高层对话会，并发表题为《携手同行现代化之路》的主旨讲话；2014年3月27日，习近平总书记在联合国教科文组织总部作《文明因交流而多彩，文明因互鉴而丰富》主题演讲。本作文题的两个材料，分别出自上述两个讲话，针对的是国际关系、文明互鉴等时代命题，揭示的道理却是普遍的，语言生动形象，蕴含着大智慧。</p>
<p>材料一，吹灭别人的灯、阻挡别人的路，看起来抢了一时的“先机”，实则为人不齿，终将被他人排斥。生动朴素的文字中所蕴含的为人处世之道启人深思。材料二，借“一花”和“百花”阐述了部分和整体的辩证关系，“一花”和“百花”相互联系，“一花”之美是在“百花”中得到凸显的，而“百花”之春又是建立在“一花”的基础上的。不同文化之间的交流、不同国家之间的联系、人与集体及社会的关系，莫不如此。材料一与材料二并举，构成了一组对话关系。材料一说的是不应怎样，材料二提供了行动思路。</p>
<p>学生在把握这两则材料的内涵、关系基础上，可写的空间与切入角度是相当多的。熟悉政治、了解国际大事的同学可以就一些重大问题发表自己的见解，例如互利共赢的开放战略、文明的多样性、构建人类命运共同体等，也可以结合当下核心技术领域“卡脖子”困境的解决去探讨科技发展中的自力更生与借鉴学习。“情者文之经，辞者理之纬”，在语文卷出现这道题，与政治卷中的作答是不一样的，“认识与思考”不是在讲立意和结论本身，重点在于立意与结论的形成过程。前述对作文材料的立意阐释，在文章写作中应转化为对鲜活事例的展现、对丰富事实的分析。那些事实材料在心中涌现，得以筛选并经语言文字外化的过程，也是内在思维的碰撞过程、情感的激荡过程。少一些空泛议论，多一些典型事例，多一些真情实感，立论才有依托，文章也才能真正打动人。</p>
<p>从材料字面回到生活与成长，也能写出很好的议论或记叙文章。如果学生能结合个人生活与求学经历，从身边具体事例谈起，通过生动的细节描写能让读者返回“现场”，写活场景中的人与事，写透对材料的认识，这不只是考场上令人满意的作文答卷，也是学生对中学时代提交的思想认识与生活总结，正是学生语文核心素养发展阶段的具体表现。两则材料都“以生动形象的语言说出了普遍的道理”。如果学生能够从这两则材料出发，联想到更多的语用典型案例，阐释出阅读鉴赏、表达交流的普遍规律，也可谓独辟蹊径的好文章。</p>
<p>语文是立德树人的独特载体，其育人价值是在真实的语言运用情境中体现出来的。这道写作试题所涉及的考查意图与目标，既是普遍的，也是个性的；既是抽象的，也是鲜活的；既是主题教育的，又是语言文字的。所谓“经正而后纬成，理定而后辞畅”，语言是表达思想的工具，文章要立得住，要对每则材料各自的观点、两则材料之间的联系有充分的认识，并能有丰富的延展。寓思政于语文之中，以语文体现思政的道理，正是试题的初心。</p>
<h2 id="文心一言-1"><a href="#文心一言-1" class="headerlink" title="文心一言"></a>文心一言</h2><p>标题：互助之光，百花齐放</p>
<p>吹灭别人的灯，并不会让自己更加光明；阻挡别人的路，也不会让自己行得更远。这样的言辞，我们在生活中时常听到，它反映出一种互助共赢的思想。又如“一花独放不是春，百花齐放春满园”，这句古语告诉我们，只有多种花竞相开放，才能让世界更加美丽。这两则材料以生动形象的语言说出了普遍的道理，即只有合作共赢，才能使个人、团体、社会以及世界变得更加美好。</p>
<p>互助之光，是一种深刻的人性光辉。自古以来，人类就是群居动物，我们依赖于彼此，才能生存和发展。当我们面临困难和挑战时，只有通过互相帮助，才能克服困难，实现共同进步。比如古人云：“三人行，必有我师焉”，这不仅是一种谦虚的态度，也是一种互助的精神。每个人都可以在其他人身上找到值得学习的优点，从而相互促进，使整个团队的水平得到提升。</p>
<p>百花齐放，是一种包容的理念。在社会的舞台上，每个人都有自己的角色和价值，只有各种不同的思想、文化、艺术等交融碰撞，才能创造出丰富多彩的世界。如同花园中的百花齐放，每一种花都有其独特的色彩和香气，共同构成了美丽的图景。同样，在人类社会中，每个人都应该被尊重和理解，每种文化都应该被传承和发扬，每种思想都应该被探讨和交流，这样才能让我们的世界更加多元化和充满活力。</p>
<p>然而，现实生活中，我们时常看到一些人试图吹灭别人的灯，阻挡别人的路。他们或是出于嫉妒，或是出于狭隘的利益考虑，忘记了只有通过互助共赢，才能实现个人和社会的共同进步。因此，我们要警惕这种消极的行为，同时也要积极培养互助共赢的精神，从而创造一个更加美好的世界。</p>
<p>互助之光，百花齐放。这不仅是一种理念，也是一种行动。在我们的日常生活中，我们可以从小事做起，培养互助共赢的精神。比如在团队合作中，我们可以多关注他人的需求和想法，积极提供帮助和支持；在社交场合，我们可以多倾听他人的观点，尊重他人的文化和习惯；在个人成长中，我们可以多学习他人的优点和长处，同时也要勇于展示自己的个性和特点。只有我们秉持着互助共赢和百花齐放的精神，才能让我们的个人和社会变得更加美好。</p>
<p>综上所述，互助之光和百花齐放的理念在我们的生活中具有重要的意义。我们要认识到只有通过互助共赢和包容不同的思想和文化，才能实现个人和社会的共同进步。让我们共同努力，培养互助共赢和百花齐放的精神，创造一个更加美好的世界。</p>
<h2 id="GPT-3-5-1"><a href="#GPT-3-5-1" class="headerlink" title="GPT-3.5"></a>GPT-3.5</h2><p>标题：和谐的融合</p>
<p>近年来，随着中国国力的不断增强，越来越多的人开始关注“中国崛起”的话题。但是，有些人似乎只看到了自己的光芒，却忽略了周围花草的美丽。这样的做法不仅是短视的，而且也是不可持续的，因为只有共同发展才能实现真正的长远发展。因此，我们需要摒弃“吹灭别人的灯”和“阻挡别人的路”的思维方式，而要推崇“一花独放不是春，百花齐放春满园”的合作态度。</p>
<p>首先，我们应该认识到，各个国家的崛起都是相互联系的，而不是相互对立的。世界上的每个国家都有自己的特色和优势，这些特色和优势可以互补，让彼此的发展更具活力和优势。在全球化时代，各个国家之间的联系日益紧密，任何国家的发展都与其他国家息息相关。如果我们只注重自己的发展，而不关心其他国家的发展，就有可能滋生矛盾和冲突，最终导致我们的崛起难以为继。因此，我们应该将自己的发展与其他国家的发展紧密联系起来，以实现互利共赢。</p>
<p>其次，我们应该强调多样性和包容性。世界上的每个国家都有自己独特的文化背景和历史积淀，这些都是不能被替代的。我们应该欣赏和尊重不同国家的文化和价值观念，并在这些基础上进行交流和合作。在这个过程中，我们要以包容的心态来对待其他国家的缺点和不足，同时也要不断完善自己，让自己更加优秀和具有竞争力。</p>
<p>最后，我们应该认识到，合作是推动世界发展的动力。我们需要摒弃零和思维，而要推崇合作、互助和共赢。只有通过合作，我们才能共同实现更快的发展和更广泛的进步。如果我们只注重个人利益，而不考虑整体利益，就会导致短期内的利益得到一定的保障，但是长远来看，却无法实现真正的长远发展。因此，我们应该树立“合作共赢”的价值观念，让世界更加美好。</p>
<p>综上所述，“吹灭别人的灯”和“阻挡别人的路”并不是我们追求的目标，而是会导致我们走向相反的方向。只有保持“一花独放不是春，百花齐放春满园”的合作态度，才能实现真正的和谐发展。我们需要在合作中实现自己的价值，同时也要为其他国家的发展贡献自己的力量。只有这样，我们才能让世界变得更加美好。</p>
<hr>
<h1 id="新课标I卷"><a href="#新课标I卷" class="headerlink" title="新课标I卷"></a><strong>新课标I卷</strong></h1><p>试题内容：</p>
<p>阅读下面的材料，根据要求写作。（60分）</p>
<p>好的故事，可以帮我们更好地表达和沟通，可以触动心灵、启迪智慧；好的故事，可以改变一个人的命运，可以展现一个民族的形象……故事是有力量的。</p>
<p>以上材料引发了你怎样的联想和思考？请写一篇文章。</p>
<p>要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>材料列举了“好的故事”在不同情境和场合发挥的不同作用，最后一句话“故事是有力量的”是材料的主旨。考生可以根据材料所列举的代表性场景内容，展开丰富的联想和深入的思考。</p>
<p>远在原始时代，人类就通过讲述神话和传说，团结部族，形成合力；春秋战国时期诸子百家常通过寓言等故事阐发学说；秦汉以来，故事变得日益丰富，成为中华优秀传统文化的一个组成部分和喜闻乐见的表达方式；当代社会，各类故事层出不穷，像我们熟悉的革命英雄的事迹、春天的故事……极大地丰富了我们的精神生活。大多数考生成长过程中都有听故事的经历，对各类故事的力量都有着或多或少的真切感受，因此本题题材范围很广，贴近考生生活，考生可以根据材料列举的内容，展开联想和思考，选择最有创意也最适合自己的题材写作。</p>
<p>关于什么是好的故事，可以有不同的评判标准。有的故事胜在情节曲折，有的则胜在人物生动；有的故事优点在通俗易懂，有的故事优点在思想深刻……一般来说，从故事的内容着眼来判断故事的优劣，是考生比较熟悉的方式，至于故事的讲述方法，是对故事力量的进一步理解，是对故事艺术的进一步认识，自然也是题中之义。</p>
<p>故事的力量如何发挥，在何种情境下发挥，可以想象的空间非常广。生活中，好的故事可以增进人们相互之间的理解和认同，帮助我们更好地表达和沟通；好的故事可以触动心灵，激发我们战胜困难的勇气；好的故事，可以拓展我们的视野，赋予我们应对各种复杂局面的智慧；个人的命运可以通过一个好的故事改变轨迹，国家的形象可以通过好的故事得到充分展现。考生可以根据自己的经验、想象和思考选择合适的角度来立意，既可以从自己的经历中，选择印象最深的部分，讲述故事如何发挥力量；也可以自行设计情境，讲述故事所带给人的力量，带给社会的能量，或带给时代的影响。</p>
<p>这个话题各类不同文体均有可以发挥自身文体优势的地方。考生可以记叙自己或他人生活中的故事和感悟；可以对某个现象进行综合分析，对某个论题加以充分论证；也可以探讨怎么讲故事才能让故事更有力量等问题。既可以书写日常生活中的微观方面和个性感触，也可以思考如何讲好中国故事与中国形象等宏观问题。本题审题难度不大，也体现了对考生的友好。</p>
<h2 id="文心一言-2"><a href="#文心一言-2" class="headerlink" title="文心一言"></a>文心一言</h2><p>标题：好故事的魅力与力量</p>
<p>好故事如同一壶醇香四溢的好茶，它的魅力在于能引人入胜，让人流连忘返，同时又能滋润心灵，启迪智慧。人生就像一部长篇小说，由无数的情节和故事串联而成，而好故事则像一颗颗璀璨的珍珠，镶嵌在人生的道路上，给我们带来无尽的启示和力量。</p>
<p>好的故事可以帮助我们更好地表达和沟通。在人际交往中，有时候我们很难用言语表达出内心深处的想法和情感，而好的故事则可以借助于形象生动的描绘和细腻入微的情感，让我们更好地传递自己的意图。如同诗人白居易所说：“文章合为时而著，歌诗合为事而作。”好的故事就是这样，它可以深入人心，引发共鸣，让人们在阅读的过程中感受到心灵的触动和启迪。</p>
<p>好故事可以帮助我们启迪智慧。从《格林童话》到四大名著，这些经典的故事不仅给我们带来了阅读的快乐，更重要的是，它们帮助我们理解生活，理解人性，启发我们的智慧。如杨洪基在《梦醒时分》中唱道：“生活就像一部电影，人人都在演戏，有时候会迷失自己，后来我才懂得，人生最美的风景是经历。” 好故事就是这样，它让我们在欣赏故事的同时，也能从中汲取智慧和力量。</p>
<p>好的故事可以改变一个人的命运。无数的事实证明，一个人的经历和所接受的文化熏陶，都可以改变他的人生轨迹。如莎士比亚在《罗密欧与朱丽叶》中所述：“人生就像舞台，我们都是演员。” 我们每一个人都在人生的舞台上扮演着不同的角色，而好故事则如同明灯指引我们前进的方向。</p>
<p>好的故事可以展现一个民族的形象。从《水浒传》到《红楼梦》，从《西游记》到《三国演义》，这些经典的故事作品不仅展现了中华民族的深厚文化底蕴，也向世界展示了一个丰富多彩、博大精深的中华文化形象。如鲁迅先生在《狂人日记》中所说：“我们的文化是博大精深的海洋,任你徜徉。” 好的故事就是这样，它让我们在欣赏故事的同时，也能为我们的民族文化而自豪。</p>
<p>好故事的魅力与力量无处不在，它不仅给我们带来了精神的愉悦和启迪，更重要的，它让我们更好的表达和沟通，更好的理解生活，理解人性，从而让我们的人生更加精彩。如赵本夫在《英雄无泪》中所说：“人生如同一场梦，而故事则是梦中的色彩。” 好故事就是这样一个色彩斑斓的梦，它让我们的生活变得更加丰富多彩。</p>
<p>总结，好故事的魅力与力量是无穷的。它滋润心灵，启迪智慧，改变命运，展现民族形象，带给我们快乐、启示和力量。而我们也要珍惜每一个好故事，用心去感受、去品味、去传播，让它在我们的生活中绽放出更加灿烂的光芒。</p>
<h2 id="GPT-3-5-2"><a href="#GPT-3-5-2" class="headerlink" title="GPT-3.5"></a>GPT-3.5</h2><p>故事的力量：让我们更好地表达和沟通</p>
<p>故事是一种古老而又神秘的艺术形式，它不仅能够为我们提供娱乐，还能够激发我们的想象力、振奋我们的情感、影响我们的价值观和信仰。好的故事，能够让我们更好地表达和沟通，这是它无穷的魅力所在。</p>
<p>故事中的人物和情节，往往是真实世界的缩影。故事中的人物和情节，往往是我们身边发生的事情。当我们读到一个故事时，我们可能会对其中的某些细节感同身受，这时，故事就成为了我们表达自己内心世界的桥梁。比如，当我们读到一个关于友谊的故事时，我们可能会想起自己和朋友之间的点点滴滴，这时，故事就成为了我们表达友情的工具。同样，当我们读到一个关于家庭和亲情的故事时，我们可能会想起自己的家庭和亲情，这时，故事就成为了我们表达感恩之情的工具。</p>
<p>故事是一种非常有效的沟通工具，可以帮助我们更好地沟通。当我们想要表达自己某个观点或者意见时，我们往往会遇到一些困难。因为我们的观点或者意见可能比较抽象，不容易被理解。但是，如果我们将这个观点或者意见通过一个故事来表达，就会有更好的效果。因为故事中的情节和人物可以使我们的观点或者意见变得更加生动、形象，更容易被人们理解和接受。</p>
<p>故事还可以帮助我们更好地沟通跨文化和跨国家的差异。不同的文化和国家之间，往往会有很大的差异，这样的差异可能会导致一些误解和不理解。但是，如果我们用故事来表达自己的观点，那么就可以避免这样的误解和不理解。因为故事中的情节和人物具有普遍性，可以被不同文化和国家的人所理解和接受。比如，在一个跨文化的交流中，如果我们想要表达自己对于自由的看法，我们可以通过讲一个关于自由的故事来表达。</p>
<p>总之，故事是一种非常有力的工具，可以帮助我们更好地表达和沟通。好的故事，可以触动我们的心灵，启迪我们的智慧，改变我们的命运，展现一个民族的形象。因此，我们应该珍惜故事的力量，用好它，去创造更美好的世界。</p>
<hr>
<h1 id="新课标II卷"><a href="#新课标II卷" class="headerlink" title="新课标II卷"></a><strong>新课标II卷</strong></h1><p>试题内容：</p>
<p>阅读下面的材料，根据要求写作。（60分）</p>
<p>本试卷语言文字运用II提到的“安静一下不被打扰”的想法，在当代青少年中也不鲜见。青少年在学习、生活中，有时希望有一个自己的空间，放松，沉淀，成长。</p>
<p>请结合以上材料写一篇文章。</p>
<p>要求：选准角度，确定立意，明确文体，自拟标题；不要套作，不得抄袭；不得泄露个人信息；不少于800字。</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>这是一道读写结合类型的作文题。读写结合类型的作文题，是根据试卷内其他模块的材料，衍生出相关的作文话题，写作与卷内其他模块材料有一定的关联性和对话性。为避免写作受到阅读因素的制约，选择了关联相对浅显的语用材料。</p>
<p>作文试题，通过语言文字运用II的材料中提及的“安静一下不被打扰”的想法，引出“青少年在学习、生活中，有时希望有一个自己的空间”的话题。材料所说的“自己的空间”，可以指现实中的空间，也可以指向虚拟的空间。“希望有”是一个意愿，值得肯定。青春期的高中生处于少年向青年的过渡期，生活中面临着自我发展、青春友谊等各种困惑，也面临学习任务繁重、求学压力大等问题，有时会表现出一些稍显自我的情绪，让长辈担心，甚至被认为“谁也不爱”，这种定性反而可能会把青少年推向封闭的自我空间。而试题以“放松，沉淀，成长”定位，就是命题者对青少年成长需求的一种换位思考，是就“安静一下不被打扰”“希望有一个自己的空间”所做出的善意表达，意在理解青少年，激励青少年健康成长。习近平总书记《在纪念五四运动100周年大会上的讲话》中指出：“我们要主动走近青年、倾听青年，做青年朋友的知心人。”作文试题呼应了这一要求。</p>
<p>对于青少年来说，“自己的空间”具有独特的精神价值，是放松心情、安放心思、积蓄力量、为继续成长加油充电的地方，那里有自己的烦恼与愿望，以及朋友的友谊、社会的关切、未来的想象等等。考生可以通过对自己空间内容的介绍，或就怎样打造“自己的空间”立意行文，展示自己的成长故事；可以就为什么想有“自己的空间”倾诉心声，与父母师长对话，告诉他们，对于我们想有“自己的空间”不必过虑，这是成长过程中的正常现象；可以思考“自己的空间”的存在意义，比如通过自己的空间可以暂时得到放松，可以沉淀自己的情绪、思考和想法，让自己得以更好成长；还可以反思“自己的空间”的局限性，避免只是从自身角度、单一视角来认识和理解世界。语言文字运用II中提到的戴耳机只是一种方式，这个信息起提示作用，考生可以由此联想到其他方式，如阅读、写日记、做剪报、独自跑步等，都能为青年营造一个自己的空间。</p>
<p>作文试题贴近考生实际，引导考生思考“自己的空间”的意义内涵及相关问题，正面引导青少年勇敢面对成长过程中的困惑与问题，激励青少年建康成长。话题内容明确，选题立意简易，便于考生展开思考与联想，写出具有真情实感的文章。</p>
<h2 id="文心一言-3"><a href="#文心一言-3" class="headerlink" title="文心一言"></a>文心一言</h2><p>《安静的力量》</p>
<p>“安静一下不被打扰”的想法，在当代青少年中并不鲜见。面对快节奏的生活，我们常常感到疲惫、烦躁，希望有一个自己的空间，放松，沉淀，成长。</p>
<p>在这个喧嚣的社会中，我们很难找到一个真正属于自己的空间。即使我们关上房门，也还有手机、电脑等各种电子设备在干扰我们。我们的生活节奏越来越快，我们的压力越来越大，我们的时间越来越宝贵，我们很难找到一个真正属于自己的空间。</p>
<p>但是，我们不能被生活所累，我们需要有自己的空间来放松自己，沉淀自己。这个空间可以是一段独处的时间，可以是一首抒情的音乐，可以是一幅美丽的画作，可以是一本好书，可以是一处旅游胜地。这个空间可以很小，也可以很大，只要能让我们静下心来，让我们沉淀自己，让我们更好地面对生活就行。</p>
<p>有时我会想，我们为什么不能把生活变成这个空间呢？为什么不能把生活变得轻松一些、自在一些呢？我们不需要在快节奏的生活中一路狂奔，我们需要在适当的时候停下来，等一等我们的灵魂。我们需要安静一下不被打扰，我们需要沉淀自己，以便更好地面对生活。</p>
<p>安静的力量是巨大的，它可以让我们放松下来，沉淀自己，更好地面对生活。当我们安静下来不被打扰时，我们可以更好地思考问题，更好地发现自己，更好地成长。安静的力量是宝贵的，它可以让我们更好地面对生活，更好地成长。</p>
<p>“安静一下不被打扰”的想法并不鲜见，但我们不能让这种想法成为我们的借口，我们要学会在喧嚣的生活中找到自己的空间。只有在安静下来不被打扰时，我们才能更好地面对生活、更好地成长。</p>
<p>青少年在学习、生活中，有时希望有一个自己的空间，放松，沉淀，成长。我们要学会在喧嚣的生活中找到自己的空间，让自己安静下来不被打扰。只有在安静下来不被打扰时，我们才能更好地面对生活、更好地成长。</p>
<p>总之，“安静一下不被打扰”的想法并不鲜见，但在喧嚣的生活中寻找自己的空间并不容易。我们要学会在适当的时候停下来，等一等我们的灵魂，让自己安静下来不被打扰。只有在安静下来不被打扰时，我们才能更好地面对生活、更好地成长。</p>
<h2 id="GPT-3-5-3"><a href="#GPT-3-5-3" class="headerlink" title="GPT-3.5"></a>GPT-3.5</h2><p>标题：青少年需要自己的“安静一下”时间</p>
<p>随着时代的变迁，当今社会节奏愈加快速，人们的生活也变得越来越繁忙。而对于青少年来说，作为一个处于成长阶段的人群，他们需要承受着家庭、学校以及社会的各种压力。因此，他们更加需要有一个自己的空间，来缓解压力、放松身心、沉淀思维，这也正是“安静一下不被打扰”的想法所体现的意义。</p>
<p>首先，青少年需要自己的空间来释放压力。在青少年的成长过程中，面临着家庭、学校、社会的各种压力，如学习压力、人际关系压力、自我认同压力等。如果身处一个没有自己空间的环境中，这些压力会不断地困扰着他们，甚至导致情绪失控。而有一个属于自己的空间，可以有效地让他们对自己的想法、情感进行排解和调节，从而达到缓解压力的效果。</p>
<p>其次，青少年需要自己的空间来放松身心。在日常学习和生活中，青少年需要集中精力进行学习和思考，这种状态会让他们感到疲惫和疲倦。此时，他们需要有一个自己的空间，可以让他们放松身心，调整好状态，以积极的心态迎接下一个挑战。</p>
<p>最后，青少年需要自己的空间来沉淀思维。现代社会信息爆炸，青少年面临着各种信息和知识的洪流，而这些信息和知识很难在短时间内被他们完全吸收和理解。在这种情况下，有一个自己的空间，可以让他们进行思考、整理、归纳，从而更好地吸收和理解知识。</p>
<p>综上所述，青少年需要自己的空间，来缓解压力、放松身心、沉淀思维。而这个“安静一下不被打扰”的想法，在现代社会青少年中也越来越受到重视。因此，我们应该给予青少年一个自由、和谐、安静的成长环境，让他们能够拥有一个属于自己的空间，释放压力、放松身心、沉淀思维，在成长的路上走得更加自信和坚定。</p>
]]></content>
  </entry>
  <entry>
    <title>Microsoft Copilot</title>
    <url>/2023/03/26/Copilot/</url>
    <content><![CDATA[<blockquote>
<p><strong>Humans are hard-wired to dream, to create, to innovate.</strong> <span id="more"></span>Each of us seeks to do work that gives us purpose — to write a great novel, to make a discovery, to build strong communities, to care for the sick. The urge to connect to the core of our work lives in all of us. But today, we spend too much time consumed by the drudgery of work on tasks that zap our time, creativity and energy. <strong>To reconnect to the soul of our work, we don’t just need a better way of doing the same things. We need a whole new way to work。</strong></p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/641ffb1fa682492fcc887ce9.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>GPT-3模型</title>
    <url>/2023/03/12/GPT-3%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="模型综述"><a href="#模型综述" class="headerlink" title="模型综述"></a>模型综述</h2><span id="more"></span>

<h2 id="GPT-3：海量参数"><a href="#GPT-3：海量参数" class="headerlink" title="GPT-3：海量参数"></a>GPT-3：海量参数</h2><blockquote>
<p>延续GPT的模型架构，用更多的数据，更大的模型，训练模型。<br>预测时，不需要Finetune，在某些任务上小样本条件下也能达到和BERT媲美的性能。<br>预测时，分别用自然语言描述任务（零样本）、一个示例（单样本，和人类学习很像）、少量示例作为上文文本，将续写的文本作为预测结果。</p>
</blockquote>
<blockquote>
<p>GPT-3共训练了5个不同的语料，分别是低质量的Common Crawl，高质量的WebText2，Books1，Books2和Wikipedia，GPT-3根据数据集的不同的质量赋予了不同的权值，权值越高的在训练的时候越容易抽样到，如图所示。</p>
<p><img src="https://pic.imgdb.cn/item/64284bf0a682492fcc162cce.jpg"></p>
</blockquote>
<blockquote>
<p>GPT-3沿用了GPT-2的结构，但是在网络容量上做了很大的提升，具体如下：<br>GPT-3采用了96 层的多头transformer，头的个数为96；<br>词向量的长度是 12888；<br>上下文划窗的窗口大小提升至2048个token；</p>
</blockquote>
<table>
<thead>
<tr>
<th>模型名称</th>
<th>描述</th>
<th>最大tokens</th>
<th>训练数据</th>
</tr>
</thead>
<tbody><tr>
<td>text-davinci-003</td>
<td>最强大的GPT-3模型。 具有更高的输出质量、 更长的输出内容 和更好的语言理解能力。 还支持文本插入功能。</td>
<td>4,000 tokens</td>
<td>截至2021年6月</td>
</tr>
<tr>
<td>text-curie-001</td>
<td>功能强大， 但比<code>Davinci</code>速度更快，价格也更便宜。</td>
<td>2,048 tokens</td>
<td>截至2019年10月</td>
</tr>
<tr>
<td>text-babbage-001</td>
<td>能够完成简单任务，速度快，成本低。</td>
<td>2,048 tokens</td>
<td>截至2019年10月</td>
</tr>
<tr>
<td>text-ada-001</td>
<td>能够完成非常简单的任务， 通常是GPT-3系列中速度最快的，成本最低的。</td>
<td>2,048 tokens</td>
<td>截至2019年10月</td>
</tr>
</tbody></table>
<h2 id="Codex子模型"><a href="#Codex子模型" class="headerlink" title="Codex子模型"></a>Codex子模型</h2><table>
<thead>
<tr>
<th>模型名称</th>
<th>描述</th>
<th>最大请求</th>
<th>训练数据</th>
</tr>
</thead>
<tbody><tr>
<td>code-davinci-002</td>
<td>最强大的Codex模型。 特别擅长将自然语言转译成代码。 除了完成代码外，还支持在代码补全。</td>
<td>8,000 tokens</td>
<td>截至2021年6月</td>
</tr>
<tr>
<td>code-cushman-001</td>
<td>几乎与<code>Davinci Codex</code>一样强大，但速度稍快。 这种速度优势可使其更适合于实时应用。</td>
<td>2,048 tokens</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>GPT-4paper解读</title>
    <url>/2023/04/01/GPT-4paper%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p><strong>GPT-4paper解读：</strong></p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table>
<thead>
<tr>
<th>官方总结</th>
<th>我们已经创建了GPT-4，这是OpenAI在扩大深度学习方面的最新里程碑。GPT-4是一个大型多模态模型(接受图像和文本输入，输出文本)，虽然在许多现实场景中不如人类，但在各种专业和学术基准上表现出与人类相当的性能。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>简介</strong></td>
<td>GPT-4是一个超大的多模态模型，它的输入可以是文字（上限约2.4万单词），还可以是图像。由于其更广泛的常识和先进的推理能力，它可以比我们之前的任何模型更准确地解决难题。</td>
</tr>
<tr>
<td><strong>核心原理</strong></td>
<td>GPT-4依旧是一个基于Transformer风格的预训练模型，用于预测文档中的下一个token，使用公开可用数据(如互联网数据)和第三方提供商授权的数据，利用人类反馈的强化学习(RLHF)对模型进行微调。</td>
</tr>
<tr>
<td><strong>意义</strong></td>
<td>GPT-4性能水平和人类相当！比如模拟律师考试，GPT-4取得了前10%的好成绩，相比之下GPT-3.5却是倒数10%；再比如做美国高考SAT试题，GPT-4也在阅读写作中拿下710分高分、数学700分（满分800）。</td>
</tr>
<tr>
<td><strong>亮点</strong></td>
<td>(1)、多模态特性：强大的识图能力，可以接受图像输入并理解图像内容；<br/><br/>(2)、更长的上下文：可以接受的文字输入长度也增加到3.2万个token（约2.5万个单词文本）；<br/><br/>(3)、针对问题基于提示可以利用不同的风格进行回答；<br/><br/>(4)、更加真实性、可控性：OpenAI 花了 6 个月的时间使用对抗性测试程序和 ChatGPT 的经验教训对 GPT-4 进行迭代调整；<br/></td>
</tr>
<tr>
<td><strong>技术点</strong></td>
<td>GPT-4依旧设置技术壁垒，目前还没有公布具体模型架构、硬件、训练计算、数据集构造、训练方法的具体细节。<br/><br/>(1)、GPT-4依旧利用强化学习人类反馈 (RLHF) 来微调模型的行为：聘请了来自长期AI一致性&#x2F;对齐风险、网络安全、生物风险和国际安全等领域的50多名专家对模型进行对抗性测试；<br/><br/>(2)、GPT-4的两个技术点提高安全性：一套额外的安全相关RLHF训练提示，以及基于规则的奖励模型(RBRMs)。通过训练模型拒绝对此类内容的请求来减少有害的输出。<br/><br/>(3)、OpenAI 基于Azure从头开始设计了一台超级计算机，并重建了整个深度学习堆栈；<br/><br/>(4)、OpenAI开源了 OpenAI Evals—自动评估 AI 模型性能的框架，主要是为了让所有人都可以指出其模型中的缺点，来帮助 OpenAI 进一步改进模型。它被用于创建和运行基准测试以评估 GPT-4 等模型，同时可以逐样本地检查模型性能；<br/><br/>(5)、模型训练到部署的庞大的团队工程能力：单看报告致谢的部分，就包括了几百人。预训练模块、长上下文模块、视觉模块、强化学习与对齐模块、评估与分析模块、部署模块等工程化的各个阶段，均装备了核心负责人小组、计算集群扩展小组、数据小组、分布式训练基础设施小组、硬件正确性小组、优化与架构小组、模型训练小组团队。<br/></td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>(1)、幻觉不可靠性：GPT-4与早期GPT模型有相似的局限性：它仍然不完全可靠，它会“产生幻觉”事实，但已经比ChatGPT减轻了这一缺点。<br/><br/>(2)、依旧存在错误推理的可能性：<br/><br/>(3)、依旧会产生有害的建议：但通过50位领域专家的反馈对模型进行了改进；<br/><br/>(4)、存在偏差性：GPT-4在输出中依旧存在各种偏差；<br/><br/>(5)、GPT-4上下文窗口有限；<br/><br/>(6)、GPT-4不能从经验中学习；<br/><br/>(7)、GPT-4会在生成的代码中引入安全漏洞；<br/></td>
</tr>
</tbody></table>
<h2 id="GPT-4模型可使用版本"><a href="#GPT-4模型可使用版本" class="headerlink" title="GPT-4模型可使用版本"></a><strong>GPT-4模型可使用版本</strong></h2><table>
<thead>
<tr>
<th>最新模型</th>
<th>描述</th>
<th>最大TOKENS</th>
<th>训练数据</th>
</tr>
</thead>
<tbody><tr>
<td>gpt-4</td>
<td>比任何GPT-3.5模型更强大，能够完成更复杂的任务，并为聊天进行了优化。将与我们最新的模型迭代更新。</td>
<td>8,192 tokens</td>
<td>截至2021年9月</td>
</tr>
<tr>
<td>gpt-4-0314</td>
<td>2023年3月14日的gpt-4快照。与gpt-4不同的是，该模型将不会接受更新，并且只会在2023年6月14日结束的三个月内得到支持。</td>
<td>8,192 tokens</td>
<td>截至2021年9月</td>
</tr>
<tr>
<td>gpt-4-32k</td>
<td>与基础gpt-4模式相同的功能，但上下文长度是它的4倍。将与我们最新的模型迭代更新。</td>
<td>32,768 tokens</td>
<td>截至2021年9月</td>
</tr>
<tr>
<td>gpt-4-32k-0314</td>
<td>2023年3月14日gpt-4-32的快照。与gpt-4-32k不同的是，该型号将不接受更新，并且只支持三个月的时间，截止2023年6月14日。</td>
<td>32,768 tokens</td>
<td>截至2021年9月</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>AIGC</category>
      </categories>
  </entry>
  <entry>
    <title>DDSP-SVC-3.0</title>
    <url>/2023/05/13/DDSP-SVC-3-0/</url>
    <content><![CDATA[<p><a href="https://www.123pan.com/s/k79SVv-h8zJ.html">链接</a></p>
<p><del>没想到这玩意居然可以用来交信息作业</del></p>
<p><a href="https://filedoge.com/download/e6638b2deab855fdf7d9e94cd547338f7e84a57293110b6a9f6b42c2dfc7749f5a58c19c15020a4f98f5">作业</a></p>
<span id="more"></span>

<h1 id="数据的处理和可视化表达——DDSP-SVC音声转换"><a href="#数据的处理和可视化表达——DDSP-SVC音声转换" class="headerlink" title="数据的处理和可视化表达——DDSP-SVC音声转换"></a>数据的处理和可视化表达——DDSP-SVC音声转换</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>相较于常用的So-VITS（SoftVC VITS Singing Voice Conversion）和更早的Diff-SVC（Diffusion Probabilistic Model for Singing Voice Conversion），DDSP-SVC（Differentiable Digital Signal Processing for Singing Voice Conversion，用于歌声转换的可微分数字信号处理）在训练推理速度和配置要求上都可以说是全面优于前两个项目，一般来说只要有一张2G以上显存的N卡，花上一两个小时就可以训练完成，大大降低了AI变声的门槛。最近DDSP项目迭代到了3.0版本，在原有的基础上加入了浅扩散机制，将DDSP输出的质量较低的音频梅尔谱图输入扩散模型进行浅扩散处理，输出梅尔谱图并通过声码器转换为高质量音频，使得转换效果大幅提升，在部分数据集上可以达到媲美So-VITS的效果。所以尝试使用DDSP进行音声转换测试。</p>
<p>项目地址：<a href="https://github.com/yxlllc/DDSP-SVC">https://github.com/yxlllc/DDSP-SVC</a></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过训练得到两个模型：</p>
<ul>
<li>DDSP模型</li>
<li>扩散模型</li>
</ul>
<p>对源音频进行推理：<img src="https://pic1.imgdb.cn/item/6468a9c0e03e90d874142709.png"></p>
<h2 id="研究过程"><a href="#研究过程" class="headerlink" title="研究过程"></a>研究过程</h2><h3 id="数据采集、处理"><a href="#数据采集、处理" class="headerlink" title="数据采集、处理"></a>数据采集、处理</h3><p>通过直播回放视频进行音频分离 约1-2小时的干声素材，切片为3-15秒的音频文件</p>
<h4 id="数据的导入与预处理"><a href="#数据的导入与预处理" class="headerlink" title="数据的导入与预处理"></a>数据的导入与预处理</h4><h5 id="导入数据集和验证集"><a href="#导入数据集和验证集" class="headerlink" title="导入数据集和验证集"></a>导入数据集和验证集</h5><p>数据集导入到<code>项目目录\data\train\audio</code>文件夹下 验证集导入到<code>项目目录\data\val\audio</code>文件夹下</p>
<p>在数据集中按训练集：验证集&#x3D;100:1的比例挑选验证集音频放置到<code>data/val/audio</code>文件夹中 单说话人模型，直接将所有wav文件放置到对应的<code>audio</code>文件夹下即可。如果是训练多说话人模型，需要在训练集和验证集的<code>audio</code>文件夹下新建不同说话人的目录，只能以纯数字命名，以1开始 验证集的条数最好不要超过10条，否则训练验证会变得很慢。验证集的音频质量越高越好。</p>
<p>数据集结构：<br>data<br>├─ train<br>│ ├─ audio<br>│ │ ├─ aaa.wav<br>│ │ ├─ bbb.wav<br>│ │ └─ ….wav<br>├─ val<br>│ ├─ audio<br>│ │ ├─ eee.wav<br>│ │ ├─ fff.wav<br>│ │ └─ ….wav</p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>预处理参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">block_size:</span> <span class="number">512</span></span><br><span class="line">  <span class="attr">cnhubertsoft_gate:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">encoder:</span> <span class="string">contentvec768l12</span></span><br><span class="line">  <span class="attr">encoder_ckpt:</span> <span class="string">pretrain\contentvec\checkpoint_best_legacy_500.pt</span></span><br><span class="line">  <span class="attr">encoder_hop_size:</span> <span class="number">320</span></span><br><span class="line">  <span class="attr">encoder_out_channels:</span> <span class="number">768</span></span><br><span class="line">  <span class="attr">encoder_sample_rate:</span> <span class="number">16000</span></span><br><span class="line">  <span class="attr">f0_extractor:</span> <span class="string">crepe</span></span><br><span class="line">  <span class="attr">f0_max:</span> <span class="number">800</span></span><br><span class="line">  <span class="attr">f0_min:</span> <span class="number">65</span></span><br><span class="line">  <span class="attr">sampling_rate:</span> <span class="number">44100</span></span><br><span class="line">  <span class="attr">train_path:</span> <span class="string">data/train</span></span><br><span class="line">  <span class="attr">valid_path:</span> <span class="string">data/val</span></span><br><span class="line"><span class="attr">device:</span> <span class="string">cuda</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">expdir:</span> <span class="string">exp/diffusion-test</span></span><br><span class="line">  <span class="attr">gpu_id:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">infer:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="string">dpm-solver</span></span><br><span class="line">  <span class="attr">speedup:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">model:</span></span><br><span class="line">  <span class="attr">n_chans:</span> <span class="number">512</span></span><br><span class="line">  <span class="attr">n_hidden:</span> <span class="number">256</span></span><br><span class="line">  <span class="attr">n_layers:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">n_spk:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Diffusion</span></span><br><span class="line">  <span class="attr">use_pitch_aug:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">train:</span></span><br><span class="line">  <span class="attr">amp_dtype:</span> <span class="string">fp32</span></span><br><span class="line">  <span class="attr">batch_size:</span> <span class="number">24</span></span><br><span class="line">  <span class="attr">cache_all_data:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cache_device:</span> <span class="string">cuda</span></span><br><span class="line">  <span class="attr">cache_fp16:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decay_step:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">epochs:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">gamma:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">interval_force_save:</span> <span class="number">20000</span></span><br><span class="line">  <span class="attr">interval_log:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">interval_val:</span> <span class="number">1500</span></span><br><span class="line">  <span class="attr">lr:</span> <span class="number">0.0002</span></span><br><span class="line">  <span class="attr">num_workers:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">save_opt:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">weight_decay:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">vocoder:</span></span><br><span class="line">  <span class="attr">ckpt:</span> <span class="string">pretrain/nsf_hifigan/model</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">nsf-hifigan</span></span><br></pre></td></tr></table></figure>

<p><strong>预处理脚本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> pyworld <span class="keyword">as</span> pw</span><br><span class="line"><span class="keyword">import</span> parselmouth</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> logger <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> ddsp.vocoder <span class="keyword">import</span> F0_Extractor, Volume_Extractor, Units_Encoder</span><br><span class="line"><span class="keyword">from</span> diffusion.vocoder <span class="keyword">import</span> Vocoder</span><br><span class="line"><span class="keyword">from</span> logger.utils <span class="keyword">import</span> traverse_dir</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_args</span>(<span class="params">args=<span class="literal">None</span>, namespace=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse command-line arguments.&quot;&quot;&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--config&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;path to the config file&quot;</span>)</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;-d&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--device&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        default=<span class="literal">None</span>,</span><br><span class="line">        required=<span class="literal">False</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;cpu or cuda, auto if not set&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args(args=args, namespace=namespace)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">preprocess</span>(<span class="params">path, f0_extractor, volume_extractor, mel_extractor, units_encoder, sample_rate, hop_size, device = <span class="string">&#x27;cuda&#x27;</span>, use_pitch_aug = <span class="literal">False</span></span>):</span><br><span class="line">    </span><br><span class="line">    path_srcdir  = os.path.join(path, <span class="string">&#x27;audio&#x27;</span>)</span><br><span class="line">    path_unitsdir  = os.path.join(path, <span class="string">&#x27;units&#x27;</span>)</span><br><span class="line">    path_f0dir  = os.path.join(path, <span class="string">&#x27;f0&#x27;</span>)</span><br><span class="line">    path_volumedir  = os.path.join(path, <span class="string">&#x27;volume&#x27;</span>)</span><br><span class="line">    path_augvoldir  = os.path.join(path, <span class="string">&#x27;aug_vol&#x27;</span>)</span><br><span class="line">    path_meldir  = os.path.join(path, <span class="string">&#x27;mel&#x27;</span>)</span><br><span class="line">    path_augmeldir  = os.path.join(path, <span class="string">&#x27;aug_mel&#x27;</span>)</span><br><span class="line">    path_skipdir = os.path.join(path, <span class="string">&#x27;skip&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># list files</span></span><br><span class="line">    filelist =  traverse_dir(</span><br><span class="line">        path_srcdir,</span><br><span class="line">        extension=<span class="string">&#x27;wav&#x27;</span>,</span><br><span class="line">        is_pure=<span class="literal">True</span>,</span><br><span class="line">        is_sort=<span class="literal">True</span>,</span><br><span class="line">        is_ext=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pitch augmentation dictionary</span></span><br><span class="line">    pitch_aug_dict = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">file</span>):</span><br><span class="line">        ext = file.split(<span class="string">&#x27;.&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        binfile = file[:-(<span class="built_in">len</span>(ext)+<span class="number">1</span>)]+<span class="string">&#x27;.npy&#x27;</span></span><br><span class="line">        path_srcfile = os.path.join(path_srcdir, file)</span><br><span class="line">        path_unitsfile = os.path.join(path_unitsdir, binfile)</span><br><span class="line">        path_f0file = os.path.join(path_f0dir, binfile)</span><br><span class="line">        path_volumefile = os.path.join(path_volumedir, binfile)</span><br><span class="line">        path_augvolfile = os.path.join(path_augvoldir, binfile)</span><br><span class="line">        path_melfile = os.path.join(path_meldir, binfile)</span><br><span class="line">        path_augmelfile = os.path.join(path_augmeldir, binfile)</span><br><span class="line">        path_skipfile = os.path.join(path_skipdir, file)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># load audio</span></span><br><span class="line">        audio, _ = librosa.load(path_srcfile, sr=sample_rate)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(audio.shape) &gt; <span class="number">1</span>:</span><br><span class="line">            audio = librosa.to_mono(audio)</span><br><span class="line">        audio_t = torch.from_numpy(audio).<span class="built_in">float</span>().to(device)</span><br><span class="line">        audio_t = audio_t.unsqueeze(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># extract volume</span></span><br><span class="line">        volume = volume_extractor.extract(audio)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># extract mel and volume augmentaion</span></span><br><span class="line">        <span class="keyword">if</span> mel_extractor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mel_t = mel_extractor.extract(audio_t, sample_rate)</span><br><span class="line">            mel = mel_t.squeeze().to(<span class="string">&#x27;cpu&#x27;</span>).numpy()</span><br><span class="line">            </span><br><span class="line">            max_amp = <span class="built_in">float</span>(torch.<span class="built_in">max</span>(torch.<span class="built_in">abs</span>(audio_t))) + <span class="number">1e-5</span></span><br><span class="line">            max_shift = <span class="built_in">min</span>(<span class="number">1</span>, np.log10(<span class="number">1</span>/max_amp))</span><br><span class="line">            log10_vol_shift = random.uniform(-<span class="number">1</span>, max_shift)</span><br><span class="line">            <span class="keyword">if</span> use_pitch_aug:</span><br><span class="line">                keyshift = random.uniform(-<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                keyshift = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            aug_mel_t = mel_extractor.extract(audio_t * (<span class="number">10</span> ** log10_vol_shift), sample_rate, keyshift = keyshift)</span><br><span class="line">            aug_mel = aug_mel_t.squeeze().to(<span class="string">&#x27;cpu&#x27;</span>).numpy()</span><br><span class="line">            aug_vol = volume_extractor.extract(audio * (<span class="number">10</span> ** log10_vol_shift))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># units encode</span></span><br><span class="line">        units_t = units_encoder.encode(audio_t, sample_rate, hop_size)</span><br><span class="line">        units = units_t.squeeze().to(<span class="string">&#x27;cpu&#x27;</span>).numpy()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># extract f0</span></span><br><span class="line">        f0 = f0_extractor.extract(audio, uv_interp = <span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">        uv = f0 == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(f0[~uv]) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># interpolate the unvoiced f0</span></span><br><span class="line">            f0[uv] = np.interp(np.where(uv)[<span class="number">0</span>], np.where(~uv)[<span class="number">0</span>], f0[~uv])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># save npy     </span></span><br><span class="line">            os.makedirs(os.path.dirname(path_unitsfile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">            np.save(path_unitsfile, units)</span><br><span class="line">            os.makedirs(os.path.dirname(path_f0file), exist_ok=<span class="literal">True</span>)</span><br><span class="line">            np.save(path_f0file, f0)</span><br><span class="line">            os.makedirs(os.path.dirname(path_volumefile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">            np.save(path_volumefile, volume)</span><br><span class="line">            <span class="keyword">if</span> mel_extractor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                pitch_aug_dict[file[:-(<span class="built_in">len</span>(ext)+<span class="number">1</span>)]] = keyshift</span><br><span class="line">                os.makedirs(os.path.dirname(path_melfile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">                np.save(path_melfile, mel)</span><br><span class="line">                os.makedirs(os.path.dirname(path_augmelfile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">                np.save(path_augmelfile, aug_mel)</span><br><span class="line">                os.makedirs(os.path.dirname(path_augvolfile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">                np.save(path_augvolfile, aug_vol)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\n[Error] F0 extraction failed: &#x27;</span> + path_srcfile)</span><br><span class="line">            os.makedirs(os.path.dirname(path_skipfile), exist_ok=<span class="literal">True</span>)</span><br><span class="line">            shutil.move(path_srcfile, os.path.dirname(path_skipfile))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;This file has been moved to &#x27;</span> + path_skipfile)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Preprocess the audio clips in :&#x27;</span>, path_srcdir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># single process</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> tqdm(filelist, total=<span class="built_in">len</span>(filelist)):</span><br><span class="line">        process(file)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> mel_extractor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        path_pitchaugdict = os.path.join(path, <span class="string">&#x27;pitch_aug_dict.npy&#x27;</span>)</span><br><span class="line">        np.save(path_pitchaugdict, pitch_aug_dict)</span><br><span class="line">    <span class="comment"># multi-process (have bugs)</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    with concurrent.futures.ProcessPoolExecutor(max_workers=2) as executor:</span></span><br><span class="line"><span class="string">        list(tqdm(executor.map(process, filelist), total=len(filelist)))</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># parse commands</span></span><br><span class="line">    cmd = parse_args()</span><br><span class="line"></span><br><span class="line">    device = cmd.device</span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># load config</span></span><br><span class="line">    args = utils.load_config(cmd.config)</span><br><span class="line">    sample_rate = args.data.sampling_rate</span><br><span class="line">    hop_size = args.data.block_size</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize f0 extractor</span></span><br><span class="line">    f0_extractor = F0_Extractor(</span><br><span class="line">                        args.data.f0_extractor, </span><br><span class="line">                        args.data.sampling_rate, </span><br><span class="line">                        args.data.block_size, </span><br><span class="line">                        args.data.f0_min, </span><br><span class="line">                        args.data.f0_max)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize volume extractor</span></span><br><span class="line">    volume_extractor = Volume_Extractor(args.data.block_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize mel extractor</span></span><br><span class="line">    mel_extractor = <span class="literal">None</span></span><br><span class="line">    use_pitch_aug = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> args.model.<span class="built_in">type</span> == <span class="string">&#x27;Diffusion&#x27;</span>:</span><br><span class="line">        mel_extractor = Vocoder(args.vocoder.<span class="built_in">type</span>, args.vocoder.ckpt, device = device)</span><br><span class="line">        <span class="keyword">if</span> mel_extractor.vocoder_sample_rate != sample_rate <span class="keyword">or</span> mel_extractor.vocoder_hop_size != hop_size:</span><br><span class="line">            mel_extractor = <span class="literal">None</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Unmatch vocoder parameters, mel extraction is ignored!&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> args.model.use_pitch_aug:</span><br><span class="line">            use_pitch_aug = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># initialize units encoder</span></span><br><span class="line">    <span class="keyword">if</span> args.data.encoder == <span class="string">&#x27;cnhubertsoftfish&#x27;</span>:</span><br><span class="line">        cnhubertsoft_gate = args.data.cnhubertsoft_gate</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cnhubertsoft_gate = <span class="number">10</span></span><br><span class="line">    units_encoder = Units_Encoder(</span><br><span class="line">                        args.data.encoder, </span><br><span class="line">                        args.data.encoder_ckpt, </span><br><span class="line">                        args.data.encoder_sample_rate, </span><br><span class="line">                        args.data.encoder_hop_size,</span><br><span class="line">                        cnhubertsoft_gate=cnhubertsoft_gate,</span><br><span class="line">                        device = device)    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># preprocess training set</span></span><br><span class="line">    preprocess(args.data.train_path, f0_extractor, volume_extractor, mel_extractor, units_encoder, sample_rate, hop_size, device = device, use_pitch_aug = use_pitch_aug)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># preprocess validation set</span></span><br><span class="line">    preprocess(args.data.valid_path, f0_extractor, volume_extractor, mel_extractor, units_encoder, sample_rate, hop_size, device = device, use_pitch_aug = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><h4 id="DDSP模型训练"><a href="#DDSP模型训练" class="headerlink" title="DDSP模型训练"></a>DDSP模型训练</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">block_size:</span> <span class="number">512</span></span><br><span class="line">  <span class="attr">cnhubertsoft_gate:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">encoder:</span> <span class="string">contentvec768l12</span></span><br><span class="line">  <span class="attr">encoder_ckpt:</span> <span class="string">pretrain\contentvec\checkpoint_best_legacy_500.pt</span></span><br><span class="line">  <span class="attr">encoder_hop_size:</span> <span class="number">320</span></span><br><span class="line">  <span class="attr">encoder_out_channels:</span> <span class="number">768</span></span><br><span class="line">  <span class="attr">encoder_sample_rate:</span> <span class="number">16000</span></span><br><span class="line">  <span class="attr">f0_extractor:</span> <span class="string">crepe</span></span><br><span class="line">  <span class="attr">f0_max:</span> <span class="number">800</span></span><br><span class="line">  <span class="attr">f0_min:</span> <span class="number">65</span></span><br><span class="line">  <span class="attr">sampling_rate:</span> <span class="number">44100</span></span><br><span class="line">  <span class="attr">train_path:</span> <span class="string">data/train</span></span><br><span class="line">  <span class="attr">valid_path:</span> <span class="string">data/val</span></span><br><span class="line"><span class="attr">device:</span> <span class="string">cuda</span></span><br><span class="line"><span class="attr">enhancer:</span></span><br><span class="line">  <span class="attr">ckpt:</span> <span class="string">pretrain/nsf_hifigan/model</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">nsf-hifigan</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">expdir:</span> <span class="string">exp/combsub-test</span></span><br><span class="line">  <span class="attr">gpu_id:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">loss:</span></span><br><span class="line">  <span class="attr">fft_max:</span> <span class="number">2048</span></span><br><span class="line">  <span class="attr">fft_min:</span> <span class="number">256</span></span><br><span class="line">  <span class="attr">n_scale:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">model:</span></span><br><span class="line">  <span class="attr">n_spk:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">CombSubFast</span></span><br><span class="line"><span class="attr">train:</span></span><br><span class="line">  <span class="attr">batch_size:</span> <span class="number">28</span></span><br><span class="line">  <span class="attr">cache_all_data:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cache_device:</span> <span class="string">cuda</span></span><br><span class="line">  <span class="attr">cache_fp16:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">epochs:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">interval_log:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">interval_val:</span> <span class="number">1500</span></span><br><span class="line">  <span class="attr">lr:</span> <span class="number">0.0005</span></span><br><span class="line">  <span class="attr">num_workers:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">save_opt:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">weight_decay:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="训练脚本"><a href="#训练脚本" class="headerlink" title="训练脚本"></a>训练脚本</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> logger <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">from</span> data_loaders <span class="keyword">import</span> get_data_loaders</span><br><span class="line"><span class="keyword">from</span> solver <span class="keyword">import</span> train</span><br><span class="line"><span class="keyword">from</span> ddsp.vocoder <span class="keyword">import</span> Sins, CombSub, CombSubFast</span><br><span class="line"><span class="keyword">from</span> ddsp.loss <span class="keyword">import</span> RSSLoss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_args</span>(<span class="params">args=<span class="literal">None</span>, namespace=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse command-line arguments.&quot;&quot;&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--config&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;path to the config file&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args(args=args, namespace=namespace)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># parse commands</span></span><br><span class="line">    cmd = parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load config</span></span><br><span class="line">    args = utils.load_config(cmd.config)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &gt; config:&#x27;</span>, cmd.config)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &gt;    exp:&#x27;</span>, args.env.expdir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># load model</span></span><br><span class="line">    model = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> args.model.<span class="built_in">type</span> == <span class="string">&#x27;Sins&#x27;</span>:</span><br><span class="line">        model = Sins(</span><br><span class="line">            sampling_rate=args.data.sampling_rate,</span><br><span class="line">            block_size=args.data.block_size,</span><br><span class="line">            n_harmonics=args.model.n_harmonics,</span><br><span class="line">            n_mag_allpass=args.model.n_mag_allpass,</span><br><span class="line">            n_mag_noise=args.model.n_mag_noise,</span><br><span class="line">            n_unit=args.data.encoder_out_channels,</span><br><span class="line">            n_spk=args.model.n_spk)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> args.model.<span class="built_in">type</span> == <span class="string">&#x27;CombSub&#x27;</span>:</span><br><span class="line">        model = CombSub(</span><br><span class="line">            sampling_rate=args.data.sampling_rate,</span><br><span class="line">            block_size=args.data.block_size,</span><br><span class="line">            n_mag_allpass=args.model.n_mag_allpass,</span><br><span class="line">            n_mag_harmonic=args.model.n_mag_harmonic,</span><br><span class="line">            n_mag_noise=args.model.n_mag_noise,</span><br><span class="line">            n_unit=args.data.encoder_out_channels,</span><br><span class="line">            n_spk=args.model.n_spk)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">elif</span> args.model.<span class="built_in">type</span> == <span class="string">&#x27;CombSubFast&#x27;</span>:</span><br><span class="line">        model = CombSubFast(</span><br><span class="line">            sampling_rate=args.data.sampling_rate,</span><br><span class="line">            block_size=args.data.block_size,</span><br><span class="line">            n_unit=args.data.encoder_out_channels,</span><br><span class="line">            n_spk=args.model.n_spk)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot; [x] Unknown Model: <span class="subst">&#123;args.model.<span class="built_in">type</span>&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load parameters</span></span><br><span class="line">    optimizer = torch.optim.AdamW(model.parameters())</span><br><span class="line">    initial_global_step, model, optimizer = utils.load_model(args.env.expdir, model, optimizer, device=args.device)</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">&#x27;lr&#x27;</span>] = args.train.lr</span><br><span class="line">        param_group[<span class="string">&#x27;weight_decay&#x27;</span>] = args.train.weight_decay</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    loss_func = RSSLoss(args.loss.fft_min, args.loss.fft_max, args.loss.n_scale, device = args.device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># device</span></span><br><span class="line">    <span class="keyword">if</span> args.device == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">        torch.cuda.set_device(args.env.gpu_id)</span><br><span class="line">    model.to(args.device)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> optimizer.state.values():</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">            <span class="keyword">if</span> torch.is_tensor(v):</span><br><span class="line">                state[k] = v.to(args.device)</span><br><span class="line">                    </span><br><span class="line">    loss_func.to(args.device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># datas</span></span><br><span class="line">    loader_train, loader_valid = get_data_loaders(args, whole_audio=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run</span></span><br><span class="line">    train(args, initial_global_step, model, optimizer, loss_func, loader_train, loader_valid)</span><br></pre></td></tr></table></figure>

<h4 id="扩散模型训练"><a href="#扩散模型训练" class="headerlink" title="扩散模型训练"></a>扩散模型训练</h4><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">f0_extractor:</span> <span class="string">crepe</span></span><br><span class="line">  <span class="attr">f0_min:</span> <span class="number">65</span></span><br><span class="line">  <span class="attr">f0_max:</span> <span class="number">800</span></span><br><span class="line">  <span class="attr">sampling_rate:</span> <span class="number">44100</span></span><br><span class="line">  <span class="attr">block_size:</span> <span class="number">512</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">encoder:</span> <span class="string">contentvec768l12</span></span><br><span class="line">  <span class="attr">cnhubertsoft_gate:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">encoder_sample_rate:</span> <span class="number">16000</span></span><br><span class="line">  <span class="attr">encoder_hop_size:</span> <span class="number">320</span></span><br><span class="line">  <span class="attr">encoder_out_channels:</span> <span class="number">768</span></span><br><span class="line">  <span class="attr">encoder_ckpt:</span> <span class="string">pretrain\contentvec\checkpoint_best_legacy_500.pt</span></span><br><span class="line">  <span class="attr">train_path:</span> <span class="string">data/train</span></span><br><span class="line">  <span class="attr">valid_path:</span> <span class="string">data/val</span></span><br><span class="line"><span class="attr">model:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Diffusion</span></span><br><span class="line">  <span class="attr">n_layers:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">n_chans:</span> <span class="number">512</span></span><br><span class="line">  <span class="attr">n_hidden:</span> <span class="number">256</span></span><br><span class="line">  <span class="attr">use_pitch_aug:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">n_spk:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">device:</span> <span class="string">cuda</span></span><br><span class="line"><span class="attr">vocoder:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">nsf-hifigan</span></span><br><span class="line">  <span class="attr">ckpt:</span> <span class="string">pretrain/nsf_hifigan/model</span></span><br><span class="line"><span class="attr">infer:</span></span><br><span class="line">  <span class="attr">speedup:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">method:</span> <span class="string">dpm-solver</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">expdir:</span> <span class="string">exp/diffusion-test</span></span><br><span class="line">  <span class="attr">gpu_id:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">train:</span></span><br><span class="line">  <span class="attr">num_workers:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">amp_dtype:</span> <span class="string">fp32</span></span><br><span class="line">  <span class="attr">batch_size:</span> <span class="number">24</span></span><br><span class="line">  <span class="attr">cache_all_data:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cache_device:</span> <span class="string">cuda</span></span><br><span class="line">  <span class="attr">cache_fp16:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">epochs:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">interval_log:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">interval_val:</span> <span class="number">1500</span></span><br><span class="line">  <span class="attr">interval_force_save:</span> <span class="number">20000</span></span><br><span class="line">  <span class="attr">lr:</span> <span class="number">0.0002</span></span><br><span class="line">  <span class="attr">decay_step:</span> <span class="number">100000</span></span><br><span class="line">  <span class="attr">gamma:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">weight_decay:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">save_opt:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="训练脚本-1"><a href="#训练脚本-1" class="headerlink" title="训练脚本"></a>训练脚本</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">from</span> logger <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">from</span> diffusion.data_loaders <span class="keyword">import</span> get_data_loaders</span><br><span class="line"><span class="keyword">from</span> diffusion.solver <span class="keyword">import</span> train</span><br><span class="line"><span class="keyword">from</span> diffusion.unit2mel <span class="keyword">import</span> Unit2Mel</span><br><span class="line"><span class="keyword">from</span> diffusion.vocoder <span class="keyword">import</span> Vocoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_args</span>(<span class="params">args=<span class="literal">None</span>, namespace=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse command-line arguments.&quot;&quot;&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(</span><br><span class="line">        <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--config&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">&quot;path to the config file&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args(args=args, namespace=namespace)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># parse commands</span></span><br><span class="line">    cmd = parse_args()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load config</span></span><br><span class="line">    args = utils.load_config(cmd.config)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &gt; config:&#x27;</span>, cmd.config)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &gt;    exp:&#x27;</span>, args.env.expdir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load vocoder</span></span><br><span class="line">    vocoder = Vocoder(args.vocoder.<span class="built_in">type</span>, args.vocoder.ckpt, device=args.device)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load model</span></span><br><span class="line">    model = Unit2Mel(</span><br><span class="line">                args.data.encoder_out_channels, </span><br><span class="line">                args.model.n_spk,</span><br><span class="line">                args.model.use_pitch_aug,</span><br><span class="line">                vocoder.dimension,</span><br><span class="line">                args.model.n_layers,</span><br><span class="line">                args.model.n_chans,</span><br><span class="line">                args.model.n_hidden)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># load parameters</span></span><br><span class="line">    optimizer = torch.optim.AdamW(model.parameters())</span><br><span class="line">    initial_global_step, model, optimizer = utils.load_model(args.env.expdir, model, optimizer, device=args.device)</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">&#x27;lr&#x27;</span>] = args.train.lr</span><br><span class="line">        param_group[<span class="string">&#x27;weight_decay&#x27;</span>] = args.train.weight_decay</span><br><span class="line">    scheduler = lr_scheduler.StepLR(optimizer, step_size=args.train.decay_step, gamma=args.train.gamma)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># device</span></span><br><span class="line">    <span class="keyword">if</span> args.device == <span class="string">&#x27;cuda&#x27;</span>:</span><br><span class="line">        torch.cuda.set_device(args.env.gpu_id)</span><br><span class="line">    model.to(args.device)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> state <span class="keyword">in</span> optimizer.state.values():</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">            <span class="keyword">if</span> torch.is_tensor(v):</span><br><span class="line">                state[k] = v.to(args.device)</span><br><span class="line">                    </span><br><span class="line">    <span class="comment"># datas</span></span><br><span class="line">    loader_train, loader_valid = get_data_loaders(args, whole_audio=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># run</span></span><br><span class="line">    train(args, initial_global_step, model, optimizer, scheduler, vocoder, loader_train, loader_valid)</span><br></pre></td></tr></table></figure>

<h4 id="性能评估"><a href="#性能评估" class="headerlink" title="性能评估"></a>性能评估</h4><h5 id="DDSP模型训练日志"><a href="#DDSP模型训练日志" class="headerlink" title="DDSP模型训练日志"></a>DDSP模型训练日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--- model size ---</span><br><span class="line">model: 4,000,518</span><br><span class="line">======= start training =======</span><br><span class="line">epoch: 0 |   9/ 47 | exp/combsub-test | batch/s: 1.35 | loss: 5.327 | time: 0:00:07.5 | step: 10</span><br><span class="line">epoch: 0 |  19/ 47 | exp/combsub-test | batch/s: 3.44 | loss: 4.606 | time: 0:00:10.4 | step: 20</span><br><span class="line">epoch: 0 |  29/ 47 | exp/combsub-test | batch/s: 3.48 | loss: 4.182 | time: 0:00:13.3 | step: 30</span><br><span class="line">epoch: 0 |  39/ 47 | exp/combsub-test | batch/s: 3.58 | loss: 3.385 | time: 0:00:16.0 | step: 40</span><br><span class="line">epoch: 1 |   2/ 47 | exp/combsub-test | batch/s: 3.73 | loss: 3.502 | time: 0:00:18.7 | step: 50</span><br><span class="line">epoch: 1 |  12/ 47 | exp/combsub-test | batch/s: 3.92 | loss: 3.372 | time: 0:00:21.3 | step: 60</span><br><span class="line">epoch: 1 |  22/ 47 | exp/combsub-test | batch/s: 3.52 | loss: 2.708 | time: 0:00:24.1 | step: 70</span><br><span class="line">epoch: 1 |  32/ 47 | exp/combsub-test | batch/s: 3.61 | loss: 2.679 | time: 0:00:26.9 | step: 80</span><br><span class="line">epoch: 1 |  42/ 47 | exp/combsub-test | batch/s: 3.58 | loss: 2.132 | time: 0:00:29.7 | step: 90</span><br><span class="line">epoch: 2 |   5/ 47 | exp/combsub-test | batch/s: 4.02 | loss: 2.151 | time: 0:00:32.2 | step: 100</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">epoch: 61 |  32/ 47 | exp/combsub-test | batch/s: 4.97 | loss: 1.073 | time: 0:10:41.3 | step: 8900</span><br><span class="line">epoch: 61 |  42/ 47 | exp/combsub-test | batch/s: 4.95 | loss: 1.113 | time: 0:10:43.3 | step: 8910</span><br><span class="line">epoch: 62 |   5/ 47 | exp/combsub-test | batch/s: 4.84 | loss: 1.056 | time: 0:10:45.4 | step: 8920</span><br><span class="line">epoch: 62 |  15/ 47 | exp/combsub-test | batch/s: 4.88 | loss: 1.082 | time: 0:10:47.4 | step: 8930</span><br><span class="line">epoch: 62 |  25/ 47 | exp/combsub-test | batch/s: 5.00 | loss: 1.094 | time: 0:10:49.4 | step: 8940</span><br><span class="line">epoch: 62 |  35/ 47 | exp/combsub-test | batch/s: 4.96 | loss: 1.042 | time: 0:10:51.4 | step: 8950</span><br><span class="line">epoch: 62 |  45/ 47 | exp/combsub-test | batch/s: 5.02 | loss: 1.065 | time: 0:10:53.4 | step: 8960</span><br><span class="line">epoch: 63 |   8/ 47 | exp/combsub-test | batch/s: 4.98 | loss: 1.102 | time: 0:10:55.4 | step: 8970</span><br><span class="line">epoch: 63 |  18/ 47 | exp/combsub-test | batch/s: 5.10 | loss: 1.080 | time: 0:10:57.4 | step: 8980</span><br><span class="line">epoch: 63 |  28/ 47 | exp/combsub-test | batch/s: 5.00 | loss: 1.064 | time: 0:10:59.4 | step: 8990</span><br><span class="line">epoch: 63 |  38/ 47 | exp/combsub-test | batch/s: 4.95 | loss: 1.069 | time: 0:11:01.4 | step: 9000</span><br><span class="line">--- &lt;validation&gt; --- </span><br><span class="line">loss: 1.087. </span><br></pre></td></tr></table></figure>

<h5 id="扩散模型训练日志"><a href="#扩散模型训练日志" class="headerlink" title="扩散模型训练日志"></a>扩散模型训练日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- model size ---</span><br><span class="line">model: 55,192,704</span><br><span class="line">======= start training =======</span><br><span class="line">epoch: 0 |   9/ 47 | exp/diffusion-test | batch/s: 1.40 | lr: 0.0002 | loss: 0.036 | time: 0:00:07.5 | step: 10</span><br><span class="line">epoch: 0 |  19/ 47 | exp/diffusion-test | batch/s: 1.62 | lr: 0.0002 | loss: 0.030 | time: 0:00:13.7 | step: 20</span><br><span class="line">epoch: 0 |  29/ 47 | exp/diffusion-test | batch/s: 1.62 | lr: 0.0002 | loss: 0.022 | time: 0:00:19.9 | step: 30</span><br><span class="line">epoch: 0 |  39/ 47 | exp/diffusion-test | batch/s: 1.61 | lr: 0.0002 | loss: 0.031 | time: 0:00:26.1 | step: 40</span><br><span class="line">epoch: 1 |   2/ 47 | exp/diffusion-test | batch/s: 1.74 | lr: 0.0002 | loss: 0.027 | time: 0:00:31.8 | step: 50</span><br><span class="line">epoch: 1 |  12/ 47 | exp/diffusion-test | batch/s: 1.61 | lr: 0.0002 | loss: 0.006 | time: 0:00:38.0 | step: 60</span><br><span class="line">epoch: 1 |  22/ 47 | exp/diffusion-test | batch/s: 1.61 | lr: 0.0002 | loss: 0.029 | time: 0:00:44.3 | step: 70</span><br><span class="line">epoch: 1 |  32/ 47 | exp/diffusion-test | batch/s: 1.60 | lr: 0.0002 | loss: 0.019 | time: 0:00:50.5 | step: 80</span><br><span class="line">epoch: 1 |  42/ 47 | exp/diffusion-test | batch/s: 1.60 | lr: 0.0002 | loss: 0.024 | time: 0:00:56.7 | step: 90</span><br><span class="line">epoch: 2 |   5/ 47 | exp/diffusion-test | batch/s: 1.72 | lr: 0.0002 | loss: 0.012 | time: 0:01:02.5 | step: 100</span><br><span class="line">                                </span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">epoch: 93 |  28/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.040 | time: 0:49:42.2 | step: 5900</span><br><span class="line">epoch: 93 |  38/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.023 | time: 0:49:48.8 | step: 5910</span><br><span class="line">epoch: 94 |   1/ 47 | exp/diffusion-test | batch/s: 1.65 | lr: 0.0002 | loss: 0.029 | time: 0:49:54.9 | step: 5920</span><br><span class="line">epoch: 94 |  11/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.021 | time: 0:50:01.5 | step: 5930</span><br><span class="line">epoch: 94 |  21/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.057 | time: 0:50:08.0 | step: 5940</span><br><span class="line">epoch: 94 |  31/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.020 | time: 0:50:14.6 | step: 5950</span><br><span class="line">epoch: 94 |  41/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.012 | time: 0:50:21.2 | step: 5960</span><br><span class="line">epoch: 95 |   4/ 47 | exp/diffusion-test | batch/s: 1.65 | lr: 0.0002 | loss: 0.008 | time: 0:50:27.2 | step: 5970</span><br><span class="line">epoch: 95 |  14/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.032 | time: 0:50:33.8 | step: 5980</span><br><span class="line">epoch: 95 |  24/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.020 | time: 0:50:40.4 | step: 5990</span><br><span class="line">epoch: 95 |  34/ 47 | exp/diffusion-test | batch/s: 1.52 | lr: 0.0002 | loss: 0.024 | time: 0:50:47.0 | step: 6000</span><br><span class="line"> --- &lt;validation&gt; --- </span><br><span class="line">loss: 0.027. </span><br></pre></td></tr></table></figure>

<h3 id="数据的可视化"><a href="#数据的可视化" class="headerlink" title="数据的可视化"></a>数据的可视化</h3><h4 id="DDSP训练loss"><a href="#DDSP训练loss" class="headerlink" title="DDSP训练loss"></a>DDSP训练loss<img src="https://pic1.imgdb.cn/item/6468da5be03e90d87451b660.jpg"></h4><h4 id="DDSP验证loss"><a href="#DDSP验证loss" class="headerlink" title="DDSP验证loss"></a>DDSP验证loss<img src="https://pic1.imgdb.cn/item/6468df81e03e90d8745846b4.jpg"></h4><h4 id="扩散训练loss"><a href="#扩散训练loss" class="headerlink" title="扩散训练loss"></a>扩散训练loss<img src="https://pic1.imgdb.cn/item/6468e01ce03e90d874590f26.jpg"></h4><h4 id="扩散验证loss"><a href="#扩散验证loss" class="headerlink" title="扩散验证loss"></a>扩散验证loss<img src="https://pic1.imgdb.cn/item/6468e07ee03e90d874599769.jpg"></h4><h1 id="研究结论"><a href="#研究结论" class="headerlink" title="研究结论"></a>研究结论</h1><p>DDSP使得音频转换效果在同等的硬件条件下大幅提升，在部分数据集上可以达到媲美So-VITS的效果。</p>
<p>此外，DDSP还具有以下优点：</p>
<ol>
<li>对音频进行实时处理，具有高效性和灵活性；</li>
<li>对音频进行可控的声音合成，使得用户可以根据自己的需求进行音频转换；</li>
<li>对音频进行可解释的分析，使得用户可以更好地理解音频的特征和结构。</li>
</ol>
<p>因此，DDSP是非常有前途，可以在音频转换、音乐合成、语音识别等领域得到广泛应用。</p>
<h2 id="推理音频示例"><a href="#推理音频示例" class="headerlink" title="推理音频示例"></a>推理音频示例</h2><p><a href="https://filedoge.com/download/fbe2cf1f61655588aa73a868addafef2e0eb82c9dd8f21d669d534a40ce50f454f657b81f24f965ff890">下载链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>GPT1、GPT2原理</title>
    <url>/2023/04/01/GPT1%E3%80%81GPT2%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="GPT-1：无监督学习"><a href="#GPT-1：无监督学习" class="headerlink" title="GPT-1：无监督学习"></a>GPT-1：无监督学习</h2><span id="more"></span>

<h3 id="GPT-1原理介绍"><a href="#GPT-1原理介绍" class="headerlink" title="GPT-1原理介绍"></a>GPT-1原理介绍</h3><p>GPT模型主要包含两个阶段，第一个阶段，先利用大量未标注的语料预训练一个语言模型，接着，在第二个阶段对预训练好的语言模型进行微改，将其迁移到各种有监督的NLP任务，并对参数进行fine-tuning。</p>
<h4 id="预训练模型（无监督）"><a href="#预训练模型（无监督）" class="headerlink" title="预训练模型（无监督）"></a>预训练模型（无监督）</h4><p>给定一个没有标注的大语料，记每一个序列为$u&#x3D;u_1,…,u_n$，GPT通过最大化以下似然函数来训练语言模型：</p>
<p><img src="https://pic.imgdb.cn/item/642843d6a682492fcc0882ce.jpg"></p>
<p>其中，k 表示上下文窗口的大小，这里计算每个单词的预测概率时，<strong>只考虑左侧窗口大小的词汇信息（单向Transformer）</strong>，在GPT中，作者基于一个12层的Transformer decoder作为语言模型的结构，并将decoder的中间那层线性变换删除，其结构和计算过程如下：</p>
<p><img src="https://pic.imgdb.cn/item/64283c12a682492fccf9e88a.png"></p>
<blockquote>
<p>GPT用的结构和Transformer的encoder、decoder都不一样，encoder是两个线性层，但是没有masked，decoder是三个线性层，有masked。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/64283c44a682492fccfa334e.jpg"><br>$$<br>h&#x3D;UWe+W p<br>$$</p>
<p>$$<br>h_<br>l<br>​<br> &#x3D;transformer_<br>b<br>​<br> lock(h_{l-1})∀i∈[1,n]<br>$$</p>
<p>$$<br>P(u)&#x3D;softmax(h_<br>n<br>​<br> W_<br>c^<br>T<br>​<br> )<br>$$</p>
<p>其中，$U &#x3D; u_i−k , . . . , u_i−1$表示左侧窗口的词汇向量，n表示Transformer的层数，$W_e$ 表示词向量矩阵，$W_p$表示position embedding矩阵，在GPT中，作者对position embedding矩阵进行随机初始化，<strong>让模型自己学习，而不是采用正弦余弦函数进行计算。(原Transformer用的三角函数)</strong></p>
<p>从GPT的计算公式来看，其实跟Transformer基本是一样的，只是对每个时间步，都只考虑左侧窗口大小的上下文信息。</p>
<p>由于使用了Masked Self-Attention，所以每个位置的词都不会“看见”后面的词，也就是预测的时候是看不见“答案”的，即避免了see themselves 的问题，保证了模型的合理性，这也是为什么OpenAI采用了单向Transformer的原因。</p>
<h4 id="fine-tuning（有监督）"><a href="#fine-tuning（有监督）" class="headerlink" title="fine-tuning（有监督）"></a>fine-tuning（有监督）</h4><p>当语言模型训练结束后，就可以将其迁移到具体的NLP任务中，假设将其迁移到一个文本分类任务中，记此时的数据集为 C ，对于每一个样本，其输入为 $x^1 , . . . , x^m$，输出为 $y$。对于每一个输入，经过预训练后的语言模型后，可以直接选取最后一层Transformer最后一个时间步的输出向量$h^m_l$，然后在其后面接一层全连接层，即可得到最后的预测标签概率：<br>$$<br>P(y∣x^<br>1<br> ,…,x^<br>m<br> )&#x3D;softmax(h_<br>l^<br>m<br>​<br> W_<br>y<br>​<br> )<br>$$<br>其中，为引入的全来凝结层的参数矩阵。因此，可以得到在分类任务中的目标函数：<br>$$<br>L _<br>2<br>​<br> (C)&#x3D;<br>\stackrel{}{\sum\limits_{x,y}}<br>​<br> logP(y∣x^<br>1<br> ,…,x^<br>m<br> )<br>$$<br>在具体的NLP任务中，作者在fine-tuning时<strong>也把语言模型的目标引入到目标函数中</strong>，作为辅助函数，作者发现这样操作可以提高模型的通用能力，并且加速模型手来你，其形式如下：<br>$$<br>L _<br>3<br>​<br> (C)&#x3D;L  _<br>2<br>​<br> (C)+λ∗L  _<br>1<br>​<br> (C)<br>$$<br>其中 λ一般取0.5。</p>
<p>可以发现，在fine-tuning阶段，此时新增的参数只有最后一层全连接层的参数$W_y$，这比ELMo算法要容易得多。</p>
<p>不过，上面这个例子知识对与<strong>文本分类任务</strong>，如果是对于其他任务，比如文本蕴涵、问答、文本相似度等，那么GPT该如何进行微调呢？</p>
<ul>
<li>文本蕴涵：对于文本蕴涵任务（文本间的推理关系，问题-答案），作者用一个$负号将文本和假设进行拼接，并在拼接后的文本前后加入开始符 start 和结束符 end，然后将拼接后的文本直接传入预训练的语言模型，在模型再接一层线性变换和softmax即可。</li>
<li>文本相似度：对于文本相似度任务，由于相似度不需要考虑两个句子的顺序关系，因此，为了反映这一点，作者将两个句子分别与另一个句子进行拼接，中间用“$”进行隔开，并且前后还是加上起始和结束符，然后分别将拼接后的两个长句子传入Transformer，最后分别得到两个句子的向量表示，将这两个向量进行元素相加，然后再接如线性层和softmax层。</li>
<li>问答和尝试推理：对于问答和尝试推理任务，首先将本经信息与问题进行拼接，然后再将拼接后的文本一次与每个答案进行拼接，最后依次传入Transformer模型，最后接一层线性层得到每个输入的预测值。</li>
</ul>
<p>具体的方法可以查看下图，可以发现，对这些任务的微调主要是：</p>
<ul>
<li>增加线性层的参数</li>
<li>增加起始符、结束符和分隔符三种特殊符号的向量参数</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/642845a2a682492fcc0ba32d.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>GPT其实跟ELMO非常相似，只是把语言模型直接迁移到具体的NLP任务中，因此，更容易进行迁移学习。</li>
<li>不过GPT主要还是针对文本分类和标注性任务，如果对于生成任务，比如机器翻译等，则其结构也没法进行很好的迁移。</li>
</ul>
<h2 id="GPT-2：多任务学习"><a href="#GPT-2：多任务学习" class="headerlink" title="GPT-2：多任务学习"></a>GPT-2：多任务学习</h2><p>GPT-2继续沿用了原来在GPT中使用的单向 Transformer 模型，而这篇文章的目的就是尽可能利用单向Transformer的优势，做一些BERT使用的双向Transformer所做不到的事。那就是通过上文生成下文文本。</p>
<h3 id="GPT-2的改进"><a href="#GPT-2的改进" class="headerlink" title="GPT-2的改进"></a>GPT-2的改进</h3><p><strong>1. 去掉了fine-tuning层：</strong>不再针对不同任务分别进行微调建模，而是不定义这个模型应该做什么任务，模型会自动识别出来需要做什么任务，是很通用的设计。</p>
<p><strong>2. 增加数据集：</strong>GPT-2手机了更加广泛，数量更多的语料组成数据集。该数据集包含800万个网页，大小为40G。这些数据是经过过滤后得到的高质量文本。</p>
<p><strong>3. 增加网络参数：</strong>GPT-2将Transformer堆叠的层数增加到48层，隐层的维度为1600，参数量达到了15亿。（5倍于BERT的参数量）</p>
<p><strong>4. 调整Transformer：</strong>将layer normalization放到每个sub-block之前，并在最后一个self-attention后再增加一个layer normalization。</p>
<ol start="5">
<li>此外，GPT-2将词汇表数量增加到50257个；最大的上下文大小从GPT-1的512提升到了1024 tokens；batch-size增加到512。</li>
</ol>
<h3 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h3><ul>
<li>同样使用了使用字节对编码构建字典，字典的大小：50257</li>
<li>滑动窗口大小：1024</li>
<li>batch-size：512</li>
<li>Layer Normalization移动到了每一块的输入部分，在每个self-attention之后额外添加了一个Layer Normalization</li>
<li>将残差层的初始化值用 $ \frac{1}{\sqrt(N)}$进行缩放，其中N是残差层的个数</li>
</ul>
<p>GPT-2训练了4组不同的层数和词向量的长度的模型，见表：</p>
<table>
<thead>
<tr>
<th>参数量</th>
<th>层数</th>
<th>词向量长度</th>
</tr>
</thead>
<tbody><tr>
<td>117M（GPT-1）</td>
<td>12</td>
<td>768</td>
</tr>
<tr>
<td>345M</td>
<td>124</td>
<td>1024</td>
</tr>
<tr>
<td>762M</td>
<td>36</td>
<td>1280</td>
</tr>
<tr>
<td>1542M</td>
<td>48</td>
<td>1600</td>
</tr>
</tbody></table>
<p>效果如下：</p>
<p><img src="https://pic.imgdb.cn/item/6428462da682492fcc0c8053.png"></p>
<p>可以看出随着模型的增大，模型的效果是不断提升的。模型仍欠拟合，后续还会加大数据量，做大做强。</p>
<h3 id="为什么GPT-2能够适应多任务？"><a href="#为什么GPT-2能够适应多任务？" class="headerlink" title="为什么GPT-2能够适应多任务？"></a>为什么GPT-2能够适应多任务？</h3><p>在训练的时候，采用了多任务的方式，不单单只在一个任务上进行学习，而是多个，每一个任务都要保证其损失函数能收敛，不同任务是共享主题Transformer参数的，进一步提升模型的泛化能力，因此在即使没有fine-tuning的情况下，依旧有非常不错的表现。</p>
<p>在fine-tuning有监督任务阶段，GPT-2根据给定输入与任务来做出相应的输出，那么模型就可以表示成下面这个样子：<br>$$<br>p(output∣input,task)<br>$$<br>例如可以直接输入：(“自然语言处理”, 中文翻译)来得到我们需要的结果(“Nature Language Processing”)，因此提出的模型可以将机器翻译，自然语言推理，语义分析，关系提取等10类任务统一建模为一个分类任务，而不误再为每一个子任务单独设计一个模型。</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo搭建小记</title>
    <url>/2023/08/25/Hexo%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h1><h2 id="hexo-generator-searchdb插件"><a href="#hexo-generator-searchdb插件" class="headerlink" title="hexo-generator-searchdb插件"></a>hexo-generator-searchdb插件</h2><h3 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h3><p>这个插件会扫描博客文章，根据“——config.yml”的配置从文章里获取内容生成一个xml&#x2F;json文件的结果，类似于博客中文章信息的摘要把，搜索的时候就搜索这个文件的内容。</p>
<h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><ol>
<li>打开“Node Command Prompt”，使用cd定位到自己博客的目录。</li>
<li>输入以下命令添加博客搜索插件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开博客目录，找到“_config.yml”文件，添加以下内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path：表示搜索后生成的文件路径，可以生成xml和json两种格式；将path设置为“content.json”就可以替代第二个插件。</span><br><span class="line">field：表示搜索的范围，有“post、page和all”三种值。</span><br><span class="line">    post：所有的文章；</span><br><span class="line">    page：所有顶部导航选项的页面；</span><br><span class="line">    all：所有的文章和顶部导航选项的页面。</span><br><span class="line">content：是否包含搜索到的文章的全部内容。如果false，生成的结果只包括标题和创建时间这些信息，没有文章主体。默认情况下是true.</span><br><span class="line">format：搜索到的内容、选项的格式。</span><br><span class="line">    html(默认)：将html原文本缩略。</span><br><span class="line">    striptags：将html原文本缩略，并删除所有标记。</span><br><span class="line">    raw：记下每一篇文章或每一页的文字。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用插件<br>打开博客目录目录，找到当前正在使用的主题的“_config.yml”文件，打开进行编辑，找到“local_search”，修改enable的值为true。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong></p>
<p>有新内容时要运行<code>hexo clean</code>再生成</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用cloudflare为基于Github Pages的Hexo博客添加HTTPS支持</title>
    <url>/2023/08/24/Pages%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0HTTPS%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>添加CNAME解析到Github Pages，并勾选代理流量即可</p>
<p>可在安全性-WAF内配置防火墙</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>GPU参数</title>
    <url>/2023/06/04/GPU%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p><strong>持续更新中</strong></p>
<span id="more"></span>

<h1 id="NVIDIA"><a href="#NVIDIA" class="headerlink" title="NVIDIA"></a>NVIDIA</h1><h2 id="消费级"><a href="#消费级" class="headerlink" title="消费级"></a>消费级</h2><h3 id="RTX30系"><a href="#RTX30系" class="headerlink" title="RTX30系"></a>RTX30系</h3><h4 id="RTX-3090Ti"><a href="#RTX-3090Ti" class="headerlink" title="RTX 3090Ti"></a>RTX 3090Ti</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1560 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1695 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>10752 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA102</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>450W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>21.2 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6X</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>384 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>24 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA102-350-A1</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>628 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>6 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>336</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>112</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>84</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>84</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>336</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>850 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>131 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>400 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>189.8 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>569.5 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>1,018 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>36.45 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>36.45 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>569.5 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3090"><a href="#RTX-3090" class="headerlink" title="RTX 3090"></a>RTX 3090</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1395 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1695 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>10496 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA102</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>350W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>19.5 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6X</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>384 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>24 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA102-300-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>283亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>628 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>6 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>328</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>112</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>82</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>82</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>328</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>750 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>121 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>370 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>189.8 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>556.0 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>936.2 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>35.58 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>35.58 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>556.0 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3080-Ti"><a href="#RTX-3080-Ti" class="headerlink" title="RTX 3080 Ti"></a>RTX 3080 Ti</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1365 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1665 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>10240 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA102</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>350W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>19 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6X</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>384 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>16 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA102-225-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>280亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>628 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>6 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>320</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>112</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>80</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>80</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>320</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>750 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>117 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>310 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>186.5 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>532.8 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>912.4 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>34.10 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>34.10 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>532.8 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3080Ti-Laptop"><a href="#RTX-3080Ti-Laptop" class="headerlink" title="RTX 3080Ti Laptop"></a>RTX 3080Ti Laptop</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>975 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1590 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>7424 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GN20-E8</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>150W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>14 GHz</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 Bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>16 GB</td>
</tr>
</tbody></table>
<p>参数补充</p>
<p>理论性能</p>
<p>显卡特性</p>
<hr>
<h4 id="RTX-3080"><a href="#RTX-3080" class="headerlink" title="RTX 3080"></a>RTX 3080</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1440 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1710 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>8704 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA102</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>320W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>19 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6X</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>320 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>10 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA102-200-KD-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>283亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>628 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>5 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>272</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>96</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>68</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>68</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>272</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>700 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>85 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>298 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>164.2 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>465.1 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>760.3 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>29.77 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>29.77 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>465.1 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3080-Laptop"><a href="#RTX-3080-Laptop" class="headerlink" title="RTX 3080 Laptop"></a>RTX 3080 Laptop</h4><hr>
<h4 id="RTX-3070Ti"><a href="#RTX-3070Ti" class="headerlink" title="RTX 3070Ti"></a>RTX 3070Ti</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1575 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1770 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>6144 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA104</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>290W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>19 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6X</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>8 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA104-400-A1</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>392 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>4 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>192</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>96</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>48</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>48</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>192</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>600 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>169.9 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>339.8 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>608.3 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>21.75 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>21.75 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>339.8 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3070Ti-Laptop"><a href="#RTX-3070Ti-Laptop" class="headerlink" title="RTX 3070Ti Laptop"></a>RTX 3070Ti Laptop</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>915 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1410 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>5632 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA104</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>115W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>14 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>8 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>392 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>4 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>176</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>80</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>44</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>44</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>176</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>112.8 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>248.2 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>448.0 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>15.88 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>15.88 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>248.2 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3070"><a href="#RTX-3070" class="headerlink" title="RTX 3070"></a>RTX 3070</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1500 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1725 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>5888 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA104</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>220W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>14 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>8 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA104-300-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>174亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>392 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>4 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>184</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>96</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>46</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>46</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>184</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>550 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>59 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>175 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>165.6 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>317.4 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>448.0 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>20.31 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>20.31 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>317.4 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3070-Laptop"><a href="#RTX-3070-Laptop" class="headerlink" title="RTX 3070 Laptop"></a>RTX 3070 Laptop</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1500 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1725 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>5888 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>220W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>16000 MHz</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 Bit</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶体管数量</td>
<td>174亿</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>59 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>175 W&#x2F;h</td>
</tr>
</tbody></table>
<p>理论性能</p>
<p>显卡特性</p>
<hr>
<h4 id="RTX-3060Ti"><a href="#RTX-3060Ti" class="headerlink" title="RTX 3060Ti"></a>RTX 3060Ti</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1410 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1665 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>4864 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA104</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>200W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>14 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>256 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>8 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA104-200-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>174亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>392 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>4 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>152</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>80</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>38</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>38</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>152</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>550 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>61 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>193 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>133.2 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>253.1 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>448.0 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>16.20 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>16.20 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>253.1 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3060Ti-Laptop"><a href="#RTX-3060Ti-Laptop" class="headerlink" title="RTX 3060Ti Laptop"></a>RTX 3060Ti Laptop</h4><hr>
<h4 id="RTX-3060"><a href="#RTX-3060" class="headerlink" title="RTX 3060"></a>RTX 3060</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1320 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1777 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>3584 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA106</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>170W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>15 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>192 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>12 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA106-300-A1</td>
</tr>
<tr>
<td align="left">晶体管数量</td>
<td>132亿</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>276 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>3 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>112</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>48</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>28</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>28</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>112</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>450 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 12-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
<tr>
<td align="left">以太坊算力</td>
<td>46 MH&#x2F;s</td>
</tr>
<tr>
<td align="left">以太坊挖矿功耗</td>
<td>154 W&#x2F;h</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>85.30 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>199.0 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>360.0 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>12.74 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>12.74 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>199.0 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3060-Laptop"><a href="#RTX-3060-Laptop" class="headerlink" title="RTX 3060 Laptop"></a>RTX 3060 Laptop</h4><hr>
<h4 id="RTX-3050Ti-Laptop"><a href="#RTX-3050Ti-Laptop" class="headerlink" title="RTX 3050Ti Laptop"></a>RTX 3050Ti Laptop</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1222 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1485 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>2560 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>60W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>12 GHz</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>128 Bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>4 GB</td>
</tr>
</tbody></table>
<p>参数补充</p>
<p>理论性能</p>
<p>显卡特性</p>
<hr>
<h4 id="RTX-3050"><a href="#RTX-3050" class="headerlink" title="RTX 3050"></a>RTX 3050</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1552 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1777 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>2560 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">GPU代号</td>
<td>GA106</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>90W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>14 Gbps</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>128 bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>8 GB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数补充</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">晶片编号</td>
<td>GA106-150-A1</td>
</tr>
<tr>
<td align="left">代工厂</td>
<td>Samsung</td>
</tr>
<tr>
<td align="left">核心面积</td>
<td>276 mm²</td>
</tr>
<tr>
<td align="left">一级缓存</td>
<td>128 KB</td>
</tr>
<tr>
<td align="left">二级缓存</td>
<td>2 MB</td>
</tr>
<tr>
<td align="left">光栅单元</td>
<td>80</td>
</tr>
<tr>
<td align="left">纹理单元</td>
<td>48</td>
</tr>
<tr>
<td align="left">RT cores</td>
<td>20</td>
</tr>
<tr>
<td align="left">SM count</td>
<td>20</td>
</tr>
<tr>
<td align="left">Tensor cores</td>
<td>80</td>
</tr>
<tr>
<td align="left">建议电源</td>
<td>250 W</td>
</tr>
<tr>
<td align="left">公版供电</td>
<td>1x 6-pin</td>
</tr>
<tr>
<td align="left">公版接口</td>
<td>1x HDMI3x DisplayPort</td>
</tr>
<tr>
<td align="left">总线接口</td>
<td>PCIe 4.0 x16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">理论性能</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">像素填充率</td>
<td>85.30 GPixel&#x2F;s</td>
</tr>
<tr>
<td align="left">纹理填充率</td>
<td>142.2 GTexel&#x2F;s</td>
</tr>
<tr>
<td align="left">显存带宽</td>
<td>224.0 GB&#x2F;s</td>
</tr>
<tr>
<td align="left">FP16</td>
<td>9.098 TFLOPS (1:1)</td>
</tr>
<tr>
<td align="left">FP32</td>
<td>9.098 TFLOPS</td>
</tr>
<tr>
<td align="left">FP64</td>
<td>142.2 GFLOPS (1:64)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">显卡特性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DirectX</td>
<td>12 Ultimate (12_2)</td>
</tr>
<tr>
<td align="left">OpenGL</td>
<td>4.6</td>
</tr>
<tr>
<td align="left">OpenCL</td>
<td>3.0</td>
</tr>
<tr>
<td align="left">Vulkan</td>
<td>1.2</td>
</tr>
<tr>
<td align="left">CUDA</td>
<td>8.6</td>
</tr>
<tr>
<td align="left">Shader model</td>
<td>6.6</td>
</tr>
</tbody></table>
<hr>
<h4 id="RTX-3050-Laptop"><a href="#RTX-3050-Laptop" class="headerlink" title="RTX 3050 Laptop"></a>RTX 3050 Laptop</h4><table>
<thead>
<tr>
<th align="left">主要参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心频率</td>
<td>1238 MHz</td>
</tr>
<tr>
<td align="left">Turbo频率</td>
<td>1500 MHz</td>
</tr>
<tr>
<td align="left">流处理单元</td>
<td>2048 个</td>
</tr>
<tr>
<td align="left">核心架构</td>
<td>Ampere</td>
</tr>
<tr>
<td align="left">生产工艺</td>
<td>8 nm</td>
</tr>
<tr>
<td align="left">TDP功耗</td>
<td>60 W</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">内存参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left">内存频率</td>
<td>12 GHz</td>
</tr>
<tr>
<td align="left">内存类型</td>
<td>GDDR6</td>
</tr>
<tr>
<td align="left">内存位宽</td>
<td>128 Bit</td>
</tr>
<tr>
<td align="left">最大显存</td>
<td>4 GB</td>
</tr>
</tbody></table>
<p>参数补充</p>
<p>理论性能</p>
<p>显卡特性</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Python3 函数</title>
    <url>/2023/07/13/Python3%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-函数"><a href="#Python3-函数" class="headerlink" title="Python3 函数"></a>Python3 函数</h1><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<hr>
<h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li>
<li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/64af83a91ddac507cc41f90f.jpg"></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名（参数列表）:</span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>

<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>让我们使用函数来输出”Hello World！”：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">def hello() :</span><br><span class="line">    print(&quot;Hello World!&quot;)</span><br><span class="line"></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure>

<p>更复杂点的应用，函数中带上参数变量:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比较两个数，并返回较大的数:</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">def max(a, b):</span><br><span class="line">    if a &gt; b:</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        return b</span><br><span class="line"> </span><br><span class="line">a = 4</span><br><span class="line">b = 5</span><br><span class="line">print(max(a, b))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算面积函数:</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 计算面积函数</span><br><span class="line">def area(width, height):</span><br><span class="line">    return width * height</span><br><span class="line"> </span><br><span class="line">def print_welcome(name):</span><br><span class="line">    print(&quot;Welcome&quot;, name)</span><br><span class="line"> </span><br><span class="line">print_welcome(&quot;Runoob&quot;)</span><br><span class="line">w = 4</span><br><span class="line">h = 5</span><br><span class="line">print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; area =&quot;, area(w, h))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome Runoob</span><br><span class="line">width = 4  height = 5  area = 20</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p>
<p>如下实例调用了 <strong>printme()</strong> 函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 定义函数</span><br><span class="line">def printme( str ):</span><br><span class="line">   # 打印任何传入的字符串</span><br><span class="line">   print (str)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用函数</span><br><span class="line">printme(&quot;我要调用用户自定义函数!&quot;)</span><br><span class="line">printme(&quot;再次调用同一函数&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=[1,2,3]</span><br><span class="line"></span><br><span class="line">a=&quot;Runoob&quot;</span><br></pre></td></tr></table></figure>

<p>以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<h3 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li><strong>不可变类型：</strong>变量赋值 <strong>a&#x3D;5</strong> 后再赋值 <strong>a&#x3D;10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li>
<li><strong>可变类型：</strong>变量赋值 <strong>la&#x3D;[1,2,3,4]</strong> 后再赋值 <strong>la[2]&#x3D;5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li>
<li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li>
</ul>
<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h3 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h3><p>通过 <strong>id()</strong> 函数来查看内存地址变化：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def change(a):</span><br><span class="line">    print(id(a))   # 指向的是同一个对象</span><br><span class="line">    a=10</span><br><span class="line">    print(id(a))   # 一个新对象</span><br><span class="line"> </span><br><span class="line">a=1</span><br><span class="line">print(id(a))</span><br><span class="line">change(a)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4379369136</span><br><span class="line">4379369136</span><br><span class="line">4379369424</span><br></pre></td></tr></table></figure>

<p>可以看见在调用函数前后，形参和实参指向的是同一个对象（对象 id 相同），在函数内部修改形参后，形参指向的是不同的 id。</p>
<h3 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h3><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def changeme( mylist ):</span><br><span class="line">   &quot;修改传入的列表&quot;</span><br><span class="line">   mylist.append([1,2,3,4])</span><br><span class="line">   print (&quot;函数内取值: &quot;, mylist)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用changeme函数</span><br><span class="line">mylist = [10,20,30]</span><br><span class="line">changeme( mylist )</span><br><span class="line">print (&quot;函数外取值: &quot;, mylist)</span><br></pre></td></tr></table></figure>

<p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br><span class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h3 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h3><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用 printme 函数，不加参数会报错</span><br><span class="line">printme()</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() missing 1 required positional argument: &#x27;str&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printme( str ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (str)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line">#调用printme函数</span><br><span class="line">printme( str = &quot;菜鸟教程&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>

<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name)</span><br><span class="line">   print (&quot;年龄: &quot;, age)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;runoob&quot; )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#可写函数说明</span><br><span class="line">def printinfo( name, age = 35 ):</span><br><span class="line">   &quot;打印任何传入的字符串&quot;</span><br><span class="line">   print (&quot;名字: &quot;, name)</span><br><span class="line">   print (&quot;年龄: &quot;, age)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line">#调用printinfo函数</span><br><span class="line">printinfo( age=50, name=&quot;runoob&quot; )</span><br><span class="line">print (&quot;------------------------&quot;)</span><br><span class="line">printinfo( name=&quot;runoob&quot; )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  runoob</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure>

<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def functionname([formal_args,] *var_args_tuple ):</span><br><span class="line">   &quot;函数_文档字符串&quot;</span><br><span class="line">   function_suite</span><br><span class="line">   return [expression]</span><br></pre></td></tr></table></figure>

<p>加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">  </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print (&quot;输出: &quot;)</span><br><span class="line">   print (arg1)</span><br><span class="line">   print (vartuple)</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 70, 60, 50 )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">70</span><br><span class="line">(60, 50)</span><br></pre></td></tr></table></figure>

<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print (&quot;输出: &quot;)</span><br><span class="line">   print (arg1)</span><br><span class="line">   for var in vartuple:</span><br><span class="line">      print (var)</span><br><span class="line">   return</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 10 )</span><br><span class="line">printinfo( 70, 60, 50 )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>还有一种就是参数带两个星号 ******基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def functionname([formal_args,] **var_args_dict ):</span><br><span class="line">   &quot;函数_文档字符串&quot;</span><br><span class="line">   function_suite</span><br><span class="line">   return [expression]</span><br></pre></td></tr></table></figure>

<p>加了两个星号 *<strong>*</strong> 的参数会以字典的形式导入。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">  </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, **vardict ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print (&quot;输出: &quot;)</span><br><span class="line">   print (arg1)</span><br><span class="line">   print (vardict)</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo(1, a=2,b=3)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">1</span><br><span class="line">&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>

<p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a,b,*,c):</span><br><span class="line">    return a+b+c</span><br></pre></td></tr></table></figure>

<p>如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(a,b,*,c):</span><br><span class="line">...     return a+b+c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f(1,2,3)   # 报错</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: f() takes 2 positional arguments but 3 were given</span><br><span class="line">&gt;&gt;&gt; f(1,2,c=3) # 正常</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Python 使用 <strong>lambda</strong> 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p>
<ul>
<li><strong>lambda</strong> 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li>
<li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li>
<li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，内联函数的目的是调用小函数时不占用栈内存从而减少函数调用的开销，提高代码的执行速度。</li>
</ul>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>lambda 函数的语法只包含一个语句，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lambda [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>

<p>设置参数 a 加上 10:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = lambda a : a + 10</span><br><span class="line">print(x(5))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<p>以下实例匿名函数设置两个参数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">sum = lambda arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"># 调用sum函数</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br><span class="line">print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure>

<p>我们可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p>
<p>以下实例将匿名函数封装在 myfunc 函数中，通过传入不同的参数来创建不同的匿名函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def myfunc(n):</span><br><span class="line">  return lambda a : a * n</span><br><span class="line"> </span><br><span class="line">mydoubler = myfunc(2)</span><br><span class="line">mytripler = myfunc(3)</span><br><span class="line"> </span><br><span class="line">print(mydoubler(11))</span><br><span class="line">print(mytripler(11))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h2><p><strong>return [表达式]</strong> 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def sum( arg1, arg2 ):</span><br><span class="line">   # 返回2个参数的和.&quot;</span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   print (&quot;函数内 : &quot;, total)</span><br><span class="line">   return total</span><br><span class="line"> </span><br><span class="line"># 调用sum函数</span><br><span class="line">total = sum( 10, 20 )</span><br><span class="line">print (&quot;函数外 : &quot;, total)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h2><p>Python3.8 新增了一个函数形参语法 &#x2F; 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a, b, /, c, d, *, e, f):</span><br><span class="line">    print(a, b, c, d, e, f)</span><br></pre></td></tr></table></figure>

<p>以下使用方法是正确的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(10, 20, 30, d=40, e=50, f=60)</span><br></pre></td></tr></table></figure>

<p>以下使用方法会发生错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式</span><br><span class="line">f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Python3 基础语法</title>
    <url>/2023/05/01/Python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是<code>unicode</code>字符串。 当然你也可以为源码文件指定不同的编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure>

<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<hr>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p>
<hr>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 <strong>#</strong> 开头</p>
<p>多行注释可以用多个 <strong>#</strong> 号，还有 <code>&#39;&#39;&#39;</code> 和 <code>&quot;&quot;&quot;</code>：</p>
<hr>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<p>程序由于缩进不一致，执行后会出现类似以下错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠来实现多行语句，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>

<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li><strong>bool</strong> (布尔), 如 True。</li>
<li><strong>float</strong> (浮点数), 如 1.23、3E-2</li>
<li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<hr>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>Python 中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</li>
<li>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</li>
<li>转义符 <code>\</code>。</li>
<li>反斜杠可以用来转义，使用 <code>r</code> 可以让反斜杠不发生转义。 如 <code>r&quot;this is a line with \n&quot;</code> 则 <strong>\n</strong> 会显示，并不是换行。</li>
<li>按字面意义级联字符串，如 <code>&quot;this &quot; &quot;is &quot; &quot;string&quot;</code> 会被自动转换为 <code>this is string</code>。</li>
<li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</li>
<li>Python 中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落，</span></span><br><span class="line"><span class="string">可以由多行组成&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第六个的字符（不包含）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])          <span class="comment"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)         <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nrunoob&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nrunoob&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure>

<p>这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)       <span class="comment"># 输出空行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;\n&#x27;</span>)      <span class="comment"># 输出 \n</span></span><br><span class="line">\n</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><font color='cornflowerblue'>以上实例输出结果：</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">123456789</span></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">345</span></span><br><span class="line"><span class="number">3456789</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">123456789123456789</span></span><br><span class="line"><span class="number">123456789</span>你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">runoob</span><br><span class="line">hello\nrunoob</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<hr>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码中 ，<code>\n\n</code> 在结果输出前会输出两个新的空行。一旦用户按下 <code>enter</code> 键时，程序将退出。</p>
<hr>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python 可以在同一行中使用多条语句，语句之间使用分号 <strong><code>;</code></strong> 分割，以下是一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用脚本执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob</span><br></pre></td></tr></table></figure>

<p>使用交互式命令行执行，输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">runoob</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>此处的 7 表示字符数，<code>runoob</code> 有 6 个字符，<code>\n</code> 表示一个字符，加起来 <strong>7</strong> 个字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">&quot; hi &quot;</span>)    <span class="comment"># hi 前后各有 1 个空格</span></span><br><span class="line"> hi <span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression : </span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression : </span><br><span class="line">   suite </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">   suite</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="print-输出"><a href="#print-输出" class="headerlink" title="print 输出"></a>print 输出</h2><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **<code>end=&quot;&quot;</code>**：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">---------</span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>在 python 用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。</p>
<p>将整个模块(somemodule)导入，格式为： <code>import somemodule</code></p>
<p>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></p>
<p>从某个模块中导入多个函数,格式为： <code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p>
<p>将某个模块中的全部函数导入，格式为： <code>from somemodule import *</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -h</span><br><span class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</span><br><span class="line">Options <span class="keyword">and</span> arguments (<span class="keyword">and</span> corresponding environment variables):</span><br><span class="line">-c cmd : program passed <span class="keyword">in</span> <span class="keyword">as</span> string (terminates option <span class="built_in">list</span>)</span><br><span class="line">-d     : debug output <span class="keyword">from</span> parser (also PYTHONDEBUG=x)</span><br><span class="line">-E     : ignore environment variables (such <span class="keyword">as</span> PYTHONPATH)</span><br><span class="line">-h     : <span class="built_in">print</span> this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line">[ etc. ]</span><br></pre></td></tr></table></figure>

<p>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数，具体使用如下：</p>
<p>Python 提供了 <strong>getopt</strong> 模块来获取命令行参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>Python 中也可以所用 <strong>sys</strong> 的 <strong>sys.argv</strong> 来获取命令行参数：</p>
<ul>
<li><strong><code>sys.argv</code></strong> 是命令行参数列表。</li>
<li><strong><code>len(sys.argv)</code></strong> 计算命令行参数个数。</li>
</ul>
<p>注：<code>sys.argv[0]</code> 表示脚本名。</p>
<p><strong>实例</strong></p>
<p>test.py 文件代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;参数个数为:&#x27;</span>, <span class="built_in">len</span>(sys.argv), <span class="string">&#x27;个参数。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;参数列表:&#x27;</span>, <span class="built_in">str</span>(sys.argv))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;脚本名:&#x27;</span>, <span class="built_in">str</span>(sys.argv[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 test.py arg1 arg2 arg3</span><br><span class="line">参数个数为: <span class="number">4</span> 个参数。</span><br><span class="line">参数列表: [<span class="string">&#x27;test.py&#x27;</span>, <span class="string">&#x27;arg1&#x27;</span>, <span class="string">&#x27;arg2&#x27;</span>, <span class="string">&#x27;arg3&#x27;</span>]</span><br><span class="line">脚本名: test.py</span><br></pre></td></tr></table></figure>

<h3 id="getopt-模块"><a href="#getopt-模块" class="headerlink" title="getopt 模块"></a>getopt 模块</h3><p>getopt 模块是专门处理命令行参数的模块，用于获取命令行选项和参数，也就是 <code>sys.argv</code>。命令行选项使得程序的参数更加灵活。支持短选项模式 <code>-</code> 和长选项模式 <code>--</code>。</p>
<p>该模块提供了两个方法及一个异常处理来解析命令行参数。</p>
<h4 id="getopt-getopt-方法"><a href="#getopt-getopt-方法" class="headerlink" title="getopt.getopt 方法"></a>getopt.getopt 方法</h4><p>getopt.getopt 方法用于解析命令行参数列表，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getopt.getopt(args, options[, long_options])</span><br></pre></td></tr></table></figure>

<p>方法参数说明：</p>
<ul>
<li><strong>args</strong>: 要解析的命令行参数列表。</li>
<li><strong>options</strong>: 以字符串的格式定义，<strong>options</strong> 后的冒号 <strong>:</strong> 表示该选项必须有附加的参数，不带冒号表示该选项不附加参数。</li>
<li><strong>long_options</strong>: 以列表的格式定义，<strong>long_options</strong> 后的等号 <strong>&#x3D;</strong> 表示如果设置该选项，必须有附加的参数，否则就不附加参数。</li>
</ul>
<p>该方法返回值由两个元素组成: 第一个是 <strong>(option, value)</strong> 元组的列表。 第二个是参数列表，包含那些没有 <strong>-</strong> 或 <strong>–</strong> 的参数。</p>
<p>接下来我们定义一个 site() 函数，然后通过命令行输入站点名称 <strong>name</strong> 和网址 <strong>url</strong>，可以用缩写 <strong>n</strong> 和 <strong>u</strong>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">site</span>():</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    url = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">&quot;n:u:&quot;</span>)  <span class="comment"># 短选项模式</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">&#x27;-n&#x27;</span>]:</span><br><span class="line">            name = arg</span><br><span class="line">        <span class="keyword">elif</span> opt <span class="keyword">in</span> [<span class="string">&#x27;-u&#x27;</span>]:</span><br><span class="line">            url = arg</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>( name +<span class="string">&quot; &quot;</span> + url)</span><br><span class="line"> </span><br><span class="line">site()</span><br></pre></td></tr></table></figure>

<p>测试以上代码，命令行中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 test.py -n yousa -u yousa.love</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yousa yousa.love</span><br></pre></td></tr></table></figure>

<p>以下实例演示长选项模式的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">site</span>():</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    url = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">&quot;n:u:&quot;</span>,  </span><br><span class="line">                                   [<span class="string">&quot;name=&quot;</span>,</span><br><span class="line">                                    <span class="string">&quot;url=&quot;</span>])  <span class="comment"># 长选项模式</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">&#x27;-n&#x27;</span>, <span class="string">&#x27;--name&#x27;</span>]:</span><br><span class="line">            name = arg</span><br><span class="line">        <span class="keyword">elif</span> opt <span class="keyword">in</span> [<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--url&#x27;</span>]:</span><br><span class="line">            url = arg</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>( name + <span class="string">&quot; &quot;</span> + url)</span><br><span class="line"> </span><br><span class="line">site()</span><br></pre></td></tr></table></figure>

<p>测试以上代码，命令行中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 test.py -n yousa -u yousa.love</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yousa yousa.love</span><br></pre></td></tr></table></figure>

<p>另外一个方法是 <code>getopt.gnu_getopt</code>，用到的情况比较少，这里不多做介绍。</p>
<h3 id="Exception-getopt-GetoptError"><a href="#Exception-getopt-GetoptError" class="headerlink" title="Exception getopt.GetoptError"></a>Exception getopt.GetoptError</h3><p>在没有找到参数列表，或选项的需要的参数为空时会触发该异常。</p>
<p>异常的参数是一个字符串，表示错误的原因。属性 <strong>msg</strong> 和 <strong>opt</strong> 为相关选项的错误信息。</p>
<p><strong>实例</strong></p>
<p>假定我们创建这样一个脚本，可以通过命令行向脚本文件传递两个文件名，同时我们通过另外一个选项查看脚本的使用。脚本使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br></pre></td></tr></table></figure>

<p>test.py 文件代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">   inputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   outputfile = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">      opts, args = getopt.getopt(argv,<span class="string">&quot;hi:o:&quot;</span>,[<span class="string">&quot;ifile=&quot;</span>,<span class="string">&quot;ofile=&quot;</span>])</span><br><span class="line">   <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)</span><br><span class="line">      sys.exit(<span class="number">2</span>)</span><br><span class="line">   <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">      <span class="keyword">if</span> opt == <span class="string">&#x27;-h&#x27;</span>:</span><br><span class="line">         <span class="built_in">print</span> (<span class="string">&#x27;test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;&#x27;</span>)</span><br><span class="line">         sys.exit()</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-i&quot;</span>, <span class="string">&quot;--ifile&quot;</span>):</span><br><span class="line">         inputfile = arg</span><br><span class="line">      <span class="keyword">elif</span> opt <span class="keyword">in</span> (<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--ofile&quot;</span>):</span><br><span class="line">         outputfile = arg</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;输入的文件为：&#x27;</span>, inputfile)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;输出的文件为：&#x27;</span>, outputfile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">   main(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 test.py -h</span><br><span class="line">usage: test.py -i &lt;inputfile&gt; -o &lt;outputfile&gt;</span><br><span class="line"></span><br><span class="line">python3 test.py -i inputfile -o outputfile</span><br><span class="line">输入的文件为： inputfile</span><br><span class="line">输出的文件为： outputfile</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>Python3列表、元组、字典、集合</title>
    <url>/2023/06/03/Python3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h1><p>序列是 Python 中最基本的数据结构。</p>
<p>序列中的每个值都有对应的位置值，称之为索引，第一个索引是 0，第二个索引是 1，依此类推。</p>
<p>Python 有 6 个序列的内置类型，但最常见的是列表和元组。</p>
<p>列表都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
<p>此外，Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<p>列表是最常用的 Python 数据类型，它可以作为一个方括号内的逗号分隔值出现。</p>
<p>列表的数据项不需要具有相同的类型</p>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]</span><br><span class="line">list2 = [1, 2, 3, 4, 5 ]</span><br><span class="line">list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">list4 = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h2><p>与字符串的索引一样，列表索引从 <strong>0</strong> 开始，第二个索引是 <strong>1</strong>，依此类推。</p>
<p>通过索引列表可以进行截取、组合等操作。</p>
<p><a href="https://pic.imgdb.cn/item/647b39adf024cca1732dc190.jpg"><img src="https://pic.imgdb.cn/item/647b39adf024cca1732dc190.jpg"></a></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]</span><br><span class="line">print( list[0] )</span><br><span class="line">print( list[1] )</span><br><span class="line">print( list[2] )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">red</span><br><span class="line">green</span><br><span class="line">blue</span><br></pre></td></tr></table></figure>

<p>索引也可以从尾部开始，最后一个元素的索引为 <strong>-1</strong>，往前一位为 <strong>-2</strong>，以此类推。</p>
<p><a href="https://pic.imgdb.cn/item/647b39dbf024cca1732de931.jpg"><img src="https://pic.imgdb.cn/item/647b39dbf024cca1732de931.jpg"></a></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">list = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;white&#x27;, &#x27;black&#x27;]</span><br><span class="line">print( list[-1] )</span><br><span class="line">print( list[-2] )</span><br><span class="line">print( list[-3] )</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">black</span><br><span class="line">white</span><br><span class="line">yellow</span><br></pre></td></tr></table></figure>

<p>使用下标索引来访问列表中的值，同样你也可以使用方括号 <strong>[]</strong> 的形式截取字符，如下所示：</p>
<p><a href="https://pic.imgdb.cn/item/647b39fcf024cca1732e0633.jpg"><img src="https://pic.imgdb.cn/item/647b39fcf024cca1732e0633.jpg"></a></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [10, 20, 30, 40, 50, 60, 70, 80, 90]</span><br><span class="line">print(nums[0:4])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[10, 20, 30, 40]</span><br></pre></td></tr></table></figure>

<p>使用负数索引值截取：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &quot;Zhihu&quot;, &quot;Taobao&quot;, &quot;Wiki&quot;]</span><br><span class="line"> </span><br><span class="line"># 读取第二位</span><br><span class="line">print (&quot;list[1]: &quot;, list[1])</span><br><span class="line"># 从第二位开始（包含）截取到倒数第二位（不包含）</span><br><span class="line">print (&quot;list[1:-2]: &quot;, list[1:-2])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list[1]:  Runoob</span><br><span class="line">list[1:-2]:  [&#x27;Runoob&#x27;, &#x27;Zhihu&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h2><p>你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]</span><br><span class="line"> </span><br><span class="line">print (&quot;第三个元素为 : &quot;, list[2])</span><br><span class="line">list[2] = 2001</span><br><span class="line">print (&quot;更新后的第三个元素为 : &quot;, list[2])</span><br><span class="line"> </span><br><span class="line">list1 = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line">list1.append(&#x27;Baidu&#x27;)</span><br><span class="line">print (&quot;更新后的列表 : &quot;, list1)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第三个元素为 :  1997</span><br><span class="line">更新后的第三个元素为 :  2001</span><br><span class="line">更新后的列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Baidu&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><p>可以使用 del 语句来删除列表的的元素，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]</span><br><span class="line"> </span><br><span class="line">print (&quot;原始列表 : &quot;, list)</span><br><span class="line">del list[2]</span><br><span class="line">print (&quot;删除第三个元素 : &quot;, list)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始列表 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000]</span><br><span class="line">删除第三个元素 :  [&#x27;Google&#x27;, &#x27;Runoob&#x27;, 2000]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>我们会在接下来的章节讨论 remove() 方法的使用</p>
<hr>
<h2 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h2><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。</p>
<p>如下所示：</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">len([1, 2, 3])</td>
<td align="left">3</td>
<td align="left">长度</td>
</tr>
<tr>
<td align="left">[1, 2, 3] + [4, 5, 6]</td>
<td align="left">[1, 2, 3, 4, 5, 6]</td>
<td align="left">组合</td>
</tr>
<tr>
<td align="left">[‘Hi!’] * 4</td>
<td align="left">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td align="left">重复</td>
</tr>
<tr>
<td align="left">3 in [1, 2, 3]</td>
<td align="left">True</td>
<td align="left">元素是否存在于列表中</td>
</tr>
<tr>
<td align="left">for x in [1, 2, 3]: print(x, end&#x3D;” “)</td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<hr>
<h2 id="Python列表截取与拼接"><a href="#Python列表截取与拼接" class="headerlink" title="Python列表截取与拼接"></a>Python列表截取与拼接</h2><p>Python的列表截取与字符串操作类型，如下所示：</p>
<p>L&#x3D;[‘Google’, ‘Runoob’, ‘Taobao’]</p>
<p>操作：</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">L[2]</td>
<td align="left">‘Taobao’</td>
<td align="left">读取第三个元素</td>
</tr>
<tr>
<td align="left">L[-2]</td>
<td align="left">‘Runoob’</td>
<td align="left">从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td align="left">L[1:]</td>
<td align="left">[‘Runoob’, ‘Taobao’]</td>
<td align="left">输出从第二个元素开始后的所有元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;L=[&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line">&gt;&gt;&gt; L[2]</span><br><span class="line">&#x27;Taobao&#x27;</span><br><span class="line">&gt;&gt;&gt; L[-2]</span><br><span class="line">&#x27;Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; L[1:]</span><br><span class="line">[&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>列表还支持拼接操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;squares = [1, 4, 9, 16, 25]</span><br><span class="line">&gt;&gt;&gt; squares += [36, 49, 64, 81, 100]</span><br><span class="line">&gt;&gt;&gt; squares</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>使用嵌套列表即在列表里创建其它列表，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">&gt;&gt;&gt; n = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x = [a, n]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], [1, 2, 3]]</span><br><span class="line">&gt;&gt;&gt; x[0]</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">&gt;&gt;&gt; x[0][1]</span><br><span class="line">&#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="列表比较"><a href="#列表比较" class="headerlink" title="列表比较"></a>列表比较</h2><p>列表比较需要引入 <strong>operator</strong> 模块的 <strong>eq</strong> 方法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导入 operator 模块</span><br><span class="line">import operator</span><br><span class="line"></span><br><span class="line">a = [1, 2]</span><br><span class="line">b = [2, 3]</span><br><span class="line">c = [2, 3]</span><br><span class="line">print(&quot;operator.eq(a,b): &quot;, operator.eq(a,b))</span><br><span class="line">print(&quot;operator.eq(c,b): &quot;, operator.eq(c,b))</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator.eq(a,b):  False</span><br><span class="line">operator.eq(c,b):  True</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python列表函数-方法"><a href="#Python列表函数-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h2><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td>
</tr>
</tbody></table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index&#x3D;-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td>
</tr>
</tbody></table>
<hr>
<h1 id="Python3-元组"><a href="#Python3-元组" class="headerlink" title="Python3 元组"></a>Python3 元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号 **( )**，列表使用方括号 **[ ]**。</p>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tup1 = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000)</span><br><span class="line">&gt;&gt;&gt; tup2 = (1, 2, 3, 4, 5 )</span><br><span class="line">&gt;&gt;&gt; tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;   #  不需要括号也可以</span><br><span class="line">&gt;&gt;&gt; type(tup3)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>创建空元组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup1 = ()</span><br></pre></td></tr></table></figure>

<p>元组中只包含一个元素时，需要在元素后面添加逗号 <strong>,</strong> ，否则括号会被当作运算符使用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tup1 = (50)</span><br><span class="line">&gt;&gt;&gt; type(tup1)     # 不加逗号，类型为整型</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tup1 = (50,)</span><br><span class="line">&gt;&gt;&gt; type(tup1)     # 加上逗号，类型为元组</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>元组与字符串类似，下标索引从 0 开始，可以进行截取，组合等。</p>
<h2 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h2><p>元组可以使用下标索引来访问元组中的值，如下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tup1 = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000)</span><br><span class="line">tup2 = (1, 2, 3, 4, 5, 6, 7 )</span><br><span class="line"> </span><br><span class="line">print (&quot;tup1[0]: &quot;, tup1[0])</span><br><span class="line">print (&quot;tup2[1:5]: &quot;, tup2[1:5])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup1[0]:  Google</span><br><span class="line">tup2[1:5]:  (2, 3, 4, 5)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h2><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tup1 = (12, 34.56)</span><br><span class="line">tup2 = (&#x27;abc&#x27;, &#x27;xyz&#x27;)</span><br><span class="line"> </span><br><span class="line"># 以下修改元组元素操作是非法的。</span><br><span class="line"># tup1[0] = 100</span><br><span class="line"> </span><br><span class="line"># 创建一个新的元组</span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line">print (tup3)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, 1997, 2000)</span><br><span class="line"> </span><br><span class="line">print (tup)</span><br><span class="line">del tup</span><br><span class="line">print (&quot;删除后的元组 tup : &quot;)</span><br><span class="line">print (tup)</span><br></pre></td></tr></table></figure>

<p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除后的元组 tup : </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print (tup)</span><br><span class="line">NameError: name &#x27;tup&#x27; is not defined</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h2><p>与字符串一样，元组之间可以使用 **+<strong>、</strong>+&#x3D;**和 ***** 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>len((1, 2, 3))</code></td>
<td align="left">3</td>
<td align="left">计算元素个数</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;&gt; a = (1, 2, 3) &gt;&gt;&gt; b = (4, 5, 6) &gt;&gt;&gt; c = a+b &gt;&gt;&gt; c (1, 2, 3, 4, 5, 6)</code></td>
<td align="left">(1, 2, 3, 4, 5, 6)</td>
<td align="left">连接，c 就是一个新的元组，它包含了 a 和 b 中的所有元素。</td>
</tr>
<tr>
<td align="left"><code>&gt;&gt;&gt; a = (1, 2, 3) &gt;&gt;&gt; b = (4, 5, 6) &gt;&gt;&gt; a += b &gt;&gt;&gt; a (1, 2, 3, 4, 5, 6)</code></td>
<td align="left">(1, 2, 3, 4, 5, 6)</td>
<td align="left">连接，a 就变成了一个新的元组，它包含了 a 和 b 中的所有元素。</td>
</tr>
<tr>
<td align="left"><code>(&#39;Hi!&#39;,) * 4</code></td>
<td align="left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td>
<td align="left">复制</td>
</tr>
<tr>
<td align="left"><code>3 in (1, 2, 3)</code></td>
<td align="left">True</td>
<td align="left">元素是否存在</td>
</tr>
<tr>
<td align="left"><code>for x in (1, 2, 3):     print (x, end=&quot; &quot;)</code></td>
<td align="left">1 2 3</td>
<td align="left">迭代</td>
</tr>
</tbody></table>
<hr>
<h2 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h2><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p>
<p>元组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;, &#x27;Weibo&#x27;,&#x27;Weixin&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/64af7a141ddac507cc210d61.png"></p>
<table>
<thead>
<tr>
<th align="left">Python 表达式</th>
<th align="left">结果</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tup[1]</td>
<td align="left">‘Runoob’</td>
<td align="left">读取第二个元素</td>
</tr>
<tr>
<td align="left">tup[-2]</td>
<td align="left">‘Weibo’</td>
<td align="left">反向读取，读取倒数第二个元素</td>
</tr>
<tr>
<td align="left">tup[1:]</td>
<td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’, ‘Weibo’, ‘Weixin’)</td>
<td align="left">截取元素，从第二个开始后的所有元素。</td>
</tr>
<tr>
<td align="left">tup[1:4]</td>
<td align="left">(‘Runoob’, ‘Taobao’, ‘Wiki’)</td>
<td align="left">截取元素，从第二个开始到第四个元素（索引为 3）。</td>
</tr>
</tbody></table>
<p>运行实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tup = (&#x27;Google&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;, &#x27;Weibo&#x27;,&#x27;Weixin&#x27;)</span><br><span class="line">&gt;&gt;&gt; tup[1]</span><br><span class="line">&#x27;Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; tup[-2]</span><br><span class="line">&#x27;Weibo&#x27;</span><br><span class="line">&gt;&gt;&gt; tup[1:]</span><br><span class="line">(&#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;, &#x27;Weibo&#x27;, &#x27;Weixin&#x27;)</span><br><span class="line">&gt;&gt;&gt; tup[1:4]</span><br><span class="line">(&#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;Wiki&#x27;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h2><p>Python元组包含了以下内置函数</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(tuple) 计算元组元素个数。</td>
<td align="left"><code>&gt;&gt;&gt; tuple1 = (&#39;Google&#39;, &#39;Runoob&#39;, &#39;Taobao&#39;) &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">max(tuple) 返回元组中元素最大值。</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; max(tuple2) &#39;8&#39; &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">min(tuple) 返回元组中元素最小值。</td>
<td align="left"><code>&gt;&gt;&gt; tuple2 = (&#39;5&#39;, &#39;4&#39;, &#39;8&#39;) &gt;&gt;&gt; min(tuple2) &#39;4&#39; &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">tuple(iterable) 将可迭代系列转换为元组。</td>
<td align="left"><code>&gt;&gt;&gt; list1= [&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 (&#39;Google&#39;, &#39;Taobao&#39;, &#39;Runoob&#39;, &#39;Baidu&#39;)</code></td>
</tr>
</tbody></table>
<p><strong>关于元组是不可变的</strong></p>
<p>所谓元组的不可变指的是元组所指向的内存中的内容不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tup = (&#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;)</span><br><span class="line">&gt;&gt;&gt; tup[0] = &#x27;g&#x27;     # 不支持修改元素</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; id(tup)     # 查看内存地址</span><br><span class="line">4440687904</span><br><span class="line">&gt;&gt;&gt; tup = (1,2,3)</span><br><span class="line">&gt;&gt;&gt; id(tup)</span><br><span class="line">4441088800    # 内存地址不一样了</span><br></pre></td></tr></table></figure>

<p>从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。</p>
<hr>
<h1 id="Python3-字典"><a href="#Python3-字典" class="headerlink" title="Python3 字典"></a>Python3 字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 <strong>key&#x3D;&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2, key3 : value3 &#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>dict</strong> 作为 Python 的关键字和内置函数，变量名不建议命名为 <strong>dict</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/64af7aba1ddac507cc238c2b.png"></p>
<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字。</p>
<p>一个简单的字典实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinydict = &#123;&#x27;name&#x27;: &#x27;runoob&#x27;, &#x27;likes&#x27;: 123, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/64af7ad81ddac507cc23f85a.png"></p>
<p>也可如此创建字典：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinydict1 = &#123; &#x27;abc&#x27;: 456 &#125;</span><br><span class="line">tinydict2 = &#123; &#x27;abc&#x27;: 123, 98.6: 37 &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h2><h3 id="使用大括号-创建空字典："><a href="#使用大括号-创建空字典：" class="headerlink" title="使用大括号 { } 创建空字典："></a>使用大括号 <strong>{ }</strong> 创建空字典：</h3><p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用大括号 &#123;&#125; 来创建空字典</span><br><span class="line">emptyDict = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"># 打印字典</span><br><span class="line">print(emptyDict)</span><br><span class="line"> </span><br><span class="line"># 查看字典的数量</span><br><span class="line">print(&quot;Length:&quot;, len(emptyDict))</span><br><span class="line"> </span><br><span class="line"># 查看类型</span><br><span class="line">print(type(emptyDict))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">Length: 0</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用内建函数-dict-创建字典："><a href="#使用内建函数-dict-创建字典：" class="headerlink" title="使用内建函数 dict() 创建字典："></a>使用内建函数 <strong>dict()</strong> 创建字典：</h3><p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emptyDict = dict()</span><br><span class="line"> </span><br><span class="line"># 打印字典</span><br><span class="line">print(emptyDict)</span><br><span class="line"> </span><br><span class="line"># 查看字典的数量</span><br><span class="line">print(&quot;Length:&quot;,len(emptyDict))</span><br><span class="line"> </span><br><span class="line"># 查看类型</span><br><span class="line">print(type(emptyDict))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line">Length: 0</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h2><p>把相应的键放入到方括号中，如下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])</span><br><span class="line">print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinydict[&#x27;Name&#x27;]:  Runoob</span><br><span class="line">tinydict[&#x27;Age&#x27;]:  7</span><br></pre></td></tr></table></figure>

<p>如果用字典里没有的键访问数据，会输出错误如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Alice&#x27;]: &quot;, tinydict[&#x27;Alice&#x27;])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    print (&quot;tinydict[&#x27;Alice&#x27;]: &quot;, tinydict[&#x27;Alice&#x27;])</span><br><span class="line">KeyError: &#x27;Alice&#x27;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h2><p>向字典添加新内容的方法是增加新的键&#x2F;值对，修改或删除已有键&#x2F;值对如下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">tinydict[&#x27;Age&#x27;] = 8               # 更新 Age</span><br><span class="line">tinydict[&#x27;School&#x27;] = &quot;菜鸟教程&quot;  # 添加信息</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])</span><br><span class="line">print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinydict[&#x27;Age&#x27;]:  8</span><br><span class="line">tinydict[&#x27;School&#x27;]:  菜鸟教程</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h2><p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显式删除一个字典用del命令，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;</span><br><span class="line">tinydict.clear()     # 清空字典</span><br><span class="line">del tinydict         # 删除字典</span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])</span><br><span class="line">print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;])</span><br></pre></td></tr></table></figure>

<p>但这会引发一个异常，因为用执行 del 操作后字典不再存在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/runoob-test/test.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])</span><br><span class="line">NameError: name &#x27;tinydict&#x27; is not defined</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>del() 方法后面也会讨论。</p>
<h2 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h2><p>字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Name&#x27;: &#x27;小菜鸟&#x27;&#125;</span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinydict[&#x27;Name&#x27;]:  小菜鸟</span><br></pre></td></tr></table></figure>

<p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">tinydict = &#123;[&#x27;Name&#x27;]: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7&#125;</span><br><span class="line"> </span><br><span class="line">print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    tinydict = &#123;[&#x27;Name&#x27;]: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字典内置函数-方法"><a href="#字典内置函数-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h2><p>Python字典包含了以下内置函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">len(dict) 计算字典元素个数，即键的总数。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">str(dict) 输出字典，可以打印的字符串表示。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td>
<td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td>
</tr>
</tbody></table>
<p>Python字典包含了以下内置方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典 key（键）所对应的值，返回被删除的值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td>
</tr>
</tbody></table>
<hr>
<h1 id="Python3-集合"><a href="#Python3-集合" class="headerlink" title="Python3 集合"></a>Python3 集合</h1><p>集合（set）是一个无序的不重复元素序列。</p>
<p>集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。</p>
<p>可以使用大括号 <strong>{ }</strong> 创建集合，元素之间用逗号 <strong>,</strong> 分隔， 或者也可以使用 <strong>set()</strong> 函数创建集合。</p>
<p><strong>创建格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line">set(value)</span><br></pre></td></tr></table></figure>

<p>以下是一个简单实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set1 = &#123;1, 2, 3, 4&#125;            # 直接使用大括号创建集合</span><br><span class="line">set2 = set([4, 5, 6, 7])      # 使用 set() 函数从列表创建集合</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>更多实例演示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; print(basket)                      # 这里演示的是去重功能</span><br><span class="line">&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; &#x27;orange&#x27; in basket                 # 快速判断元素是否在集合内</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;crabgrass&#x27; in basket</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # 下面展示两个集合间的运算.</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)</span><br><span class="line">&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)</span><br><span class="line">&gt;&gt;&gt; a                                  </span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a - b                              # 集合a中包含而集合b中不包含的元素</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a | b                              # 集合a或b中包含的所有元素</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a &amp; b                              # 集合a和b中都包含了的元素</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a ^ b                              # 不同时包含于a和b的元素</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>类似列表推导式，同样集合支持集合推导式(Set comprehension):</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合的基本操作"><a href="#集合的基本操作" class="headerlink" title="集合的基本操作"></a>集合的基本操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.add( x )</span><br></pre></td></tr></table></figure>

<p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; thisset.add(&quot;Facebook&quot;)</span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">&#123;&#x27;Taobao&#x27;, &#x27;Facebook&#x27;, &#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.update( x )</span><br></pre></td></tr></table></figure>

<p>x 可以有多个，用逗号分开。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; thisset.update(&#123;1,3&#125;)</span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">&#123;1, 3, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; thisset.update([1,4],[5,6])  </span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">&#123;1, 3, 4, 5, 6, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.remove( x )</span><br></pre></td></tr></table></figure>

<p>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; thisset.remove(&quot;Taobao&quot;)</span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">&#123;&#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; thisset.remove(&quot;Facebook&quot;)   # 不存在会发生错误</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#x27;Facebook&#x27;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.discard( x )</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; thisset.discard(&quot;Facebook&quot;)  # 不存在不会发生错误</span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">&#123;&#x27;Taobao&#x27;, &#x27;Google&#x27;, &#x27;Runoob&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以设置随机删除集合中的一个元素，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.pop() </span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;, &quot;Facebook&quot;))</span><br><span class="line">x = thisset.pop()</span><br><span class="line"></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob</span><br></pre></td></tr></table></figure>

<p>多次执行测试结果都不一样。</p>
<p>set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。</p>
<h3 id="计算集合元素个数"><a href="#计算集合元素个数" class="headerlink" title="计算集合元素个数"></a>计算集合元素个数</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">len(s)</span><br></pre></td></tr></table></figure>

<p>计算集合 s 元素个数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; len(thisset)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>

<p>清空集合 s。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; thisset.clear()</span><br><span class="line">&gt;&gt;&gt; print(thisset)</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>

<h3 id="判断元素是否在集合中存在"><a href="#判断元素是否在集合中存在" class="headerlink" title="判断元素是否在集合中存在"></a>判断元素是否在集合中存在</h3><p><strong>语法格式如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x in s</span><br></pre></td></tr></table></figure>

<p>判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class="line">&gt;&gt;&gt; &quot;Runoob&quot; in thisset</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;Facebook&quot; in thisset</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合内置方法完整列表"><a href="#集合内置方法完整列表" class="headerlink" title="集合内置方法完整列表"></a>集合内置方法完整列表</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td>
<td align="left">为集合添加元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td>
<td align="left">移除集合中的所有元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td>
<td align="left">拷贝一个集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td>
<td align="left">返回多个集合的差集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td>
<td align="left">移除集合中的元素，该元素在指定的集合也存在。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td>
<td align="left">删除集合中指定的元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td>
<td align="left">返回集合的交集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td>
<td align="left">返回集合的交集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td>
<td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td>
<td align="left">判断指定集合是否为该方法参数集合的子集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td>
<td align="left">判断该方法的参数集合是否为指定集合的子集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td>
<td align="left">随机移除元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td>
<td align="left">移除指定元素</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td>
<td align="left">返回两个集合中不重复的元素集合。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td>
<td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td>
<td align="left">返回两个集合的并集</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td>
<td align="left">给集合添加元素</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Python3数字、字符串</title>
    <url>/2023/06/03/Python3%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-数字"><a href="#Python3-数字" class="headerlink" title="Python3 数字"></a>Python3 数字</h1><p>Python 数字数据类型用于存储数值。</p>
<p>数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间。</p>
<p>以下实例在变量赋值时 Number 对象将被创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure>

<p>您也可以使用del语句删除一些数字对象的引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure>

<p>您可以通过使用del语句删除单个或多个对象的引用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>

<p>Python 支持三种不同的数值类型：</p>
<ul>
<li><strong>整型(int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。布尔(bool)是整型的子类型。</li>
<li><strong>浮点型(float)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x 102 &#x3D; 250）</li>
<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>我们可以使用十六进制和八进制来代表整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; number = 0xA0F # 十六进制</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line">2575</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; number=0o37 # 八进制</span><br><span class="line">&gt;&gt;&gt; number</span><br><span class="line">31</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">int</th>
<th align="left">float</th>
<th align="left">complex</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10</td>
<td align="left">0.0</td>
<td align="left">3.14j</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">15.20</td>
<td align="left">45.j</td>
</tr>
<tr>
<td align="left">-786</td>
<td align="left">-21.9</td>
<td align="left">9.322e-36j</td>
</tr>
<tr>
<td align="left">080</td>
<td align="left">32.3e+18</td>
<td align="left">.876j</td>
</tr>
<tr>
<td align="left">-0490</td>
<td align="left">-90.</td>
<td align="left">-.6545+0J</td>
</tr>
<tr>
<td align="left">-0x260</td>
<td align="left">-32.54e100</td>
<td align="left">3e+26J</td>
</tr>
<tr>
<td align="left">0x69</td>
<td align="left">70.2E-12</td>
<td align="left">4.53e-7j</td>
</tr>
</tbody></table>
<ul>
<li>Python支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<hr>
<h2 id="Python-数字类型转换"><a href="#Python-数字类型转换" class="headerlink" title="Python 数字类型转换"></a>Python 数字类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><strong>int(x)</strong> 将x转换为一个整数。</li>
<li><strong>float(x)</strong> 将x转换到一个浮点数。</li>
<li><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</li>
<li><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。</li>
</ul>
<p>以下实例将浮点数变量 a 转换为整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 1.0</span><br><span class="line">&gt;&gt;&gt; int(a)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-数字运算"><a href="#Python-数字运算" class="headerlink" title="Python 数字运算"></a>Python 数字运算</h2><p>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p>
<p>表达式的语法很直白： <strong>+</strong>, <strong>-</strong>, ***** 和 <strong>&#x2F;</strong>, 和其它语言（如Pascal或C）里一样。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 50 - 5*6</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; (50 - 5*6) / 4</span><br><span class="line">5.0</span><br><span class="line">&gt;&gt;&gt; 8 / 5  # 总是返回一个浮点数</span><br><span class="line">1.6</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在不同的机器上浮点运算的结果可能会不一样。</p>
<p>在整数除法中，除法 <strong>&#x2F;</strong> 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 <strong>&#x2F;&#x2F;</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 17 / 3  # 整数除法返回浮点型</span><br><span class="line">5.666666666666667</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; 17 // 3  # 整数除法返回向下取整后的结果</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; 17 % 3  # ％操作符返回除法的余数</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 5 * 3 + 2 </span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><strong>&#x2F;&#x2F;</strong> 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 7//2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 7.0//2</span><br><span class="line">3.0</span><br><span class="line">&gt;&gt;&gt; 7//2.0</span><br><span class="line">3.0</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>

<p>等号 <strong>&#x3D;</strong> 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; width = 20</span><br><span class="line">&gt;&gt;&gt; height = 5*9</span><br><span class="line">&gt;&gt;&gt; width * height</span><br><span class="line">900</span><br></pre></td></tr></table></figure>

<p>Python 可以使用 *<strong>*</strong> 操作来进行幂运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 ** 2  # 5 的平方</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; 2 ** 7  # 2的7次方</span><br><span class="line">128</span><br></pre></td></tr></table></figure>

<p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; n   # 尝试访问一个未定义的变量</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &#x27;n&#x27; is not defined</span><br></pre></td></tr></table></figure>

<p>不同类型的数混合运算时会将整数转换为浮点数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 * 3.75 / 1.5</span><br><span class="line">7.5</span><br><span class="line">&gt;&gt;&gt; 7.0 / 2</span><br><span class="line">3.5</span><br></pre></td></tr></table></figure>

<p>在交互模式中，最后被输出的表达式结果被赋值给变量 <strong>_</strong> 。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tax = 12.5 / 100</span><br><span class="line">&gt;&gt;&gt; price = 100.50</span><br><span class="line">&gt;&gt;&gt; price * tax</span><br><span class="line">12.5625</span><br><span class="line">&gt;&gt;&gt; price + _</span><br><span class="line">113.0625</span><br><span class="line">&gt;&gt;&gt; round(_, 2)</span><br><span class="line">113.06</span><br></pre></td></tr></table></figure>

<p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p>
<hr>
<h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td>
<td align="left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td>
<td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td align="left">cmp(x, y)</td>
<td align="left">如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td>
<td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td>
<td align="left">以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td>
<td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td>
<td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td>
<td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td>
<td align="left">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td>
<td align="left">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td>
<td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td>
<td align="left">x**y 运算后的值。</td>
</tr>
<tr>
<td align="left">[round(x <a href="https://www.runoob.com/python3/python3-func-number-round.html">,n])</a></td>
<td align="left">返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td>
<td align="left">返回数字x的平方根。</td>
</tr>
</tbody></table>
<hr>
<h2 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h2><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-choice.html">choice(seq)</a></td>
<td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td align="left">[randrange (<a href="https://www.runoob.com/python3/python3-func-number-randrange.html">start,] stop [,step])</a></td>
<td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-random.html">random()</a></td>
<td align="left">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td align="left">[seed(<a href="https://www.runoob.com/python3/python3-func-number-seed.html">x])</a></td>
<td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-shuffle.html">shuffle(lst)</a></td>
<td align="left">将序列的所有元素随机排序</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-uniform.html">uniform(x, y)</a></td>
<td align="left">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody></table>
<hr>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>Python包括以下三角函数：</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-acos.html">acos(x)</a></td>
<td align="left">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-asin.html">asin(x)</a></td>
<td align="left">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan.html">atan(x)</a></td>
<td align="left">返回x的反正切弧度值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-atan2.html">atan2(y, x)</a></td>
<td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-cos.html">cos(x)</a></td>
<td align="left">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-hypot.html">hypot(x, y)</a></td>
<td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-sin.html">sin(x)</a></td>
<td align="left">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-tan.html">tan(x)</a></td>
<td align="left">返回x弧度的正切值。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-degrees.html">degrees(x)</a></td>
<td align="left">将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-number-radians.html">radians(x)</a></td>
<td align="left">将角度转换为弧度</td>
</tr>
</tbody></table>
<hr>
<h2 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h2><table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pi</td>
<td align="left">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody></table>
<hr>
<h1 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h1><p>字符串是 Python 中最常用的数据类型。我们可以使用引号( <strong>‘</strong> 或 <strong>“</strong> )来创建字符串。</p>
<p>创建字符串很简单，只要为变量分配一个值即可。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = &#x27;Hello World!&#x27;</span><br><span class="line">var2 = &quot;Runoob&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Python-访问字符串中的值"><a href="#Python-访问字符串中的值" class="headerlink" title="Python 访问字符串中的值"></a>Python 访问字符串中的值</h2><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</p>
<p>Python 访问子字符串，可以使用方括号 <strong>[]</strong> 来截取字符串，字符串的截取的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure>

<p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p>
<p><a href="https://pic.imgdb.cn/item/647b2a61f024cca1731c8c36.jpg"><img src="https://pic.imgdb.cn/item/647b2a61f024cca1731c8c36.jpg"></a></p>
<p><a href="https://pic.imgdb.cn/item/647b35d5f024cca173293f7f.jpg"><img src="https://pic.imgdb.cn/item/647b35d5f024cca173293f7f.jpg"></a></p>
<p>如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = &#x27;Hello World!&#x27;</span><br><span class="line">var2 = &quot;Runoob&quot;</span><br><span class="line"> </span><br><span class="line">print (&quot;var1[0]: &quot;, var1[0])</span><br><span class="line">print (&quot;var2[1:5]: &quot;, var2[1:5])</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1[0]:  H</span><br><span class="line">var2[1:5]:  unoo</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-字符串更新"><a href="#Python-字符串更新" class="headerlink" title="Python 字符串更新"></a>Python 字符串更新</h2><p>你可以截取字符串的一部分并与其他字段拼接，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = &#x27;Hello World!&#x27;</span><br><span class="line"> </span><br><span class="line">print (&quot;已更新字符串 : &quot;, var1[:6] + &#x27;Runoob!&#x27;)</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已更新字符串 :  Hello Runoob!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-转义字符"><a href="#Python-转义字符" class="headerlink" title="Python 转义字符"></a>Python 转义字符</h2><p>在需要在字符中使用特殊字符时，python 用反斜杠<code>\</code>转义字符。如下表：</p>
<table>
<thead>
<tr>
<th align="left">转义字符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\在行尾时</td>
<td align="left">续行符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;line1 \ ... line2 \ ... line3&quot;) line1 line2 line3 &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜杠符号</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\\&quot;) \</code></td>
</tr>
<tr>
<td align="left"><code>\&#39;</code></td>
<td align="left">单引号</td>
<td align="left"><code>&gt;&gt;&gt; print(&#39;\&#39;&#39;) &#39;</code></td>
</tr>
<tr>
<td align="left"><code>\&quot;</code></td>
<td align="left">双引号</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\&quot;&quot;) &quot;</code></td>
</tr>
<tr>
<td align="left">\a</td>
<td align="left">响铃</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\a&quot;)</code>执行后电脑有响声。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格(Backspace)</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \b World!&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\000</td>
<td align="left">空</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\000&quot;) &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\n&quot;)  &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">纵向制表符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \v World!&quot;) Hello        World! &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">横向制表符</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \t World!&quot;) Hello    World! &gt;&gt;&gt;</code></td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车，将 <strong>\r</strong> 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 <strong>\r</strong> 后面的内容完全替换完成。</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello\rWorld!&quot;) World! &gt;&gt;&gt; print(&#39;google runoob taobao\r123456&#39;) 123456 runoob taobao</code></td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;Hello \f World!&quot;) Hello        World! &gt;&gt;&gt; </code></td>
</tr>
<tr>
<td align="left">\yyy</td>
<td align="left">八进制数，y 代表 0~7 的字符，例如：\012 代表换行。</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\110\145\154\154\157\40\127\157\162\154\144\41&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\xyy</td>
<td align="left">十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行</td>
<td align="left"><code>&gt;&gt;&gt; print(&quot;\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21&quot;) Hello World!</code></td>
</tr>
<tr>
<td align="left">\other</td>
<td align="left">其它的字符以普通格式输出</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>使用 <strong>\r</strong> 实现百分比进度：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">for i in range(101):</span><br><span class="line">    print(&quot;\r&#123;:3&#125;%&quot;.format(i),end=&#x27; &#x27;)</span><br><span class="line">    time.sleep(0.05)</span><br></pre></td></tr></table></figure>

<p>以下实例，我们使用了不同的转义字符来演示单引号、换行符、制表符、退格符、换页符、ASCII、二进制、八进制数和十六进制数的效果：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;\&#x27;Hello, world!\&#x27;&#x27;)  # 输出：&#x27;Hello, world!&#x27;</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, world!\nHow are you?&quot;)  # 输出：Hello, world!</span><br><span class="line">                                        #       How are you?</span><br><span class="line"></span><br><span class="line">print(&quot;Hello, world!\tHow are you?&quot;)  # 输出：Hello, world!    How are you?</span><br><span class="line"></span><br><span class="line">print(&quot;Hello,\b world!&quot;)  # 输出：Hello world!</span><br><span class="line"></span><br><span class="line">print(&quot;Hello,\f world!&quot;)  # 输出：</span><br><span class="line">                           # Hello,</span><br><span class="line">                           #  world!</span><br><span class="line"></span><br><span class="line">print(&quot;A 对应的 ASCII 值为：&quot;, ord(&#x27;A&#x27;))  # 输出：A 对应的 ASCII 值为： 65</span><br><span class="line"></span><br><span class="line">print(&quot;\x41 为 A 的 ASCII 代码&quot;)  # 输出：A 为 A 的 ASCII 代码</span><br><span class="line"></span><br><span class="line">decimal_number = 42</span><br><span class="line">binary_number = bin(decimal_number)  # 十进制转换为二进制</span><br><span class="line">print(&#x27;转换为二进制:&#x27;, binary_number)  # 转换为二进制: 0b101010</span><br><span class="line"></span><br><span class="line">octal_number = oct(decimal_number)  # 十进制转换为八进制</span><br><span class="line">print(&#x27;转换为八进制:&#x27;, octal_number)  # 转换为八进制: 0o52</span><br><span class="line"></span><br><span class="line">hexadecimal_number = hex(decimal_number)  # 十进制转换为十六进制</span><br><span class="line">print(&#x27;转换为十六进制:&#x27;, hexadecimal_number) # 转换为十六进制: 0x2a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-字符串运算符"><a href="#Python-字符串运算符" class="headerlink" title="Python 字符串运算符"></a>Python 字符串运算符</h2><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">字符串连接</td>
<td align="left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">重复输出字符串</td>
<td align="left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">通过索引获取字符串中字符</td>
<td align="left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td align="left">[ : ]</td>
<td align="left">截取字符串中的一部分，遵循<strong>左闭右开</strong>原则，str[0:2] 是不包含第 3 个字符的。</td>
<td align="left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td align="left"><strong>‘H’ in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td align="left"><strong>‘M’ not in a</strong> 输出结果 True</td>
</tr>
<tr>
<td align="left">r&#x2F;R</td>
<td align="left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 <strong>r</strong>（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td align="left"><code>print( r&#39;\n&#39; ) print( R&#39;\n&#39; )</code></td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">格式字符串</td>
<td align="left">请看下一节内容。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;Hello&quot;</span><br><span class="line">b = &quot;Python&quot;</span><br><span class="line"> </span><br><span class="line">print(&quot;a + b 输出结果：&quot;, a + b)</span><br><span class="line">print(&quot;a * 2 输出结果：&quot;, a * 2)</span><br><span class="line">print(&quot;a[1] 输出结果：&quot;, a[1])</span><br><span class="line">print(&quot;a[1:4] 输出结果：&quot;, a[1:4])</span><br><span class="line"> </span><br><span class="line">if( &quot;H&quot; in a) :</span><br><span class="line">    print(&quot;H 在变量 a 中&quot;)</span><br><span class="line">else :</span><br><span class="line">    print(&quot;H 不在变量 a 中&quot;)</span><br><span class="line"> </span><br><span class="line">if( &quot;M&quot; not in a) :</span><br><span class="line">    print(&quot;M 不在变量 a 中&quot;)</span><br><span class="line">else :</span><br><span class="line">    print(&quot;M 在变量 a 中&quot;)</span><br><span class="line"> </span><br><span class="line">print (r&#x27;\n&#x27;)</span><br><span class="line">print (R&#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b 输出结果： HelloPython</span><br><span class="line">a * 2 输出结果： HelloHello</span><br><span class="line">a[1] 输出结果： e</span><br><span class="line">a[1:4] 输出结果： ell</span><br><span class="line">H 在变量 a 中</span><br><span class="line">M 不在变量 a 中</span><br><span class="line">\n</span><br><span class="line">\n</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-字符串格式化"><a href="#Python-字符串格式化" class="headerlink" title="Python 字符串格式化"></a>Python 字符串格式化</h2><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p>
<p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print (&quot;我叫 %s 今年 %d 岁!&quot; % (&#x27;小明&#x27;, 10))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我叫 小明 今年 10 岁!</span><br></pre></td></tr></table></figure>

<p>python字符串格式化符号:</p>
<table>
<thead>
<tr>
<th align="left">符  号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%c</td>
<td align="left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">格式化字符串</td>
</tr>
<tr>
<td align="left">%d</td>
<td align="left">格式化整数</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">格式化无符号整型</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">格式化无符号八进制数</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">格式化无符号十六进制数</td>
</tr>
<tr>
<td align="left">%X</td>
<td align="left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td align="left">%f</td>
<td align="left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td align="left">%e</td>
<td align="left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%E</td>
<td align="left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td align="left">%g</td>
<td align="left">%f和%e的简写</td>
</tr>
<tr>
<td align="left">%G</td>
<td align="left">%f 和 %E 的简写</td>
</tr>
<tr>
<td align="left">%p</td>
<td align="left">用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<p>格式化操作符辅助指令:</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">用做左对齐</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td align="left"><sp></td>
<td align="left">在正数前面显示空格</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td align="left">(var)</td>
<td align="left">映射变量(字典参数)</td>
</tr>
<tr>
<td align="left">m.n.</td>
<td align="left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody></table>
<p>Python2.6 开始，新增了一种格式化字符串的函数 <a href="https://www.runoob.com/python/att-string-format.html">str.format()</a>，它增强了字符串格式化的功能。</p>
<hr>
<h2 id="Python三引号"><a href="#Python三引号" class="headerlink" title="Python三引号"></a>Python三引号</h2><p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">para_str = &quot;&quot;&quot;这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB ( \t )。</span><br><span class="line">也可以使用换行符 [ \n ]。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">print (para_str)</span><br></pre></td></tr></table></figure>

<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个多行字符串的实例</span><br><span class="line">多行字符串可以使用制表符</span><br><span class="line">TAB (    )。</span><br><span class="line">也可以使用换行符 [ </span><br><span class="line"> ]。</span><br></pre></td></tr></table></figure>

<p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p>
<p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">errHTML = &#x27;&#x27;&#x27;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span><br><span class="line">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span><br><span class="line">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span><br><span class="line">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">cursor.execute(&#x27;&#x27;&#x27;</span><br><span class="line">CREATE TABLE users (  </span><br><span class="line">login VARCHAR(8), </span><br><span class="line">uid INTEGER,</span><br><span class="line">prid INTEGER)</span><br><span class="line">&#x27;&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。</p>
<p>之前我们习惯用百分号 (%):</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name = &#x27;Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;Hello %s&#x27; % name</span><br><span class="line">&#x27;Hello Runoob&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>f-string</strong> 格式化字符串以 <strong>f</strong> 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name = &#x27;Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; f&#x27;Hello &#123;name&#125;&#x27;  # 替换变量</span><br><span class="line">&#x27;Hello Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; f&#x27;&#123;1+2&#125;&#x27;         # 使用表达式</span><br><span class="line">&#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; w = &#123;&#x27;name&#x27;: &#x27;Runoob&#x27;, &#x27;url&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; f&#x27;&#123;w[&quot;name&quot;]&#125;: &#123;w[&quot;url&quot;]&#125;&#x27;</span><br><span class="line">&#x27;Runoob: www.runoob.com&#x27;</span><br></pre></td></tr></table></figure>

<p>用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。</p>
<p>在 Python 3.8 的版本中可以使用 <strong>&#x3D;</strong> 符号来拼接运算表达式与结果：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1</span><br><span class="line">&gt;&gt;&gt; print(f&#x27;&#123;x+1&#125;&#x27;)   # Python 3.6</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; x = 1</span><br><span class="line">&gt;&gt;&gt; print(f&#x27;&#123;x+1=&#125;&#x27;)   # Python 3.8</span><br><span class="line">x+1=2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h2><p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <strong>u</strong>。</p>
<p>在Python3中，所有的字符串都是Unicode字符串。</p>
<hr>
<h2 id="Python-的字符串内建函数"><a href="#Python-的字符串内建函数" class="headerlink" title="Python 的字符串内建函数"></a>Python 的字符串内建函数</h2><p>Python 的字符串常用内建函数如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg&#x3D; 0,end&#x3D;len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding&#x3D;”utf-8”, errors&#x3D;”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding&#x3D;’UTF-8’,errors&#x3D;’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg&#x3D;0, end&#x3D;len(string))</a> 检查字符串是否以 suffix 结束，如果 beg 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize&#x3D;8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg&#x3D;0, end&#x3D;len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg&#x3D;0, end&#x3D;len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg&#x3D;0,end&#x3D;len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg&#x3D;0, end&#x3D;len(string))</a> 类似于 index()，不过是从右边开始.</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str&#x3D;””, num&#x3D;string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg&#x3D;0,end&#x3D;len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars&#x3D;””)</a> 根据 table 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Python3 条件控制、循环语句</title>
    <url>/2023/07/13/Python3%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-条件控制"><a href="#Python3-条件控制" class="headerlink" title="Python3 条件控制"></a>Python3 条件控制</h1><p>Python 条件语句是通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。</p>
<p>可以通过下图来简单了解条件语句的执行过程:</p>
<p><img src="https://pic.imgdb.cn/item/64af7d7b1ddac507cc2dfce1.jpg"></p>
<p>代码执行过程：</p>
<p><img src="https://pic.imgdb.cn/item/64af7d901ddac507cc2e3e0d.webp"></p>
<hr>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>Python中if语句的一般形式如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line">elif condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line">else:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li>
<li>如果 “condition_1” 为False，将判断 “condition_2”</li>
<li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li>
<li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li>
</ul>
<p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if – elif – else</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。</li>
<li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li>
<li>3、在 Python 中没有 <strong>switch…case</strong> 语句，但在 Python3.10 版本添加了 <strong>match…case</strong>，功能也类似，详见下文。</li>
</ul>
<p>Gif 演示：</p>
<p><img src="https://pic.imgdb.cn/item/64af7dc41ddac507cc2ef37d.gif"></p>
<p>以下是一个简单的 if 实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">var1 = 100</span><br><span class="line">if var1:</span><br><span class="line">    print (&quot;1 - if 表达式条件为 true&quot;)</span><br><span class="line">    print (var1)</span><br><span class="line"> </span><br><span class="line">var2 = 0</span><br><span class="line">if var2:</span><br><span class="line">    print (&quot;2 - if 表达式条件为 true&quot;)</span><br><span class="line">    print (var2)</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - if 表达式条件为 true</span><br><span class="line">100</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。</p>
<p>以下实例演示了狗的年龄计算判断：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">age = int(input(&quot;请输入你家狗狗的年龄: &quot;))</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">if age &lt;= 0:</span><br><span class="line">    print(&quot;你是在逗我吧!&quot;)</span><br><span class="line">elif age == 1:</span><br><span class="line">    print(&quot;相当于 14 岁的人。&quot;)</span><br><span class="line">elif age == 2:</span><br><span class="line">    print(&quot;相当于 22 岁的人。&quot;)</span><br><span class="line">elif age &gt; 2:</span><br><span class="line">    human = 22 + (age -2)*5</span><br><span class="line">    print(&quot;对应人类年龄: &quot;, human)</span><br><span class="line"> </span><br><span class="line">### 退出提示</span><br><span class="line">input(&quot;点击 enter 键退出&quot;)</span><br></pre></td></tr></table></figure>

<p>将以上脚本保存在dog.py文件中，并执行该脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 dog.py </span><br><span class="line">请输入你家狗狗的年龄: 1</span><br><span class="line"></span><br><span class="line">相当于 14 岁的人。</span><br><span class="line">点击 enter 键退出</span><br></pre></td></tr></table></figure>

<p>以下为if中常用的操作运算符:</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left"><code>==</code></td>
<td align="left">等于，比较两个值是否相等</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line"># 程序演示了 == 操作符</span><br><span class="line"># 使用数字</span><br><span class="line">print(5 == 6)</span><br><span class="line"># 使用变量</span><br><span class="line">x = 5</span><br><span class="line">y = 8</span><br><span class="line">print(x == y)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>high_low.py文件演示了数字的比较运算：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3 </span><br><span class="line"> </span><br><span class="line"># 该实例演示了数字猜谜游戏</span><br><span class="line">number = 7</span><br><span class="line">guess = -1</span><br><span class="line">print(&quot;数字猜谜游戏!&quot;)</span><br><span class="line">while guess != number:</span><br><span class="line">    guess = int(input(&quot;请输入你猜的数字：&quot;))</span><br><span class="line"> </span><br><span class="line">    if guess == number:</span><br><span class="line">        print(&quot;恭喜，你猜对了！&quot;)</span><br><span class="line">    elif guess &lt; number:</span><br><span class="line">        print(&quot;猜的数字小了...&quot;)</span><br><span class="line">    elif guess &gt; number:</span><br><span class="line">        print(&quot;猜的数字大了...&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，实例输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 high_low.py </span><br><span class="line">数字猜谜游戏!</span><br><span class="line">请输入你猜的数字：1</span><br><span class="line">猜的数字小了...</span><br><span class="line">请输入你猜的数字：9</span><br><span class="line">猜的数字大了...</span><br><span class="line">请输入你猜的数字：7</span><br><span class="line">恭喜，你猜对了！</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h2><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 表达式1:</span><br><span class="line">    语句</span><br><span class="line">    if 表达式2:</span><br><span class="line">        语句</span><br><span class="line">    elif 表达式3:</span><br><span class="line">        语句</span><br><span class="line">    else:</span><br><span class="line">        语句</span><br><span class="line">elif 表达式4:</span><br><span class="line">    语句</span><br><span class="line">else:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># !/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">num=int(input(&quot;输入一个数字：&quot;))</span><br><span class="line">if num%2==0:</span><br><span class="line">    if num%3==0:</span><br><span class="line">        print (&quot;你输入的数字可以整除 2 和 3&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print (&quot;你输入的数字可以整除 2，但不能整除 3&quot;)</span><br><span class="line">else:</span><br><span class="line">    if num%3==0:</span><br><span class="line">        print (&quot;你输入的数字可以整除 3，但不能整除 2&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print  (&quot;你输入的数字不能整除 2 和 3&quot;)</span><br></pre></td></tr></table></figure>

<p>将以上程序保存到 test_if.py 文件中，执行后输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 test.py </span><br><span class="line">输入一个数字：6</span><br><span class="line">你输入的数字可以整除 2 和 3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="match…case"><a href="#match…case" class="headerlink" title="match…case"></a>match…case</h2><p>Python 3.10 增加了 <strong>match…case</strong> 的条件判断，不需要再使用一连串的 <strong>if-else</strong> 来判断了。</p>
<p>match 后的对象会依次与 case 后的内容进行匹配，如果匹配成功，则执行匹配到的表达式，否则直接跳过，**_** 可以匹配一切。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match subject:</span><br><span class="line">    case &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    case &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    case &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    case _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure>

<p><strong>case _:</strong> 类似于 C 和 Java 中的 **default:**，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def http_error(status):</span><br><span class="line">    match status:</span><br><span class="line">        case 400:</span><br><span class="line">            return &quot;Bad request&quot;</span><br><span class="line">        case 404:</span><br><span class="line">            return &quot;Not found&quot;</span><br><span class="line">        case 418:</span><br><span class="line">            return &quot;I&#x27;m a teapot&quot;</span><br><span class="line">        case _:</span><br><span class="line">            return &quot;Something&#x27;s wrong with the internet&quot;</span><br><span class="line"></span><br><span class="line">mystatus=400</span><br><span class="line">print(http_error(400))</span><br></pre></td></tr></table></figure>

<p>以上是一个输出 HTTP 状态码的实例，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bad request</span><br></pre></td></tr></table></figure>

<p>一个 case 也可以设置多个匹配条件，条件使用 <strong>｜</strong> 隔开，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    case 401|403|404:</span><br><span class="line">        return &quot;Not allowed&quot;</span><br></pre></td></tr></table></figure>

<h1 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h1><p>本章节将为大家介绍 Python 循环语句的使用。</p>
<p>Python 中的循环语句有 for 和 while。</p>
<p>Python 循环语句的控制结构图如下所示：</p>
<p><img src="https://pic.imgdb.cn/item/64af7e771ddac507cc31fd57.jpg"></p>
<hr>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>Python 中 while 语句的一般形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure>

<p>执行流程图如下：</p>
<p><img src="https://pic.imgdb.cn/item/64af7ead1ddac507cc32fe72.jpg"></p>
<p>执行 Gif 演示：</p>
<p><img src="https://pic.imgdb.cn/item/64af7ebd1ddac507cc33420e.gif"></p>
<p>同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环。</p>
<p>以下实例使用了 while 来计算 1 到 100 的总和：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"> </span><br><span class="line">n = 100</span><br><span class="line"> </span><br><span class="line">sum = 0</span><br><span class="line">counter = 1</span><br><span class="line">while counter &lt;= n:</span><br><span class="line">    sum = sum + counter</span><br><span class="line">    counter += 1</span><br><span class="line"> </span><br><span class="line">print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 到 100 之和为: 5050</span><br></pre></td></tr></table></figure>

<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">var = 1</span><br><span class="line">while var == 1 :  # 表达式永远为 true</span><br><span class="line">   num = int(input(&quot;输入一个数字  :&quot;))</span><br><span class="line">   print (&quot;你输入的数字是: &quot;, num)</span><br><span class="line"> </span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入一个数字  :5</span><br><span class="line">你输入的数字是:  5</span><br><span class="line">输入一个数字  :</span><br></pre></td></tr></table></figure>

<p>你可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p>
<p>无限循环在服务器上客户端的实时请求非常有用。</p>
<h3 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h3><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>

<p>expr 条件语句为 true 则执行 statement(s) 语句块，如果为 false，则执行 additional_statement(s)。</p>
<p>循环输出数字，并判断大小：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">count = 0</span><br><span class="line">while count &lt; 5:</span><br><span class="line">   print (count, &quot; 小于 5&quot;)</span><br><span class="line">   count = count + 1</span><br><span class="line">else:</span><br><span class="line">   print (count, &quot; 大于或等于 5&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0  小于 5</span><br><span class="line">1  小于 5</span><br><span class="line">2  小于 5</span><br><span class="line">3  小于 5</span><br><span class="line">4  小于 5</span><br><span class="line">5  大于或等于 5</span><br></pre></td></tr></table></figure>

<h3 id="简单语句组"><a href="#简单语句组" class="headerlink" title="简单语句组"></a>简单语句组</h3><p>类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与 while 写在同一行中， 如下所示：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"> </span><br><span class="line">flag = 1</span><br><span class="line"> </span><br><span class="line">while (flag): print (&#x27;欢迎访问菜鸟教程!&#x27;)</span><br><span class="line"> </span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>以上的无限循环你可以使用 CTRL+C 来中断循环。</p>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">欢迎访问菜鸟教程!</span><br><span class="line">欢迎访问菜鸟教程!</span><br><span class="line">欢迎访问菜鸟教程!</span><br><span class="line">欢迎访问菜鸟教程!</span><br><span class="line">欢迎访问菜鸟教程!</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>Python for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for &lt;variable&gt; in &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/64af7f3d1ddac507cc34f6c0.jpg"></p>
<p>Python for 循环实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]</span><br><span class="line">for site in sites:</span><br><span class="line">    print(site)</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Baidu</span><br><span class="line">Google</span><br><span class="line">Runoob</span><br><span class="line">Taobao</span><br></pre></td></tr></table></figure>

<p>也可用于打印字符串中的每个字符：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">word = &#x27;runoob&#x27;</span><br><span class="line"> </span><br><span class="line">for letter in word:</span><br><span class="line">    print(letter)</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r</span><br><span class="line">u</span><br><span class="line">n</span><br><span class="line">o</span><br><span class="line">o</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>整数范围值可以配合 range() 函数使用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">#  1 到 5 的所有数字：</span><br><span class="line">for number in range(1, 6):</span><br><span class="line">    print(number)</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h2><p>在 Python 中，for…else 语句用于在循环结束后执行一段代码。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for item in iterable:</span><br><span class="line">    # 循环主体</span><br><span class="line">else:</span><br><span class="line">    # 循环结束后执行的代码</span><br></pre></td></tr></table></figure>

<p>当循环执行完毕（即遍历完 iterable 中的所有元素）后，会执行 else 子句中的代码，如果在循环过程中遇到了 break 语句，则会中断循环，此时不会执行 else 子句。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in range(6):</span><br><span class="line">  print(x)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;Finally finished!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行脚本后，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Finally finished!</span><br></pre></td></tr></table></figure>

<p>以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体，不会执行 else 子句：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]</span><br><span class="line">for site in sites:</span><br><span class="line">    if site == &quot;Runoob&quot;:</span><br><span class="line">        print(&quot;菜鸟教程!&quot;)</span><br><span class="line">        break</span><br><span class="line">    print(&quot;循环数据 &quot; + site)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;没有循环数据!&quot;)</span><br><span class="line">print(&quot;完成循环!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行脚本后，在循环到 “Runoob”时会跳出循环体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">循环数据 Baidu</span><br><span class="line">循环数据 Google</span><br><span class="line">菜鸟教程!</span><br><span class="line">完成循环!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h2><p>如果你需要遍历数字序列，可以使用内置 range() 函数。它会生成数列，例如:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(5):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>你也可以使用 range() 指定区间的值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(5,9) :</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>也可以使 range() 以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(0, 10, 3) :</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>负数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;for i in range(-10, -100, -30) :</span><br><span class="line">    print(i)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">-10</span><br><span class="line">-40</span><br><span class="line">-70</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>可以结合 range() 和 len() 函数以遍历一个序列的索引,如下所示:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [&#x27;Google&#x27;, &#x27;Baidu&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;QQ&#x27;]</span><br><span class="line">&gt;&gt;&gt; for i in range(len(a)):</span><br><span class="line">...     print(i, a[i])</span><br><span class="line">... </span><br><span class="line">0 Google</span><br><span class="line">1 Baidu</span><br><span class="line">2 Runoob</span><br><span class="line">3 Taobao</span><br><span class="line">4 QQ</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>还可以使用 range() 函数来创建一个列表：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>更多关于 range() 函数用法参考：<a href="https://www.runoob.com/python3/python3-func-range.html">https://www.runoob.com/python3/python3-func-range.html</a></p>
<hr>
<h2 id="break-和-continue-语句及循环中的-else-子句"><a href="#break-和-continue-语句及循环中的-else-子句" class="headerlink" title="break 和 continue 语句及循环中的 else 子句"></a>break 和 continue 语句及循环中的 else 子句</h2><p><strong>break 执行流程图：</strong></p>
<p><img src="https://pic.imgdb.cn/item/64af800b1ddac507cc378275.jpg"></p>
<p><strong>continue 执行流程图：</strong></p>
<p><img src="https://pic.imgdb.cn/item/64af803d1ddac507cc380f9c.jpg"></p>
<p>while 语句代码执行过程：</p>
<p><img src="https://pic.imgdb.cn/item/64af80491ddac507cc383b1a.webp"></p>
<p>for 语句代码执行过程：</p>
<p><img src="https://pic.imgdb.cn/item/64af805d1ddac507cc387022.png"></p>
<p><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</p>
<p><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<h3 id="while-中使用-break："><a href="#while-中使用-break：" class="headerlink" title="while 中使用 break："></a>while 中使用 break：</h3><p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 5</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    n -= 1</span><br><span class="line">    if n == 2:</span><br><span class="line">        break</span><br><span class="line">    print(n)</span><br><span class="line">print(&#x27;循环结束。&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">循环结束。</span><br></pre></td></tr></table></figure>

<h3 id="while-中使用-continue："><a href="#while-中使用-continue：" class="headerlink" title="while 中使用 continue："></a>while 中使用 continue：</h3><p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 5</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    n -= 1</span><br><span class="line">    if n == 2:</span><br><span class="line">        continue</span><br><span class="line">    print(n)</span><br><span class="line">print(&#x27;循环结束。&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">循环结束。</span><br></pre></td></tr></table></figure>

<p>更多实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">for letter in &#x27;Runoob&#x27;:     # 第一个实例</span><br><span class="line">   if letter == &#x27;b&#x27;:</span><br><span class="line">      break</span><br><span class="line">   print (&#x27;当前字母为 :&#x27;, letter)</span><br><span class="line">  </span><br><span class="line">var = 10                    # 第二个实例</span><br><span class="line">while var &gt; 0:              </span><br><span class="line">   print (&#x27;当前变量值为 :&#x27;, var)</span><br><span class="line">   var = var -1</span><br><span class="line">   if var == 5:</span><br><span class="line">      break</span><br><span class="line"> </span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前字母为 : R</span><br><span class="line">当前字母为 : u</span><br><span class="line">当前字母为 : n</span><br><span class="line">当前字母为 : o</span><br><span class="line">当前字母为 : o</span><br><span class="line">当前变量值为 : 10</span><br><span class="line">当前变量值为 : 9</span><br><span class="line">当前变量值为 : 8</span><br><span class="line">当前变量值为 : 7</span><br><span class="line">当前变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<p>以下实例循环字符串 Runoob，碰到字母 o 跳过输出：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">for letter in &#x27;Runoob&#x27;:     # 第一个实例</span><br><span class="line">   if letter == &#x27;o&#x27;:        # 字母为 o 时跳过输出</span><br><span class="line">      continue</span><br><span class="line">   print (&#x27;当前字母 :&#x27;, letter)</span><br><span class="line"> </span><br><span class="line">var = 10                    # 第二个实例</span><br><span class="line">while var &gt; 0:              </span><br><span class="line">   var = var -1</span><br><span class="line">   if var == 5:             # 变量为 5 时跳过输出</span><br><span class="line">      continue</span><br><span class="line">   print (&#x27;当前变量值 :&#x27;, var)</span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">当前字母 : b</span><br><span class="line">当前变量值 : 9</span><br><span class="line">当前变量值 : 8</span><br><span class="line">当前变量值 : 7</span><br><span class="line">当前变量值 : 6</span><br><span class="line">当前变量值 : 4</span><br><span class="line">当前变量值 : 3</span><br><span class="line">当前变量值 : 2</span><br><span class="line">当前变量值 : 1</span><br><span class="line">当前变量值 : 0</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p>
<p>如下实例用于查询质数的循环例子:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">for n in range(2, 10):</span><br><span class="line">    for x in range(2, n):</span><br><span class="line">        if n % x == 0:</span><br><span class="line">            print(n, &#x27;等于&#x27;, x, &#x27;*&#x27;, n//x)</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        # 循环中没有找到元素</span><br><span class="line">        print(n, &#x27; 是质数&#x27;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  是质数</span><br><span class="line">3  是质数</span><br><span class="line">4 等于 2 * 2</span><br><span class="line">5  是质数</span><br><span class="line">6 等于 2 * 3</span><br><span class="line">7  是质数</span><br><span class="line">8 等于 2 * 4</span><br><span class="line">9 等于 3 * 3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;while True:</span><br><span class="line">...     pass  # 等待键盘中断 (Ctrl+C)</span><br></pre></td></tr></table></figure>

<p>最小的类:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;class MyEmptyClass:</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure>

<p>以下实例在字母为 o 时 执行 pass 语句块:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">for letter in &#x27;Runoob&#x27;: </span><br><span class="line">   if letter == &#x27;o&#x27;:</span><br><span class="line">      pass</span><br><span class="line">      print (&#x27;执行 pass 块&#x27;)</span><br><span class="line">   print (&#x27;当前字母 :&#x27;, letter)</span><br><span class="line"> </span><br><span class="line">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上脚本输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : b</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Python3数据类型转换</title>
    <url>/2023/06/03/Python3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-数据类型转换"><a href="#Python3-数据类型转换" class="headerlink" title="Python3 数据类型转换"></a>Python3 数据类型转换</h1><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，一般情况下你只需要将数据类型作为函数名即可。</p>
<p>Python 数据类型转换可以分为两种：</p>
<ul>
<li>隐式类型转换 - 自动完成</li>
<li>显式类型转换 - 需要使用类型函数来转换</li>
</ul>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>在隐式类型转换中，Python 会自动将一种数据类型转换为另一种数据类型，不需要我们去干预。</p>
<p>以下实例中，我们对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int = 123</span><br><span class="line">num_flo = 1.23</span><br><span class="line"></span><br><span class="line">num_new = num_int + num_flo</span><br><span class="line"></span><br><span class="line">print(&quot;datatype of num_int:&quot;,type(num_int))</span><br><span class="line">print(&quot;datatype of num_flo:&quot;,type(num_flo))</span><br><span class="line"></span><br><span class="line">print(&quot;Value of num_new:&quot;,num_new)</span><br><span class="line">print(&quot;datatype of num_new:&quot;,type(num_new))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">num_flo 数据类型为: &lt;class &#x27;float&#x27;&gt;</span><br><span class="line">num_new: 值为: 124.23</span><br><span class="line">num_new 数据类型为: &lt;class &#x27;float&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li>实例中我们对两个不同数据类型的变量 <code>num_int</code> 和 <code>num_flo</code> 进行相加运算，并存储在变量 <code>num_new</code> 中。</li>
<li>然后查看三个变量的数据类型。</li>
<li>在输出结果中，我们看到 <code>num_int</code> 是 <code>整型（integer）</code> ， <code>num_flo</code> 是 <code>浮点型（float）</code>。</li>
<li>同样，新的变量 <code>num_new</code> 是 <code>浮点型（float）</code>，这是因为 Python 会将较小的数据类型转换为较大的数据类型，以避免数据丢失。</li>
</ul>
<p>我们再看一个实例，整型数据与字符串类型的数据进行相加：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int = 123</span><br><span class="line">num_str = &quot;456&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;Data type of num_int:&quot;,type(num_int))</span><br><span class="line">print(&quot;Data type of num_str:&quot;,type(num_str))</span><br><span class="line"></span><br><span class="line">print(num_int+num_str)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">num_str 数据类型为: &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/runoob-test/test.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(num_int+num_str)</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，整型和字符串类型运算结果会报错，输出 TypeError。 Python 在这种情况下无法使用隐式转换。</p>
<p>但是，Python 为这些类型的情况提供了一种解决方案，称为显式转换。</p>
<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p>在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。</p>
<p><strong>int()</strong> 强制转换为整型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = int(1)   # x 输出结果为 1</span><br><span class="line">y = int(2.8) # y 输出结果为 2</span><br><span class="line">z = int(&quot;3&quot;) # z 输出结果为 3</span><br></pre></td></tr></table></figure>

<p><strong>float()</strong> 强制转换为浮点型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = float(1)     # x 输出结果为 1.0</span><br><span class="line">y = float(2.8)   # y 输出结果为 2.8</span><br><span class="line">z = float(&quot;3&quot;)   # z 输出结果为 3.0</span><br><span class="line">w = float(&quot;4.2&quot;) # w 输出结果为 4.2</span><br></pre></td></tr></table></figure>

<p><strong>str()</strong> 强制转换为字符串类型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = str(&quot;s1&quot;) # x 输出结果为 &#x27;s1&#x27;</span><br><span class="line">y = str(2)    # y 输出结果为 &#x27;2&#x27;</span><br><span class="line">z = str(3.0)  # z 输出结果为 &#x27;3.0&#x27;</span><br></pre></td></tr></table></figure>

<p>整型和字符串类型进行运算，就可以用强制类型转换来完成：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int = 123</span><br><span class="line">num_str = &quot;456&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;num_int 数据类型为:&quot;,type(num_int))</span><br><span class="line">print(&quot;类型转换前，num_str 数据类型为:&quot;,type(num_str))</span><br><span class="line"></span><br><span class="line">num_str = int(num_str)    # 强制转换为整型</span><br><span class="line">print(&quot;类型转换后，num_str 数据类型为:&quot;,type(num_str))</span><br><span class="line"></span><br><span class="line">num_sum = num_int + num_str</span><br><span class="line"></span><br><span class="line">print(&quot;num_int 与 num_str 相加结果为:&quot;,num_sum)</span><br><span class="line">print(&quot;sum 数据类型为:&quot;,type(num_sum))</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_int 数据类型为: &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">类型转换前，num_str 数据类型为: &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">类型转换后，num_str 数据类型为: &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">num_int 与 num_str 相加结果为: 579</span><br><span class="line">sum 数据类型为: &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td>
<td align="left">将x转换为一个整数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td>
<td align="left">将x转换到一个浮点数</td>
</tr>
<tr>
<td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td>
<td align="left">创建一个复数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td>
<td align="left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td>
<td align="left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td>
<td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td>
<td align="left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td>
<td align="left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td>
<td align="left">转换为可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td>
<td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td>
<td align="left">转换为不可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td>
<td align="left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td>
<td align="left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td>
<td align="left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td>
<td align="left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Lua笔记</title>
    <url>/2023/08/06/Lua%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Lua笔记"><a href="#Lua笔记" class="headerlink" title="Lua笔记"></a>Lua笔记</h1><h2 id="第一个-Lua-程序"><a href="#第一个-Lua-程序" class="headerlink" title="第一个 Lua 程序"></a>第一个 Lua 程序</h2><span id="more"></span>

<h3 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h3><p>Lua 提供了交互式编程模式。我们可以在命令行中输入程序并立即查看效果。</p>
<p>Lua 交互式编程模式可以通过命令 lua -i 或 lua 来启用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua -i </span><br><span class="line">$ Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>在命令行中，输入以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(&quot;Hello World！&quot;)</span><br></pre></td></tr></table></figure>

<p>接着我们按下回车键，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(&quot;Hello World！&quot;)</span><br><span class="line">Hello World！</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><p>我们可以将 Lua 程序代码保存到一个以 lua 结尾的文件，并执行，该模式称为脚本式编程，如我们将如下代码存储在名为 hello.lua 的脚本文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello World！&quot;)</span><br><span class="line">print(&quot;www.runoob.com&quot;)</span><br></pre></td></tr></table></figure>

<p>使用 lua 名执行以上脚本，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua hello.lua</span><br><span class="line">Hello World！</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<p>我们也可以将代码修改为如下形式来执行脚本（在开头添加：#!&#x2F;usr&#x2F;local&#x2F;bin&#x2F;lua）：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/**local**/bin/lua</span><br><span class="line"></span><br><span class="line">print(&quot;Hello World！&quot;)</span><br><span class="line">print(&quot;www.runoob.com&quot;)</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们指定了 Lua 的解释器 &#x2F;usr&#x2F;local&#x2F;bin directory。加上 # 号标记解释器会忽略它。接下来我们为脚本添加可执行权限，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hello.lua </span><br><span class="line">Hello World！</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>两个减号是单行注释:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--</span><br></pre></td></tr></table></figure>

<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--[[</span><br><span class="line"> 多行注释</span><br><span class="line"> 多行注释</span><br><span class="line"> --]]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="标示符"><a href="#标示符" class="headerlink" title="标示符"></a>标示符</h2><p>Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 <strong>_</strong> 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。</p>
<p>最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。</p>
<p>Lua 不允许使用特殊字符如 <strong>@</strong>, <strong>$</strong>, 和 <strong>%</strong> 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Runoob 与 runoob 是两个不同的标示符。以下列出了一些正确的标示符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mohd         zara      abc     move_name    a_123</span><br><span class="line">myname50     _temp     j       a23b9        retVal</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>以下列出了 Lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符：</p>
<table>
<thead>
<tr>
<th>and</th>
<th>break</th>
<th>do</th>
<th>else</th>
</tr>
</thead>
<tbody><tr>
<td>elseif</td>
<td>end</td>
<td>false</td>
<td>for</td>
</tr>
<tr>
<td>function</td>
<td>if</td>
<td>in</td>
<td>local</td>
</tr>
<tr>
<td>nil</td>
<td>not</td>
<td>or</td>
<td>repeat</td>
</tr>
<tr>
<td>return</td>
<td>then</td>
<td>true</td>
<td>until</td>
</tr>
<tr>
<td>while</td>
<td>goto</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。</p>
<hr>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在默认情况下，变量总是认为是全局的。</p>
<p>全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(b)</span><br><span class="line">nil</span><br><span class="line">&gt; b=10</span><br><span class="line">&gt; print(b)</span><br><span class="line">10</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>如果你想删除一个全局变量，只需要将变量赋值为nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = nil</span><br><span class="line">print(b)      --&gt; nil</span><br></pre></td></tr></table></figure>

<p>这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于nil时，这个变量即存在。</p>
<hr>
<h1 id="Lua-数据类型"><a href="#Lua-数据类型" class="headerlink" title="Lua 数据类型"></a>Lua 数据类型</h1><p>Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p>
<p>Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">nil</td>
<td align="left">这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">包含两个值：false和true。</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">表示双精度类型的实浮点数</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">字符串由一对双引号或单引号来表示</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">由 C 或 Lua 编写的函数</td>
</tr>
<tr>
<td align="left">userdata</td>
<td align="left">表示任意存储在变量中的C数据结构</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示执行的独立线路，用于执行协同程序</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td>
</tr>
</tbody></table>
<p>我们可以使用 type 函数测试给定变量或者值的类型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(type(&quot;Hello world&quot;))    *--&gt; string*</span><br><span class="line">print(type(10.4*3))       *--&gt; number*</span><br><span class="line">print(type(print))        *--&gt; function*</span><br><span class="line">print(type(type))        *--&gt; function*</span><br><span class="line">print(type(true))        *--&gt; boolean*</span><br><span class="line">print(type(nil))         *--&gt; nil*</span><br><span class="line">print(type(type(X)))       *--&gt; string*</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="nil（空）"><a href="#nil（空）" class="headerlink" title="nil（空）"></a>nil（空）</h2><p>nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(type(a))</span><br><span class="line">nil</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tab1 = &#123; key1 = &quot;val1&quot;, key2 = &quot;val2&quot;, &quot;val3&quot; &#125;</span><br><span class="line">for k, v in pairs(tab1) do</span><br><span class="line">    print(k .. &quot; - &quot; .. v)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">tab1.key1 = nil</span><br><span class="line">for k, v in pairs(tab1) do</span><br><span class="line">    print(k .. &quot; - &quot; .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>nil 作比较时应该加上双引号 <code>&quot;</code>：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; type(X)</span><br><span class="line">nil</span><br><span class="line">&gt; type(X)==nil</span><br><span class="line">false</span><br><span class="line">&gt; type(X)==&quot;nil&quot;</span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p><strong>type(X)&#x3D;&#x3D;nil</strong> 结果为 <strong>false</strong> 的原因是 type(X) 实质是返回的 <strong>“nil”</strong> 字符串，是一个 string 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type(type(X))==string</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="boolean（布尔）"><a href="#boolean（布尔）" class="headerlink" title="boolean（布尔）"></a>boolean（布尔）</h2><p>boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(type(true))</span><br><span class="line">print(type(false))</span><br><span class="line">print(type(nil))</span><br><span class="line"> </span><br><span class="line">if false or nil then</span><br><span class="line">    print(&quot;至少有一个是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;false 和 nil 都为 false&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if 0 then</span><br><span class="line">    print(&quot;数字 0 是 true&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;数字 0 为 false&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua test.lua </span><br><span class="line">boolean</span><br><span class="line">boolean</span><br><span class="line">nil</span><br><span class="line">false 和 nil 都为 false</span><br><span class="line">数字 0 是 true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="number（数字）"><a href="#number（数字）" class="headerlink" title="number（数字）"></a>number（数字）</h2><p>Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(type(2))</span><br><span class="line">print(type(2.2))</span><br><span class="line">print(type(0.2))</span><br><span class="line">print(type(2e+1))</span><br><span class="line">print(type(0.2e-1))</span><br><span class="line">print(type(7.8263692594256e-06))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>字符串由一对双引号或单引号来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string1 = &quot;this is string1&quot;</span><br><span class="line">string2 = &#x27;this is string2&#x27;</span><br></pre></td></tr></table></figure>

<p>也可以用 2 个方括号 “[[]]” 来表示”一块”字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html = [[</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">]]</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure>

<p>以下代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;http://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(&quot;2&quot; + 6)</span><br><span class="line">8.0</span><br><span class="line">&gt; print(&quot;2&quot; + &quot;6&quot;)</span><br><span class="line">8.0</span><br><span class="line">&gt; print(&quot;2 + 6&quot;)</span><br><span class="line">2 + 6</span><br><span class="line">&gt; print(&quot;-2e2&quot; * &quot;6&quot;)</span><br><span class="line">-1200.0</span><br><span class="line">&gt; print(&quot;error&quot; + 1)</span><br><span class="line">stdin:1: attempt to perform arithmetic on a string value</span><br><span class="line">stack traceback:</span><br><span class="line">        stdin:1: in main chunk</span><br><span class="line">        [C]: in ?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码中”error” + 1执行报错了，字符串连接使用的是 .. ，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(&quot;a&quot; .. &#x27;b&#x27;)</span><br><span class="line">ab</span><br><span class="line">&gt; print(157 .. 428)</span><br><span class="line">157428</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>

<p>使用 # 来计算字符串的长度，放在字符串前面，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; len = &quot;www.runoob.com&quot;</span><br><span class="line">&gt; print(#len)</span><br><span class="line">14</span><br><span class="line">&gt; print(#&quot;www.runoob.com&quot;)</span><br><span class="line">14</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="table（表）"><a href="#table（表）" class="headerlink" title="table（表）"></a>table（表）</h2><p>在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个空的 table</span><br><span class="line">local tbl1 = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 直接初始表</span><br><span class="line">local tbl2 = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- table_test.lua 脚本文件</span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a[&quot;key&quot;] = &quot;value&quot;</span><br><span class="line">key = 10</span><br><span class="line">a[key] = 22</span><br><span class="line">a[key] = a[key] + 11</span><br><span class="line">for k, v in pairs(a) do</span><br><span class="line">    print(k .. &quot; : &quot; .. v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua table_test.lua </span><br><span class="line">key : value</span><br><span class="line">10 : 33</span><br></pre></td></tr></table></figure>

<p>不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- table_test2.lua 脚本文件</span><br><span class="line">local tbl = &#123;&quot;apple&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;grape&quot;&#125;</span><br><span class="line">for key, val in pairs(tbl) do</span><br><span class="line">    print(&quot;Key&quot;, key)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua table_test2.lua </span><br><span class="line">Key    1</span><br><span class="line">Key    2</span><br><span class="line">Key    3</span><br><span class="line">Key    4</span><br></pre></td></tr></table></figure>

<p>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- table_test3.lua 脚本文件</span><br><span class="line">a3 = &#123;&#125;</span><br><span class="line">for i = 1, 10 do</span><br><span class="line">    a3[i] = i</span><br><span class="line">end</span><br><span class="line">a3[&quot;key&quot;] = &quot;val&quot;</span><br><span class="line">print(a3[&quot;key&quot;])</span><br><span class="line">print(a3[&quot;none&quot;])</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua table_test3.lua </span><br><span class="line">val</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="function（函数）"><a href="#function（函数）" class="headerlink" title="function（函数）"></a>function（函数）</h2><p>在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，函数可以存在变量里:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- function_test.lua 脚本文件</span><br><span class="line">function factorial1(n)</span><br><span class="line">    if n == 0 then</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        return n * factorial1(n - 1)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">print(factorial1(5))</span><br><span class="line">factorial2 = factorial1</span><br><span class="line">print(factorial2(5))</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua function_test.lua </span><br><span class="line">120</span><br><span class="line">120</span><br></pre></td></tr></table></figure>

<p>function 可以以匿名函数（anonymous function）的方式通过参数传递:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- function_test2.lua 脚本文件</span><br><span class="line">function testFun(tab,fun)</span><br><span class="line">        for k ,v in pairs(tab) do</span><br><span class="line">                print(fun(k,v));</span><br><span class="line">        end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab=&#123;key1=&quot;val1&quot;,key2=&quot;val2&quot;&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line">function(key,val)--匿名函数</span><br><span class="line">        return key..&quot;=&quot;..val;</span><br><span class="line">end</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>脚本执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua function_test2.lua </span><br><span class="line">key1=val1</span><br><span class="line">key2=val2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="thread（线程）"><a href="#thread（线程）" class="headerlink" title="thread（线程）"></a>thread（线程）</h2><p>在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p>
<p>线程跟协程的区别：线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。</p>
<hr>
<h2 id="userdata（自定义类型）"><a href="#userdata（自定义类型）" class="headerlink" title="userdata（自定义类型）"></a>userdata（自定义类型）</h2><p>userdata 是一种用户自定义数据，用于表示一种由应用程序或 C&#x2F;C++ 语言库所创建的类型，可以将任意 C&#x2F;C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p>
<hr>
<h1 id="Lua-变量"><a href="#Lua-变量" class="headerlink" title="Lua 变量"></a>Lua 变量</h1><p>变量在使用前，需要在代码中进行声明，即创建该变量。</p>
<p>编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</p>
<p>Lua 变量有三种类型：全局变量、局部变量、表中的域。</p>
<p>Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。</p>
<p>局部变量的作用域为从声明位置开始到所在语句块结束。</p>
<p>变量的默认值均为 nil。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test.lua 文件脚本</span><br><span class="line">a = 5               -- 全局变量</span><br><span class="line">local b = 5         -- 局部变量</span><br><span class="line"></span><br><span class="line">function joke()</span><br><span class="line">    c = 5           -- 全局变量</span><br><span class="line">    local d = 6     -- 局部变量</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line">print(c,d)          --&gt; 5 nil</span><br><span class="line"></span><br><span class="line">do </span><br><span class="line">    local a = 6     -- 局部变量</span><br><span class="line">    b = 6           -- 对局部变量重新赋值</span><br><span class="line">    print(a,b);     --&gt; 6 6</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(a,b)      --&gt; 5 6</span><br></pre></td></tr></table></figure>

<p>执行以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua test.lua </span><br><span class="line">5    nil</span><br><span class="line">6    6</span><br><span class="line">5    6</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2><p>赋值是改变一个变量的值和改变表域的最基本的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;hello&quot; .. &quot;world&quot;</span><br><span class="line">t.n = t.n + 1</span><br></pre></td></tr></table></figure>

<p>Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b = 10, 2*x       &lt;--&gt;       a=10; b=2*x</span><br></pre></td></tr></table></figure>

<p>遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, y = y, x                     -- swap &#x27;x&#x27; for &#x27;y&#x27;</span><br><span class="line">a[i], a[j] = a[j], a[i]         -- swap &#x27;a[i]&#x27; for &#x27;a[j]&#x27;</span><br></pre></td></tr></table></figure>

<p>当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. 变量个数 &gt; 值的个数             按变量个数补足nil</span><br><span class="line">b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b, c = 0, 1</span><br><span class="line">print(a,b,c)             --&gt; 0   1   nil</span><br><span class="line"> </span><br><span class="line">a, b = a+1, b+1, b+2     -- value of b+2 is ignored</span><br><span class="line">print(a,b)               --&gt; 1   2</span><br><span class="line"> </span><br><span class="line">a, b, c = 0</span><br><span class="line">print(a,b,c)             --&gt; 0   nil   nil</span><br></pre></td></tr></table></figure>

<p>上面最后一个例子是一个常见的错误情况，注意：如果要对多个变量赋值必须依次对每个变量赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b, c = 0, 0, 0</span><br><span class="line">print(a,b,c)             --&gt; 0   0   0</span><br></pre></td></tr></table></figure>

<p>多值赋值经常用来交换变量，或将函数调用返回给变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b = f()</span><br></pre></td></tr></table></figure>

<p>f()返回两个值，第一个赋给a，第二个赋给b。</p>
<p>应该尽可能的使用局部变量，有两个好处：</p>
<ul>
<li>避免命名冲突。</li>
<li>访问局部变量的速度比全局变量更快。</li>
</ul>
<hr>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>对 table 的索引使用方括号 []。Lua 也提供了 . 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t.i                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line">gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; site = &#123;&#125;</span><br><span class="line">&gt; site[&quot;key&quot;] = &quot;www.runoob.com&quot;</span><br><span class="line">&gt; print(site[&quot;key&quot;])</span><br><span class="line">www.runoob.com</span><br><span class="line">&gt; print(site.key)</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-循环"><a href="#Lua-循环" class="headerlink" title="Lua 循环"></a>Lua 循环</h1><p>很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。</p>
<p>一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。</p>
<p>循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。</p>
<p>循环语句是由循环体及循环的终止条件两部分组成的。</p>
<p><img src="https://pic.imgdb.cn/item/64cf55111ddac507cc30b63e.jpg"></p>
<p>Lua 语言提供了以下几种循环处理方式：</p>
<table>
<thead>
<tr>
<th align="left">循环类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-while-loop.html">while 循环</a></td>
<td align="left">在条件为 true 时，让程序重复地执行某些语句。执行语句前会先检查条件是否为 true。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-for-loop.html">for 循环</a></td>
<td align="left">重复执行指定语句，重复次数可在 for 语句中控制。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-repeat-until-loop.html">repeat…until</a></td>
<td align="left">重复执行循环，直到 指定的条件为真时为止</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-nested-loops.html">循环嵌套</a></td>
<td align="left">可以在循环内嵌套一个或多个循环语句（while do … end;for … do … end;repeat … until;）</td>
</tr>
</tbody></table>
<hr>
<h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句用于控制程序的流程， 以实现程序的各种结构方式。</p>
<p>Lua 支持以下循环控制语句：</p>
<table>
<thead>
<tr>
<th align="left">控制语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-break-statement.html">break 语句</a></td>
<td align="left">退出当前循环或语句，并开始脚本执行紧接着的语句。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/lua-goto.html">goto 语句</a></td>
<td align="left">将程序的控制点转移到一个标签处。</td>
</tr>
</tbody></table>
<hr>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>在循环体中如果条件永远为 true 循环语句就会永远执行下去，以下以 while 循环为例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while( true )</span><br><span class="line">do</span><br><span class="line">   print(&quot;循环将永远执行下去&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-流程控制"><a href="#Lua-流程控制" class="headerlink" title="Lua 流程控制"></a>Lua 流程控制</h1><p>Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。</p>
<p>以下是典型的流程控制流程图：</p>
<p><img src="https://pic.imgdb.cn/item/64cf555b1ddac507cc318489.jpg"></p>
<p>控制结构的条件表达式结果可以是任何值，Lua认为false和nil为假，true和非nil为真。</p>
<p>要注意的是Lua中 0 为 true：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--[ 0 为 true ]</span><br><span class="line">if(0)</span><br><span class="line">then</span><br><span class="line">    print(&quot;0 为 true&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 为 true</span><br></pre></td></tr></table></figure>

<p>Lua 提供了以下控制结构语句：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/lua/if-statement-in-lua.html">if 语句</a></td>
<td align="left"><strong>if 语句</strong> 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/if-else-statement-in-lua.html">if…else 语句</a></td>
<td align="left"><strong>if 语句</strong> 可以与 <strong>else 语句</strong>搭配使用, 在 if 条件表达式为 false 时执行 else 语句代码。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/lua/nested-if-statements-in-lua.html">if 嵌套语句</a></td>
<td align="left">你可以在<strong>if</strong> 或 <strong>else if</strong>中使用一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句 。</td>
</tr>
</tbody></table>
<hr>
<h1 id="Lua-函数"><a href="#Lua-函数" class="headerlink" title="Lua 函数"></a>Lua 函数</h1><p>在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。</p>
<p>Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。</p>
<p>Lua 函数主要有两种用途：</p>
<ul>
<li>完成指定的任务，这种情况下函数作为调用语句使用；</li>
<li>计算并返回值，这种情况下函数作为赋值语句的表达式使用。</li>
</ul>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>Lua 编程语言函数定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)</span><br><span class="line">    function_body</span><br><span class="line">    return result_params_comma_separated</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li><strong>optional_function_scope:</strong> 该参数是可选的指定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 <strong>local</strong>。</li>
<li><strong>function_name:</strong> 指定函数名称。</li>
<li><strong>argument1, argument2, argument3…, argumentn:</strong> 函数参数，多个参数以逗号隔开，函数也可以不带参数。</li>
<li><strong>function_body:</strong> 函数体，函数中需要执行的代码语句块。</li>
<li><strong>result_params_comma_separated:</strong> 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。</li>
</ul>
<p>以下实例定义了函数 **max()**，参数为 num1, num2，用于比较两值的大小，并返回最大值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--[[ 函数返回两个值的最大值 --]]</span><br><span class="line">function max(num1, num2)</span><br><span class="line"></span><br><span class="line">   if (num1 &gt; num2) then</span><br><span class="line">      result = num1;</span><br><span class="line">   else</span><br><span class="line">      result = num2;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   return result; </span><br><span class="line">end</span><br><span class="line">-- 调用函数</span><br><span class="line">print(&quot;两值比较最大值为 &quot;,max(10,4))</span><br><span class="line">print(&quot;两值比较最大值为 &quot;,max(5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两值比较最大值为     10</span><br><span class="line">两值比较最大值为     6</span><br></pre></td></tr></table></figure>

<p>Lua 中我们可以将函数作为参数传递给函数，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myprint = function(param)</span><br><span class="line">   print(&quot;这是打印函数 -   ##&quot;,param,&quot;##&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function add(num1,num2,functionPrint)</span><br><span class="line">   result = num1 + num2</span><br><span class="line">   -- 调用传递的函数参数</span><br><span class="line">   functionPrint(result)</span><br><span class="line">end</span><br><span class="line">myprint(10)</span><br><span class="line">-- myprint 函数作为参数传递</span><br><span class="line">add(2,5,myprint)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是打印函数 -   ##    10    ##</span><br><span class="line">这是打印函数 -   ##    7    ##</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Lua函数可以返回多个结果值，比如string.find，其返回匹配串”开始和结束的下标”（如果不存在匹配串返回nil）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; s, e = string.find(&quot;www.runoob.com&quot;, &quot;runoob&quot;) </span><br><span class="line">&gt; print(s, e)</span><br><span class="line">5    10</span><br></pre></td></tr></table></figure>

<p>Lua函数中，在return后列出要返回的值的列表即可返回多值，如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function maximum (a)</span><br><span class="line">    local mi = 1             -- 最大值索引</span><br><span class="line">    local m = a[mi]          -- 最大值</span><br><span class="line">    for i,val in ipairs(a) do</span><br><span class="line">       if val &gt; m then</span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line">    return m, mi</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(maximum(&#123;8,10,23,12,5&#125;))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">23    3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 <strong>…</strong> 表示函数有可变的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(...)  </span><br><span class="line">local s = 0  </span><br><span class="line">  for i, v in ipairs&#123;...&#125; do   --&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span><br><span class="line">    s = s + v  </span><br><span class="line">  end  </span><br><span class="line">  return s  </span><br><span class="line">end  </span><br><span class="line">print(add(3,4,5,6,7))  ---&gt;25</span><br></pre></td></tr></table></figure>

<p>我们可以将可变参数赋值给一个变量。</p>
<p>例如，我们计算几个数的平均值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   result = 0</span><br><span class="line">   local arg=&#123;...&#125;    --&gt; arg 为一个表，局部变量</span><br><span class="line">   for i,v in ipairs(arg) do</span><br><span class="line">      result = result + v</span><br><span class="line">   end</span><br><span class="line">   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)</span><br><span class="line">   return result/#arg</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;平均值为&quot;,average(10,5,3,4,5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总共传入 6 个数</span><br><span class="line">平均值为    5.5</span><br></pre></td></tr></table></figure>

<p>我们也可以通过 select(“#”,…) 来获取可变参数的数量:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function average(...)</span><br><span class="line">   result = 0</span><br><span class="line">   local arg=&#123;...&#125;</span><br><span class="line">   for i,v in ipairs(arg) do</span><br><span class="line">      result = result + v</span><br><span class="line">   end</span><br><span class="line">   print(&quot;总共传入 &quot; .. select(&quot;#&quot;,...) .. &quot; 个数&quot;)</span><br><span class="line">   return result/select(&quot;#&quot;,...)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;平均值为&quot;,average(10,5,3,4,5,6))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总共传入 6 个数</span><br><span class="line">平均值为    5.5</span><br></pre></td></tr></table></figure>

<p>有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fwrite(fmt, ...)  ---&gt; 固定的参数fmt</span><br><span class="line">    return io.write(string.format(fmt, ...))     </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fwrite(&quot;runoob\n&quot;)       ---&gt;fmt = &quot;runoob&quot;, 没有变长参数。  </span><br><span class="line">fwrite(&quot;%d%d\n&quot;, 1, 2)   ---&gt;fmt = &quot;%d%d&quot;, 变长参数为 1 和 2</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>通常在遍历变长参数的时候只需要使用 <strong>{…}<strong>，然而变长参数可能会包含一些 <strong>nil</strong>，那么就可以用 <strong>select</strong> 函数来访问变长参数了：</strong>select(‘#’, …)</strong> 或者 <strong>select(n, …)</strong></p>
<ul>
<li><strong>select(‘#’, …)</strong> 返回可变参数的长度。</li>
<li><strong>select(n, …)</strong> 用于返回从起点 <strong>n</strong> 开始到结束位置的所有参数列表。</li>
</ul>
<p>调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 <strong>n</strong> 开始到结束位置的所有参数列表，否则只能为字符串 **#**，这样 select 返回变长参数的总数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f(...)</span><br><span class="line">    a = select(3,...)  --&gt;从第三个位置开始，变量 a 对应右边变量列表的第一个参数</span><br><span class="line">    print (a)</span><br><span class="line">    print (select(3,...)) --&gt;打印所有列表参数</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">f(0,1,2,3,4,5)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2       3       4       5</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do  </span><br><span class="line">    function foo(...)  </span><br><span class="line">        for i = 1, select(&#x27;#&#x27;, ...) do  --&gt;获取参数总数</span><br><span class="line">            local arg = select(i, ...); --&gt;读取参数，arg 对应的是右边变量列表的第一个参数</span><br><span class="line">            print(&quot;arg&quot;, arg);  </span><br><span class="line">        end  </span><br><span class="line">    end  </span><br><span class="line">  </span><br><span class="line">    foo(1, 2, 3, 4);  </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg    1</span><br><span class="line">arg    2</span><br><span class="line">arg    3</span><br><span class="line">arg    4</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-运算符"><a href="#Lua-运算符" class="headerlink" title="Lua 运算符"></a>Lua 运算符</h1><p>运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>其他运算符</li>
</ul>
<hr>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了 Lua 语言中的常用算术运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left">A + B 输出结果 30</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left">A - B 输出结果 -10</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left">A * B 输出结果 200</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除法</td>
<td align="left">B &#x2F; A 输出结果 2</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left">B % A 输出结果 0</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">乘幂</td>
<td align="left">A^2 输出结果 100</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">负号</td>
<td align="left">-A 输出结果 -10</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;</td>
<td align="left">整除运算符(&gt;&#x3D;lua5.3)</td>
<td align="left"><strong>5&#x2F;&#x2F;2</strong> 输出结果 2</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解算术运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line">c = a + b</span><br><span class="line">print(&quot;Line 1 - c 的值为 &quot;, c )</span><br><span class="line">c = a - b</span><br><span class="line">print(&quot;Line 2 - c 的值为 &quot;, c )</span><br><span class="line">c = a * b</span><br><span class="line">print(&quot;Line 3 - c 的值为 &quot;, c )</span><br><span class="line">c = a / b</span><br><span class="line">print(&quot;Line 4 - c 的值为 &quot;, c )</span><br><span class="line">c = a % b</span><br><span class="line">print(&quot;Line 5 - c 的值为 &quot;, c )</span><br><span class="line">c = a^2</span><br><span class="line">print(&quot;Line 6 - c 的值为 &quot;, c )</span><br><span class="line">c = -a</span><br><span class="line">print(&quot;Line 7 - c 的值为 &quot;, c )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Line 1 - c 的值为     31</span><br><span class="line">Line 2 - c 的值为     11</span><br><span class="line">Line 3 - c 的值为     210</span><br><span class="line">Line 4 - c 的值为     2.1</span><br><span class="line">Line 5 - c 的值为     1</span><br><span class="line">Line 6 - c 的值为     441</span><br><span class="line">Line 7 - c 的值为     -21</span><br></pre></td></tr></table></figure>

<p>在 lua 中，**&#x2F;** 用作除法运算，计算结果包含小数部分，**&#x2F;&#x2F;** 用作整除运算，计算结果不包含小数部分：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 2</span><br><span class="line"></span><br><span class="line">print(&quot;除法运算 - a/b 的值为 &quot;, a / b )</span><br><span class="line">print(&quot;整除运算 - a//b 的值为 &quot;, a // b )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除法运算 - a/b 的值为   2.5</span><br><span class="line">整除运算 - a//b 的值为  2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">等于，检测两个值是否相等，相等返回 true，否则返回 false</td>
<td align="left">(A &#x3D;&#x3D; B) 为 false。</td>
</tr>
<tr>
<td align="left">~&#x3D;</td>
<td align="left">不等于，检测两个值是否相等，不相等返回 true，否则返回 false</td>
<td align="left">(A ~&#x3D; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于，如果左边的值大于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt; B) 为 false。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于，如果左边的值大于右边的值，返回 false，否则返回 true</td>
<td align="left">(A &lt; B) 为 true。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &gt;&#x3D; B) 返回 false。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td>
<td align="left">(A &lt;&#x3D; B) 返回 true。</td>
</tr>
</tbody></table>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解关系运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line">if( a == b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 1 - a 等于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 1 - a 不等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if( a ~= b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 2 - a 不等于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 2 - a 等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a &lt; b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 3 - a 小于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 3 - a 大于等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a &gt; b ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 4 - a 大于 b&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;Line 5 - a 小于等于 b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 修改 a 和 b 的值</span><br><span class="line">a = 5</span><br><span class="line">b = 20</span><br><span class="line">if ( a &lt;= b ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 5 - a 小于等于  b&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( b &gt;= a ) </span><br><span class="line">then</span><br><span class="line">   print(&quot;Line 6 - b 大于等于 a&quot; )</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Line 1 - a 不等于 b</span><br><span class="line">Line 2 - a 不等于 b</span><br><span class="line">Line 3 - a 大于等于 b</span><br><span class="line">Line 4 - a 大于 b</span><br><span class="line">Line 5 - a 小于等于  b</span><br><span class="line">Line 6 - b 大于等于 a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td>
<td align="left">(A and B) 为 false。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。</td>
<td align="left">(A or B) 为 true。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td>
<td align="left">not(A and B) 为 true。</td>
</tr>
</tbody></table>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解逻辑运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = true</span><br><span class="line">b = true</span><br><span class="line"></span><br><span class="line">if ( a and b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a and b - 条件为 true&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( a or b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a or b - 条件为 true&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(&quot;---------分割线---------&quot; )</span><br><span class="line"></span><br><span class="line">-- 修改 a 和 b 的值</span><br><span class="line">a = false</span><br><span class="line">b = true</span><br><span class="line"></span><br><span class="line">if ( a and b )</span><br><span class="line">then</span><br><span class="line">   print(&quot;a and b - 条件为 true&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;a and b - 条件为 false&quot; )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if ( not( a and b) )</span><br><span class="line">then</span><br><span class="line">   print(&quot;not( a and b) - 条件为 true&quot; )</span><br><span class="line">else</span><br><span class="line">   print(&quot;not( a and b) - 条件为 false&quot; )</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a and b - 条件为 true</span><br><span class="line">a or b - 条件为 true</span><br><span class="line">---------分割线---------</span><br><span class="line">a and b - 条件为 false</span><br><span class="line">not( a and b) - 条件为 true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>下表列出了 Lua 语言中的连接运算符与计算表或字符串长度的运算符：</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">..</td>
<td align="left">连接两个字符串</td>
<td align="left">a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。</td>
</tr>
<tr>
<td align="left">#</td>
<td align="left">一元运算符，返回字符串或表的长度。</td>
<td align="left">#”Hello” 返回 5</td>
</tr>
</tbody></table>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的理解连接运算符与计算表或字符串长度的运算符的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;Hello &quot;</span><br><span class="line">b = &quot;World&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;连接字符串 a 和 b &quot;, a..b )</span><br><span class="line"></span><br><span class="line">print(&quot;b 字符串长度 &quot;,#b )</span><br><span class="line"></span><br><span class="line">print(&quot;字符串 Test 长度 &quot;,#&quot;Test&quot; )</span><br><span class="line"></span><br><span class="line">print(&quot;菜鸟教程网址长度 &quot;,#&quot;www.runoob.com&quot; )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接字符串 a 和 b     Hello World</span><br><span class="line">b 字符串长度     5</span><br><span class="line">字符串 Test 长度     4</span><br><span class="line">菜鸟教程网址长度     14</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>从高到低的顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^</span><br><span class="line">not    - (unary)</span><br><span class="line">*      /       %</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line">and</span><br><span class="line">or</span><br></pre></td></tr></table></figure>

<p>除了 <strong>^</strong> 和 <strong>..</strong> 外所有的二元运算符都是左连接的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a+i &lt; b/2+1          &lt;--&gt;       (a+i) &lt; ((b/2)+1)</span><br><span class="line">5+x^2*8              &lt;--&gt;       5+((x^2)*8)</span><br><span class="line">a &lt; y and y &lt;= z     &lt;--&gt;       (a &lt; y) and (y &lt;= z)</span><br><span class="line">-x^2                 &lt;--&gt;       -(x^2)</span><br><span class="line">x^y^z                &lt;--&gt;       x^(y^z)</span><br></pre></td></tr></table></figure>

<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>我们可以通过以下实例来更加透彻的了解 Lua 语言运算符的优先级：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">c = 15</span><br><span class="line">d = 5</span><br><span class="line"></span><br><span class="line">e = (a + b) * c / d;-- ( 30 * 15 ) / 5</span><br><span class="line">print(&quot;(a + b) * c / d 运算值为  :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = ((a + b) * c) / d; -- (30 * 15 ) / 5</span><br><span class="line">print(&quot;((a + b) * c) / d 运算值为 :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = (a + b) * (c / d);-- (30) * (15/5)</span><br><span class="line">print(&quot;(a + b) * (c / d) 运算值为 :&quot;,e )</span><br><span class="line"></span><br><span class="line">e = a + (b * c) / d;  -- 20 + (150/5)</span><br><span class="line">print(&quot;a + (b * c) / d 运算值为   :&quot;,e )</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a + b) * c / d 运算值为  :    90.0</span><br><span class="line">((a + b) * c) / d 运算值为 :    90.0</span><br><span class="line">(a + b) * (c / d) 运算值为 :    90.0</span><br><span class="line">a + (b * c) / d 运算值为   :    50.0</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-字符串"><a href="#Lua-字符串" class="headerlink" title="Lua 字符串"></a>Lua 字符串</h1><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。</p>
<p>在 Lua 中，字符串是一种基本的数据类型，用于存储文本数据。</p>
<p>Lua 中的字符串可以包含任意字符，包括字母、数字、符号、空格以及其他特殊字符。</p>
<p>Lua 语言中字符串可以使用以下三种方式来表示：</p>
<ul>
<li><p>单引号间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local str1 = &#x27;This is a string.&#x27;</span><br><span class="line">local str2 = &quot;This is also a string.&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双引号间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local str = &quot;Hello, &quot;</span><br><span class="line">str = str .. &quot;World!&quot;  -- 创建一个新的字符串并将其赋值给str</span><br><span class="line">print(str)  -- 输出 &quot;Hello, World!&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[[</strong> 与 <strong>]]</strong> 间的一串字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local multilineString = [[</span><br><span class="line">This is a multiline string.</span><br><span class="line">It can contain multiple lines of text.</span><br><span class="line">No need for escape characters.</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line">print(multilineString)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上三种方式的字符串实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;</span><br><span class="line">print(&quot;\&quot;字符串 1 是\&quot;&quot;,string1)</span><br><span class="line">string2 = &#x27;runoob.com&#x27;</span><br><span class="line">print(&quot;字符串 2 是&quot;,string2)</span><br><span class="line"></span><br><span class="line">string3 = [[&quot;Lua 教程&quot;]]</span><br><span class="line">print(&quot;字符串 3 是&quot;,string3)</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;字符串 1 是&quot;    Lua</span><br><span class="line">字符串 2 是    runoob.com</span><br><span class="line">字符串 3 是    &quot;Lua 教程&quot;</span><br></pre></td></tr></table></figure>

<h2 id="字符串长度计算"><a href="#字符串长度计算" class="headerlink" title="字符串长度计算"></a>字符串长度计算</h2><p>在 Lua 中，要计算字符串的长度（即字符串中字符的个数），你可以使用 <strong>string.len</strong>函数或 <strong>utf8.len</strong> 函数，包含中文的一般用 <strong>utf8.len</strong>，<strong>string.len</strong> 函数用于计算只包含 ASCII 字符串的长度。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local myString = &quot;Hello, RUNOOB!&quot;</span><br><span class="line"></span><br><span class="line">-- 计算字符串的长度（字符个数）</span><br><span class="line">local length = string.len(myString)</span><br><span class="line"></span><br><span class="line">print(length) -- 输出 14</span><br></pre></td></tr></table></figure>

<p>以上实例的 myString 字符串只包含 ASCII 字符，因此 <strong>string.len</strong> 函数可以准确地返回字符串的长度。</p>
<p>包含中文的字符串使用 <strong>utf8.len</strong>函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local myString = &quot;Hello, 世界!&quot;</span><br><span class="line"></span><br><span class="line">-- 计算字符串的长度（字符个数）</span><br><span class="line">local length1 = utf8.len(myString)</span><br><span class="line">print(length1) -- 输出 9</span><br><span class="line"></span><br><span class="line">-- string.len 函数会导致结果不准确</span><br><span class="line">local length2 = string.len(myString)</span><br><span class="line">print(length2) -- 输出 14</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">14</span><br></pre></td></tr></table></figure>

<p>转义字符用于表示不能直接显示的字符，比如后退键，回车键等，如在字符串转换双引号可以使用 ****。</p>
<p>所有的转义字符和所对应的意义：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’&#39;</td>
<td>092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td>三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td>二位十六进制</td>
</tr>
</tbody></table>
<hr>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>Lua 提供了很多的方法来支持字符串的操作：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>string.upper(argument):</strong> 字符串全部转为大写字母。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>string.lower(argument):</strong> 字符串全部转为小写字母。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">**string.gsub(mainString,findString,replaceString,num)**在字符串中替换。mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如：<code>&gt; string.gsub(&quot;aaaa&quot;,&quot;a&quot;,&quot;z&quot;,3); zzza  3</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>string.find (str, substr, [init, [plain]])</strong> 在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。<strong>init</strong> 指定了搜索的起始位置，默认为 1，可以一个负数，表示从后往前数的字符个数。<strong>plain</strong> 表示是否使用简单模式，默认为 false，true 只做简单的查找子串的操作，false 表示使用使用正则模式匹配。以下实例查找字符串 “Lua” 的起始索引和结束索引位置：<code>&gt; string.find(&quot;Hello Lua user&quot;, &quot;Lua&quot;, 1)  7  9</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>string.reverse(arg)</strong> 字符串反转<code>&gt; string.reverse(&quot;Lua&quot;) auL</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>string.format(…)</strong> 返回一个类似printf的格式化字符串<code>&gt; string.format(&quot;the value is:%d&quot;,4) the value is:4</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>string.char(arg) 和 string.byte(arg[,int])</strong> char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。<code>&gt; string.char(97,98,99,100) abcd &gt; string.byte(&quot;ABCD&quot;,4) 68 &gt; string.byte(&quot;ABCD&quot;) 65 &gt;</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>string.len(arg)</strong> 计算字符串长度。<code>string.len(&quot;abc&quot;) 3</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>string.rep(string, n)</strong> 返回字符串string的n个拷贝<code>&gt; string.rep(&quot;abcd&quot;,2) abcdabcd</code></td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>..</strong> 链接两个字符串<code>&gt; print(&quot;www.runoob.&quot;..&quot;com&quot;) www.runoob.com</code></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>string.gmatch(str, pattern)</strong> 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。<code>&gt; for word in string.gmatch(&quot;Hello Lua user&quot;, &quot;%a+&quot;) do print(word) end Hello Lua user</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>string.match(str, pattern, init)</strong> string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。<code>&gt; = string.match(&quot;I have 2 questions for you.&quot;, &quot;%d+ %a+&quot;) 2 questions &gt; = string.format(&quot;%d, %q&quot;, string.match(&quot;I have 2 questions for you.&quot;, &quot;(%d+) (%a+)&quot;)) 2, &quot;questions&quot;</code></td>
</tr>
</tbody></table>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>字符串截取使用 sub() 方法。</p>
<p>string.sub() 用于截取字符串，原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string.sub(s, i [, j])</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>s：要截取的字符串。</li>
<li>i：截取开始位置。</li>
<li>j：截取结束位置，默认为 -1，最后一个字符。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 字符串</span><br><span class="line">local sourcestr = &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br><span class="line">print(&quot;\n原始字符串&quot;, string.format(&quot;%q&quot;, sourcestr))</span><br><span class="line"></span><br><span class="line">-- 截取部分，第4个到第15个</span><br><span class="line">local first_sub = string.sub(sourcestr, 4, 15)</span><br><span class="line">print(&quot;\n第一次截取&quot;, string.format(&quot;%q&quot;, first_sub))</span><br><span class="line"></span><br><span class="line">-- 取字符串前缀，第1个到第8个</span><br><span class="line">local second_sub = string.sub(sourcestr, 1, 8)</span><br><span class="line">print(&quot;\n第二次截取&quot;, string.format(&quot;%q&quot;, second_sub))</span><br><span class="line"></span><br><span class="line">-- 截取最后10个</span><br><span class="line">local third_sub = string.sub(sourcestr, -10)</span><br><span class="line">print(&quot;\n第三次截取&quot;, string.format(&quot;%q&quot;, third_sub))</span><br><span class="line"></span><br><span class="line">-- 索引越界，输出原始字符串</span><br><span class="line">local fourth_sub = string.sub(sourcestr, -100)</span><br><span class="line">print(&quot;\n第四次截取&quot;, string.format(&quot;%q&quot;, fourth_sub))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始字符串    &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br><span class="line"></span><br><span class="line">第一次截取    &quot;fix--runoobg&quot;</span><br><span class="line"></span><br><span class="line">第二次截取    &quot;prefix--&quot;</span><br><span class="line"></span><br><span class="line">第三次截取    &quot;ao--suffix&quot;</span><br><span class="line"></span><br><span class="line">第四次截取    &quot;prefix--runoobgoogletaobao--suffix&quot;</span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><p>以下实例演示了如何对字符串大小写进行转换：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;;</span><br><span class="line">print(string.upper(string1))</span><br><span class="line">print(string.lower(string1))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LUA</span><br><span class="line">lua</span><br></pre></td></tr></table></figure>

<h3 id="字符串查找与反转"><a href="#字符串查找与反转" class="headerlink" title="字符串查找与反转"></a>字符串查找与反转</h3><p>以下实例演示了如何对字符串进行查找与反转操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string = &quot;Lua Tutorial&quot;</span><br><span class="line">-- 查找字符串</span><br><span class="line">print(string.find(string,&quot;Tutorial&quot;))</span><br><span class="line">reversedString = string.reverse(string)</span><br><span class="line">print(&quot;新字符串为&quot;,reversedString)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5    12</span><br><span class="line">新字符串为    lairotuT auL</span><br></pre></td></tr></table></figure>

<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Lua 提供了 <strong>string.format()</strong> 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。</p>
<p>由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。</p>
<p>以下实例演示了如何对字符串进行格式化操作：</p>
<p>格式字符串可能包含以下的转义码:</p>
<ul>
<li>%c - 接受一个数字, 并将其转化为ASCII码表中对应的字符</li>
<li>%d, %i - 接受一个数字并将其转化为有符号的整数格式</li>
<li>%o - 接受一个数字并将其转化为八进制数格式</li>
<li>%u - 接受一个数字并将其转化为无符号整数格式</li>
<li>%x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母</li>
<li>%X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母</li>
<li>%e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e</li>
<li>%E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E</li>
<li>%f - 接受一个数字并将其转化为浮点数格式</li>
<li>%g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式</li>
<li>%q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式</li>
<li>%s - 接受一个字符串并按照给定的参数格式化该字符串</li>
</ul>
<p>为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入:</p>
<ul>
<li>(1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号.</li>
<li>(2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格.</li>
<li>(3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐.</li>
<li>(4) 宽度数值</li>
<li>(5) 小数位数&#x2F;字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位.</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string1 = &quot;Lua&quot;</span><br><span class="line">string2 = &quot;Tutorial&quot;</span><br><span class="line">number1 = 10</span><br><span class="line">number2 = 20</span><br><span class="line">-- 基本字符串格式化</span><br><span class="line">print(string.format(&quot;基本格式化 %s %s&quot;,string1,string2))</span><br><span class="line">-- 日期格式化</span><br><span class="line">date = 2; month = 1; year = 2014</span><br><span class="line">print(string.format(&quot;日期格式化 %02d/%02d/%03d&quot;, date, month, year))</span><br><span class="line">-- 十进制格式化</span><br><span class="line">print(string.format(&quot;%.4f&quot;,1/3))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本格式化 Lua Tutorial</span><br><span class="line">日期格式化 02/01/2014</span><br><span class="line">0.3333</span><br></pre></td></tr></table></figure>

<p>其他例子：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string.format(&quot;%c&quot;, 83)                 -- 输出S</span><br><span class="line">string.format(&quot;%+d&quot;, 17.0)              -- 输出+17</span><br><span class="line">string.format(&quot;%05d&quot;, 17)               -- 输出00017</span><br><span class="line">string.format(&quot;%o&quot;, 17)                 -- 输出21</span><br><span class="line">string.format(&quot;%u&quot;, 3.14)               -- 输出3</span><br><span class="line">string.format(&quot;%x&quot;, 13)                 -- 输出d</span><br><span class="line">string.format(&quot;%X&quot;, 13)                 -- 输出D</span><br><span class="line">string.format(&quot;%e&quot;, 1000)               -- 输出1.000000e+03</span><br><span class="line">string.format(&quot;%E&quot;, 1000)               -- 输出1.000000E+03</span><br><span class="line">string.format(&quot;%6.3f&quot;, 13)              -- 输出13.000</span><br><span class="line">string.format(&quot;%q&quot;, &quot;One\nTwo&quot;)         -- 输出&quot;One\</span><br><span class="line">                                        -- 　　Two&quot;</span><br><span class="line">string.format(&quot;%s&quot;, &quot;monkey&quot;)           -- 输出monkey</span><br><span class="line">string.format(&quot;%10s&quot;, &quot;monkey&quot;)         -- 输出    monkey</span><br><span class="line">string.format(&quot;%5.3s&quot;, &quot;monkey&quot;)        -- 输出  mon</span><br></pre></td></tr></table></figure>

<h3 id="字符与整数相互转换"><a href="#字符与整数相互转换" class="headerlink" title="字符与整数相互转换"></a>字符与整数相互转换</h3><p>以下实例演示了字符与整数相互转换：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 字符转换</span><br><span class="line">-- 转换第一个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;))</span><br><span class="line">-- 转换第三个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,3))</span><br><span class="line">-- 转换末尾第一个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,-1))</span><br><span class="line">-- 第二个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,2))</span><br><span class="line">-- 转换末尾第二个字符</span><br><span class="line">print(string.byte(&quot;Lua&quot;,-2))</span><br><span class="line"></span><br><span class="line">-- 整数 ASCII 码转换为字符</span><br><span class="line">print(string.char(97))</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">76</span><br><span class="line">97</span><br><span class="line">97</span><br><span class="line">117</span><br><span class="line">117</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><p>以下实例演示了其他字符串操作，如计算字符串长度，字符串连接，字符串复制等：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string1 = &quot;www.&quot;</span><br><span class="line">string2 = &quot;runoob&quot;</span><br><span class="line">string3 = &quot;.com&quot;</span><br><span class="line">-- 使用 .. 进行字符串连接</span><br><span class="line">print(&quot;连接字符串&quot;,string1..string2..string3)</span><br><span class="line"></span><br><span class="line">-- 字符串长度</span><br><span class="line">print(&quot;字符串长度 &quot;,string.len(string2))</span><br><span class="line"></span><br><span class="line">-- 字符串复制 2 次</span><br><span class="line">repeatedString = string.rep(string2,2)</span><br><span class="line">print(repeatedString)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接字符串    www.runoob.com</span><br><span class="line">字符串长度     6</span><br><span class="line">runoobrunoob</span><br></pre></td></tr></table></figure>

<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 <strong>string.find, string.gmatch, string.gsub, string.match</strong>。</p>
<p>你还可以在模式串中使用字符类。</p>
<p>字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 <strong>%d</strong> 匹配任意数字。所以你可以使用模式串 <strong>%d%d&#x2F;%d%d&#x2F;%d%d%d%d</strong> 搜索 <strong>dd&#x2F;mm&#x2F;yyyy</strong> 格式的日期：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;Deadline is 30/05/1999, firm&quot;</span><br><span class="line">date = &quot;%d%d/%d%d/%d%d%d%d&quot;</span><br><span class="line">print(string.sub(s, string.find(s, date)))    --&gt; 30/05/1999</span><br></pre></td></tr></table></figure>

<p>下面的表列出了Lua支持的所有字符类：</p>
<p>单个字符(除 <strong>^$()%.[]*+-?</strong> 外): 与该字符自身配对</p>
<ul>
<li><p>.(点): 与任何字符配对</p>
</li>
<li><p>%a: 与任何字母配对</p>
</li>
<li><p>%c: 与任何控制符配对(例如\n)</p>
</li>
<li><p>%d: 与任何数字配对</p>
</li>
<li><p>%l: 与任何小写字母配对</p>
</li>
<li><p>%p: 与任何标点(punctuation)配对</p>
</li>
<li><p>%s: 与空白字符配对</p>
</li>
<li><p>%u: 与任何大写字母配对</p>
</li>
<li><p>%w: 与任何字母&#x2F;数字配对</p>
</li>
<li><p>%x: 与任何十六进制数配对</p>
</li>
<li><p>%z: 与任何代表0的字符配对</p>
</li>
<li><p>%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对</p>
</li>
<li><p>[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母&#x2F;数字, 或下划线符号(_)配对</p>
</li>
<li><p>[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对</p>
</li>
</ul>
<p>当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))</span><br><span class="line">hello..up.down.    4</span><br></pre></td></tr></table></figure>

<p>数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。</p>
<p>在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">( ) . % + - * ? [ ^ $</span><br></pre></td></tr></table></figure>

<p>‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%’不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。</p>
<p><strong>模式条目可以是：</strong></p>
<ul>
<li>单个字符类匹配该类别中任意单个字符；</li>
<li>单个字符类跟一个 ‘<code>*</code>‘， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>+</code>‘， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串；</li>
<li>单个字符类跟一个 ‘<code>-</code>‘， 将匹配零或更多个该类的字符。 和 ‘<code>*</code>‘ 不同， 这个条目总是匹配尽可能短的串；</li>
<li>单个字符类跟一个 ‘<code>?</code>‘， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个；</li>
<li><code>%*n*</code>， 这里的 <em>n</em> 可以从 1 到 9； 这个条目匹配一个等于 <em>n</em> 号捕获物（后面有描述）的子串。</li>
<li><code>%b*xy*</code>， 这里的 <em>x</em> 和 <em>y</em> 是两个明确的字符； 这个条目匹配以 <em>x</em> 开始 <em>y</em> 结束， 且其中 <em>x</em> 和 <em>y</em> 保持 <em>平衡</em> 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 <em>x</em> 就 <em>+1</em> ，读到一个 <em>y</em> 就 <em>-1</em>， 最终结束处的那个 <em>y</em> 是第一个记数到 0 的 <em>y</em>。 举个例子，条目 <code>%b()</code> 可以匹配到括号平衡的表达式。</li>
<li><code>%f[*set*]</code>， 指 <em>边境模式</em>； 这个条目会匹配到一个位于 <em>set</em> 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 <em>set</em> 。 集合 <em>set</em> 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘<code>\0</code>‘ 一样。</li>
</ul>
<p><strong>模式：</strong></p>
<p><em>模式</em> 指一个模式条目的序列。 在模式最前面加上符号 ‘<code>^</code>‘ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘<code>$</code>‘ 将使匹配过程锚定到字符串的结尾。 如果 ‘<code>^</code>‘ 和 ‘<code>$</code>‘ 出现在其它位置，它们均没有特殊含义，只表示自身。</p>
<p><strong>捕获：</strong></p>
<p>模式可以在内部用小括号括起一个子模式； 这些子模式被称为 <em>捕获物</em>。 当匹配成功时，由 <em>捕获物</em> 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 <code>&quot;(a*(.)%w(%s*))&quot;</code> ， 字符串中匹配到 <code>&quot;a*(.)%w(%s*)&quot;</code> 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “<code>.</code>“ 匹配到的字符是 2 号捕获物， 匹配到 “<code>%s*</code>“ 的那部分是 3 号。</p>
<p>作为一个特例，空的捕获 <code>()</code> 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 <code>&quot;()aa()&quot;</code> 作用到字符串 <code>&quot;flaaap&quot;</code> 上，将产生两个捕获物： 3 和 5 。</p>
<hr>
<h1 id="Lua-数组"><a href="#Lua-数组" class="headerlink" title="Lua 数组"></a>Lua 数组</h1><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。</p>
<p>在 Lua 中，数组不是一种特定的数据类型，而是一种用来存储一组值的数据结构。</p>
<p>实际上，Lua 中并没有专门的数组类型，而是使用一种被称为 <strong>“table”</strong> 的数据结构来实现数组的功能。</p>
<p>Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p>
<p>在 Lua 索引值是以 <strong>1</strong> 为起始，但你也可以指定 0 开始。</p>
<hr>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>一维数组是最简单的数组，其逻辑结构是线性表。</p>
<p>使用索引访问数组元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 访问数组元素</span><br><span class="line">print(myArray[1])  -- 输出 10</span><br><span class="line">print(myArray[3])  -- 输出 30</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<p>要计算数组的长度（即数组中元素的个数），你可以使用 <strong>#</strong> 操作符：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 计算数组长度</span><br><span class="line">local length = #myArray</span><br><span class="line"></span><br><span class="line">print(length) -- 输出 5</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>一维数组可以用 <strong>for</strong> 循环出数组中的元素，如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>lua 索引默认从 1 开始：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array = &#123;&quot;Lua&quot;, &quot;Tutorial&quot;&#125;</span><br><span class="line"></span><br><span class="line">for i= 0, 2 do</span><br><span class="line">   print(array[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nil</span><br><span class="line">Lua</span><br><span class="line">Tutorial</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，我们可以使用整数索引来访问数组元素，如果指定的索引没有值则返回 <strong>nil</strong>。</p>
<p>除此外我们还可以以负数为数组索引值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line">for i= -2, 2 do</span><br><span class="line">   array[i] = i *2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i = -2,2 do</span><br><span class="line">   print(array[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-4</span><br><span class="line">-2</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>我们也可以修改数组中元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 修改数组元素</span><br><span class="line">myArray[2] = 25</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">25</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<p>我们也可以向数组中添加元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 添加新元素到数组末尾</span><br><span class="line">myArray[#myArray + 1] = 60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br><span class="line">40</span><br><span class="line">50</span><br><span class="line">60</span><br></pre></td></tr></table></figure>

<p>我们也可以删除数组中元素：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建一个数组</span><br><span class="line">local myArray = &#123;10, 20, 30, 40, 50&#125;</span><br><span class="line"></span><br><span class="line">-- 删除第三个元素</span><br><span class="line">table.remove(myArray, 3)</span><br><span class="line"></span><br><span class="line">-- 循环遍历数组</span><br><span class="line">for i = 1, #myArray do</span><br><span class="line">    print(myArray[i])</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">40</span><br><span class="line">50</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组即数组中包含数组或一维数组的索引键对应一个数组。</p>
<p>以下是一个三行三列的阵列多维数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 初始化数组</span><br><span class="line">array = &#123;&#125;</span><br><span class="line">for i=1,3 do</span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      for j=1,3 do</span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 访问数组</span><br><span class="line">for i=1,3 do</span><br><span class="line">   for j=1,3 do</span><br><span class="line">      print(array[i][j])</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>不同索引键的三行三列阵列多维数组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 初始化数组</span><br><span class="line">array = &#123;&#125;</span><br><span class="line">maxRows = 3</span><br><span class="line">maxColumns = 3</span><br><span class="line">for row=1,maxRows do</span><br><span class="line">   for col=1,maxColumns do</span><br><span class="line">      array[row*maxColumns +col] = row*col</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 访问数组</span><br><span class="line">for row=1,maxRows do</span><br><span class="line">   for col=1,maxColumns do</span><br><span class="line">      print(array[row*maxColumns +col])</span><br><span class="line">   end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，以上的实例中，数组设定了指定的索引值，这样可以避免出现 nil 值，有利于节省内存空间。</p>
<hr>
<h1 id="Lua-迭代器"><a href="#Lua-迭代器" class="headerlink" title="Lua 迭代器"></a>Lua 迭代器</h1><p>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。</p>
<p>在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。</p>
<hr>
<h2 id="泛型-for-迭代器"><a href="#泛型-for-迭代器" class="headerlink" title="泛型 for 迭代器"></a>泛型 for 迭代器</h2><p>泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。</p>
<p>泛型 for 迭代器提供了集合的 key&#x2F;value 对，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for k, v in pairs(t) do</span><br><span class="line">    print(k, v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>上面代码中，k, v为变量列表；pairs(t)为表达式列表。</p>
<p>查看以下实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line"></span><br><span class="line">for key,value in ipairs(array) </span><br><span class="line">do</span><br><span class="line">   print(key, value)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上代码执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  Google</span><br><span class="line">2  Runoob</span><br></pre></td></tr></table></figure>

<p>以上实例中我们使用了 Lua 默认提供的迭代函数 ipairs。</p>
<p>下面我们看看泛型 for 的执行过程：</p>
<ul>
<li>首先，初始化，计算 in 后面表达式的值，表达式应该返回泛型 for 需要的三个值：迭代函数、状态常量、控制变量；与多值赋值一样，如果表达式返回的结果个数不足三个会自动用 nil 补足，多出部分会被忽略。</li>
<li>第二，将状态常量和控制变量作为参数调用迭代函数（注意：对于 for 结构来说，状态常量没有用处，仅仅在初始化时获取他的值并传递给迭代函数）。</li>
<li>第三，将迭代函数返回的值赋给变量列表。</li>
<li>第四，如果返回的第一个值为nil循环结束，否则执行循环体。</li>
<li>第五，回到第二步再次调用迭代函数</li>
</ul>
<p>在Lua中我们常常使用函数来描述迭代器，每次调用该函数就返回集合的下一个元素。Lua 的迭代器包含以下两种类型：</p>
<ul>
<li>无状态的迭代器</li>
<li>多状态的迭代器</li>
</ul>
<hr>
<h2 id="无状态的迭代器"><a href="#无状态的迭代器" class="headerlink" title="无状态的迭代器"></a>无状态的迭代器</h2><p>无状态的迭代器是指不保留任何状态的迭代器，因此在循环中我们可以利用无状态迭代器避免创建闭包花费额外的代价。</p>
<p>每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素。</p>
<p>这种无状态迭代器的典型的简单的例子是 ipairs，它遍历数组的每一个元素，元素的索引需要是数值。</p>
<p>以下实例我们使用了一个简单的函数来实现迭代器，实现 数字 n 的平方：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function square(iteratorMaxCount,currentNumber)</span><br><span class="line">   if currentNumber&lt;iteratorMaxCount</span><br><span class="line">   then</span><br><span class="line">      currentNumber = currentNumber+1</span><br><span class="line">   return currentNumber, currentNumber*currentNumber</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i,n in square,3,0</span><br><span class="line">do</span><br><span class="line">   print(i,n)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1    1</span><br><span class="line">2    4</span><br><span class="line">3    9</span><br></pre></td></tr></table></figure>

<p>迭代的状态包括被遍历的表（循环过程中不会改变的状态常量）和当前的索引下标（控制变量），ipairs 和迭代函数都很简单，我们在 Lua 中可以这样实现：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function iter (a, i)</span><br><span class="line">    i = i + 1</span><br><span class="line">    local v = a[i]</span><br><span class="line">    if v then</span><br><span class="line">       return i, v</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function ipairs (a)</span><br><span class="line">    return iter, a, 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a,0) 返回 1, a[1]（除非 a[1]&#x3D;nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]……直到第一个 nil 元素。</p>
<hr>
<h2 id="多状态的迭代器"><a href="#多状态的迭代器" class="headerlink" title="多状态的迭代器"></a>多状态的迭代器</h2><p>很多情况下，迭代器需要保存多个状态信息而不是简单的状态常量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到 table 内，将 table 作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在 table 内，所以迭代函数通常不需要第二个参数。</p>
<p>以下实例我们创建了自己的迭代器：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array = &#123;&quot;Google&quot;, &quot;Runoob&quot;&#125;</span><br><span class="line"></span><br><span class="line">function elementIterator (collection)</span><br><span class="line">   local index = 0</span><br><span class="line">   local count = #collection</span><br><span class="line">   -- 闭包函数</span><br><span class="line">   return function ()</span><br><span class="line">      index = index + 1</span><br><span class="line">      if index &lt;= count</span><br><span class="line">      then</span><br><span class="line">         --  返回迭代器的当前元素</span><br><span class="line">         return collection[index]</span><br><span class="line">      end</span><br><span class="line">   end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for element in elementIterator(array)</span><br><span class="line">do</span><br><span class="line">   print(element)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>

<p>以上实例中我们可以看到，elementIterator 内使用了闭包函数，实现计算集合大小并输出各个元素。</p>
<hr>
<h1 id="Lua-table-表"><a href="#Lua-table-表" class="headerlink" title="Lua table(表)"></a>Lua table(表)</h1><p>table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。</p>
<p>Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。</p>
<p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p>
<p>Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。</p>
<hr>
<h2 id="table-表-的构造"><a href="#table-表-的构造" class="headerlink" title="table(表)的构造"></a>table(表)的构造</h2><p>构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 初始化表</span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- 指定值</span><br><span class="line">mytable[1]= &quot;Lua&quot;</span><br><span class="line"></span><br><span class="line">-- 移除引用</span><br><span class="line">mytable = nil</span><br><span class="line">-- lua 垃圾回收会释放内存</span><br></pre></td></tr></table></figure>

<p>当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。</p>
<p>以下实例演示了以上的描述情况：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 简单的 table</span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line">print(&quot;mytable 的类型是 &quot;,type(mytable))</span><br><span class="line"></span><br><span class="line">mytable[1]= &quot;Lua&quot;</span><br><span class="line">mytable[&quot;wow&quot;] = &quot;修改前&quot;</span><br><span class="line">print(&quot;mytable 索引为 1 的元素是 &quot;, mytable[1])</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">-- alternatetable和mytable的是指同一个 table</span><br><span class="line">alternatetable = mytable</span><br><span class="line"></span><br><span class="line">print(&quot;alternatetable 索引为 1 的元素是 &quot;, alternatetable[1])</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, alternatetable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">alternatetable[&quot;wow&quot;] = &quot;修改后&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">-- 释放变量</span><br><span class="line">alternatetable = nil</span><br><span class="line">print(&quot;alternatetable 是 &quot;, alternatetable)</span><br><span class="line"></span><br><span class="line">-- mytable 仍然可以访问</span><br><span class="line">print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])</span><br><span class="line"></span><br><span class="line">mytable = nil</span><br><span class="line">print(&quot;mytable 是 &quot;, mytable)</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable 的类型是     table</span><br><span class="line">mytable 索引为 1 的元素是     Lua</span><br><span class="line">mytable 索引为 wow 的元素是     修改前</span><br><span class="line">alternatetable 索引为 1 的元素是     Lua</span><br><span class="line">mytable 索引为 wow 的元素是     修改前</span><br><span class="line">mytable 索引为 wow 的元素是     修改后</span><br><span class="line">alternatetable 是     nil</span><br><span class="line">mytable 索引为 wow 的元素是     修改后</span><br><span class="line">mytable 是     nil</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><p>以下列出了 Table 操作常用的方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">**table.concat (table [, sep [, start [, end]]]):**concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">**table.insert (table, [pos,] value):**在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">**table.maxn (table)**指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">**table.remove (table [, pos])**返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">**table.sort (table [, comp])**对给定的table进行升序排序。</td>
</tr>
</tbody></table>
<p>接下来我们来看下这几个方法的实例。</p>
<h3 id="Table-连接"><a href="#Table-连接" class="headerlink" title="Table 连接"></a>Table 连接</h3><p>我们可以使用 concat() 输出一个列表中元素连接成的字符串:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line">-- 返回 table 连接后的字符串</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits))</span><br><span class="line"></span><br><span class="line">-- 指定连接字符</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))</span><br><span class="line"></span><br><span class="line">-- 指定索引来连接 table</span><br><span class="line">print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">连接后的字符串     bananaorangeapple</span><br><span class="line">连接后的字符串     banana, orange, apple</span><br><span class="line">连接后的字符串     orange, apple</span><br></pre></td></tr></table></figure>

<h3 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h3><p>以下实例演示了 table 的插入和移除操作:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;</span><br><span class="line"></span><br><span class="line">-- 在末尾插入</span><br><span class="line">table.insert(fruits,&quot;mango&quot;)</span><br><span class="line">print(&quot;索引为 4 的元素为 &quot;,fruits[4])</span><br><span class="line"></span><br><span class="line">-- 在索引为 2 的键处插入</span><br><span class="line">table.insert(fruits,2,&quot;grapes&quot;)</span><br><span class="line">print(&quot;索引为 2 的元素为 &quot;,fruits[2])</span><br><span class="line"></span><br><span class="line">print(&quot;最后一个元素为 &quot;,fruits[5])</span><br><span class="line">table.remove(fruits)</span><br><span class="line">print(&quot;移除后最后一个元素为 &quot;,fruits[5])</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引为 4 的元素为     mango</span><br><span class="line">索引为 2 的元素为     grapes</span><br><span class="line">最后一个元素为     mango</span><br><span class="line">移除后最后一个元素为     nil</span><br></pre></td></tr></table></figure>

<h3 id="Table-排序"><a href="#Table-排序" class="headerlink" title="Table 排序"></a>Table 排序</h3><p>以下实例演示了 sort() 方法的使用，用于对 Table 进行排序：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;&#125;</span><br><span class="line">print(&quot;排序前&quot;)</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">        print(k,v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">table.sort(fruits)</span><br><span class="line">print(&quot;排序后&quot;)</span><br><span class="line">for k,v in ipairs(fruits) do</span><br><span class="line">        print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">1    banana</span><br><span class="line">2    orange</span><br><span class="line">3    apple</span><br><span class="line">4    grapes</span><br><span class="line">排序后</span><br><span class="line">1    apple</span><br><span class="line">2    banana</span><br><span class="line">3    grapes</span><br><span class="line">4    orange</span><br></pre></td></tr></table></figure>

<h3 id="Table-最大值"><a href="#Table-最大值" class="headerlink" title="Table 最大值"></a>Table 最大值</h3><p>table.maxn 在 Lua5.2 之后该方法已经不存在了，我们定义了 table_maxn 方法来实现。</p>
<p>以下实例演示了如何获取 table 中的最大值：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function table_maxn(t)</span><br><span class="line">  local mn=nil;</span><br><span class="line">  for k, v in pairs(t) do</span><br><span class="line">    if(mn==nil) then</span><br><span class="line">      mn=v</span><br><span class="line">    end</span><br><span class="line">    if mn &lt; v then</span><br><span class="line">      mn = v</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  return mn</span><br><span class="line">end</span><br><span class="line">tbl = &#123;[1] = 2, [2] = 6, [3] = 34, [26] =5&#125;</span><br><span class="line">print(&quot;tbl 最大值：&quot;, table_maxn(tbl))</span><br><span class="line">print(&quot;tbl 长度 &quot;, #tbl)</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tbl 最大值：    34</span><br><span class="line">tbl 长度     3</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<p>当我们获取 table 的长度的时候无论是使用 <strong>#</strong> 还是 <strong>table.getn</strong> 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p>
<p>可以使用以下方法来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function table_leng(t)</span><br><span class="line">local leng=0</span><br><span class="line">for k, v in pairs(t) do</span><br><span class="line"> leng=leng+1</span><br><span class="line">end</span><br><span class="line">return leng;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h1 id="Lua-模块与包"><a href="#Lua-模块与包" class="headerlink" title="Lua 模块与包"></a>Lua 模块与包</h1><p>模块类似于一个封装库，从 Lua 5.1 开始，Lua 加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以 API 接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度。</p>
<p>Lua 的模块是由变量、函数等已知元素组成的 table，因此创建一个模块很简单，就是创建一个 table，然后把需要导出的常量、函数放入其中，最后返回这个 table 就行。以下为创建自定义模块 module.lua，文件代码格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 文件名为 module.lua</span><br><span class="line">-- 定义一个名为 module 的模块</span><br><span class="line">module = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">-- 定义一个常量</span><br><span class="line">module.constant = &quot;这是一个常量&quot;</span><br><span class="line"> </span><br><span class="line">-- 定义一个函数</span><br><span class="line">function module.func1()</span><br><span class="line">    io.write(&quot;这是一个公有函数！\n&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">local function func2()</span><br><span class="line">    print(&quot;这是一个私有函数！&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">function module.func3()</span><br><span class="line">    func2()</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">return module</span><br></pre></td></tr></table></figure>

<p>由上可知，模块的结构就是一个 table 的结构，因此可以像操作调用 table 里的元素那样来操作调用模块里的常量或函数。</p>
<p>上面的 func2 声明为程序块的局部变量，即表示一个私有函数，因此是不能从外部访问模块里的这个私有函数，必须通过模块里的公有函数来调用.</p>
<hr>
<h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h2><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(&quot;&lt;模块名&gt;&quot;)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require &quot;&lt;模块名&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p>
<p><strong>test_module.lua 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test_module.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(module.constant)</span><br><span class="line"> </span><br><span class="line">module.func3()</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>

<p>或者给加载的模块定义一个别名变量，方便调用：</p>
<p><strong>test_module2.lua 文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test_module2.lua 文件</span><br><span class="line">-- module 模块为上文提到到 module.lua</span><br><span class="line">-- 别名变量 m</span><br><span class="line">local m = require(&quot;module&quot;)</span><br><span class="line"> </span><br><span class="line">print(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>

<h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>对于自定义的模块，模块文件不是放在哪个文件目录都行，函数 require 有它自己的文件路径加载策略，它会尝试从 Lua 文件或 C 程序库中加载模块。</p>
<p>require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。</p>
<p>当然，如果没有 LUA_PATH 这个环境变量，也可以自定义设置，在当前用户根目录下打开 .profile 文件（没有则创建，打开 .bashrc 文件也可以），例如把 “~&#x2F;lua&#x2F;“ 路径加入 LUA_PATH 环境变量里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#LUA_PATH</span><br><span class="line">export LUA_PATH=&quot;~/lua/?.lua;;&quot;</span><br></pre></td></tr></table></figure>

<p>文件路径以 “;” 号分隔，最后的 2 个 “;;” 表示新加的路径后面加上原来的默认路径。</p>
<p>接着，更新环境变量参数，使之立即生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure>

<p>这时假设 package.path 的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/dengjoe/lua/?.lua;./?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua;/usr/local/lib/lua/5.1/?.lua;/usr/local/lib/lua/5.1/?/init.lua</span><br></pre></td></tr></table></figure>

<p>那么调用 require(“module”) 时就会尝试打开以下文件目录去搜索目标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Users/dengjoe/lua/module.lua;</span><br><span class="line">./module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module.lua</span><br><span class="line">/usr/local/share/lua/5.1/module/init.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module.lua</span><br><span class="line">/usr/local/lib/lua/5.1/module/init.lua</span><br></pre></td></tr></table></figure>

<p>如果找过目标文件，则会调用 package.loadfile 来加载模块。否则，就会去找 C 程序库。</p>
<p>搜索的文件路径是从全局变量 package.cpath 获取，而这个变量则是通过环境变量 LUA_CPATH 来初始。</p>
<p>搜索的策略跟上面的一样，只不过现在换成搜索的是 so 或 dll 类型的文件。如果找得到，那么 require 就会通过 package.loadlib 来加载它。</p>
<hr>
<h2 id="C-包"><a href="#C-包" class="headerlink" title="C 包"></a>C 包</h2><p>Lua和C是很容易结合的，使用 C 为 Lua 写包。</p>
<p>与Lua中写包不同，C包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制。</p>
<p>Lua在一个叫loadlib的函数内提供了所有的动态连接的功能。这个函数有两个参数:库的绝对路径和初始化函数。所以典型的调用的例子如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local path = &quot;/usr/local/lua/lib/libluasocket.so&quot;</span><br><span class="line">local f = loadlib(path, &quot;luaopen_socket&quot;)</span><br></pre></td></tr></table></figure>

<p>loadlib 函数加载指定的库并且连接到 Lua，然而它并不打开库（也就是说没有调用初始化函数），反之他返回初始化函数作为 Lua 的一个函数，这样我们就可以直接在Lua中调用他。</p>
<p>如果加载动态库或者查找初始化函数时出错，loadlib 将返回 nil 和错误信息。我们可以修改前面一段代码，使其检测错误然后调用初始化函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local path = &quot;/usr/local/lua/lib/libluasocket.so&quot;</span><br><span class="line">-- 或者 path = &quot;C:\\windows\\luasocket.dll&quot;，这是 Windows 平台下</span><br><span class="line">local f = assert(loadlib(path, &quot;luaopen_socket&quot;))</span><br><span class="line">f()  -- 真正打开库</span><br></pre></td></tr></table></figure>

<p>一般情况下我们期望二进制的发布库包含一个与前面代码段相似的 stub 文件，安装二进制库的时候可以随便放在某个目录，只需要修改 stub 文件对应二进制库的实际路径即可。</p>
<p>将 stub 文件所在的目录加入到 LUA_PATH，这样设定后就可以使用 require 函数加载 C 库了。</p>
<hr>
<h1 id="Lua-元表-Metatable"><a href="#Lua-元表-Metatable" class="headerlink" title="Lua 元表(Metatable)"></a>Lua 元表(Metatable)</h1><p>在 Lua table 中我们可以访问对应的 key 来得到 value 值，但是却无法对两个 table 进行操作(比如相加)。</p>
<p>因此 Lua 提供了元表(Metatable)，允许我们改变 table 的行为，每个行为关联了对应的元方法。</p>
<p>例如，使用元表我们可以定义 Lua 如何计算两个 table 的相加操作 a+b。</p>
<p>当 Lua 试图对两个表进行相加时，先检查两者之一是否有元表，之后检查是否有一个叫 <strong>__add</strong> 的字段，若找到，则调用对应的值。 <strong>__add</strong> 等即时字段，其对应的值（往往是一个函数或是 table）就是”元方法”。</p>
<p>有两个很重要的函数来处理元表：</p>
<ul>
<li><strong>setmetatable(table,metatable):</strong> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。</li>
<li><strong>getmetatable(table):</strong> 返回对象的元表(metatable)。</li>
</ul>
<p>以下实例演示了如何对指定的表设置元表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&#125;                          -- 普通表 </span><br><span class="line">mymetatable = &#123;&#125;                      -- 元表</span><br><span class="line">setmetatable(mytable,mymetatable)     -- 把 mymetatable 设为 mytable 的元表</span><br></pre></td></tr></table></figure>

<p>以上代码也可以直接写成一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = setmetatable(&#123;&#125;,&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>以下为返回对象元表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getmetatable(mytable)                 -- 这会返回 mymetatable</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="index-元方法"><a href="#index-元方法" class="headerlink" title="__index 元方法"></a>__index 元方法</h2><p>这是 metatable 最常用的键。</p>
<p>当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。</p>
<p>我们可以在使用 lua 命令进入交互模式查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lua</span><br><span class="line">Lua 5.3.0  Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; other = &#123; foo = 3 &#125; </span><br><span class="line">&gt; t = setmetatable(&#123;&#125;, &#123; __index = other &#125;) </span><br><span class="line">&gt; t.foo</span><br><span class="line">3</span><br><span class="line">&gt; t.bar</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>如果__index包含一个函数的话，Lua就会调用那个函数，table和键会作为参数传递给函数。</p>
<p>__index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;</span><br><span class="line">  __index = function(mytable, key)</span><br><span class="line">    if key == &quot;key2&quot; then</span><br><span class="line">      return &quot;metatablevalue&quot;</span><br><span class="line">    else</span><br><span class="line">      return nil</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<p>实例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value1    metatablevalue</span><br></pre></td></tr></table></figure>

<p>实例解析：</p>
<ul>
<li>mytable 表赋值为 **{key1 &#x3D; “value1”}**。</li>
<li>mytable 设置了元表，元方法为 __index。</li>
<li>在mytable表中查找 key1，如果找到，返回该元素，找不到则继续。</li>
<li>在mytable表中查找 key2，如果找到，返回 metatablevalue，找不到则继续。</li>
<li>判断元表有没有__index方法，如果__index方法是一个函数，则调用该函数。</li>
<li>元方法中查看是否传入 “key2” 键的参数（mytable.key2已设置），如果传入 “key2” 参数返回 “metatablevalue”，否则返回 mytable 对应的键值。</li>
</ul>
<p>我们可以将以上代码简单写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __index = &#123; key2 = &quot;metatablevalue&quot; &#125; &#125;)</span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:</p>
<ul>
<li>1.在表中查找，如果找到，返回该元素，找不到则继续</li>
<li>2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。</li>
<li>3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。</li>
</ul>
<p>该部分内容来自作者寰子：<a href="https://blog.csdn.net/xocoder/article/details/9028347">https://blog.csdn.net/xocoder/article/details/9028347</a></p>
</blockquote>
<hr>
<h2 id="newindex-元方法"><a href="#newindex-元方法" class="headerlink" title="__newindex 元方法"></a>__newindex 元方法</h2><p>__newindex 元方法用来对表更新，__index则用来对表访问 。</p>
<p>当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。</p>
<p>以下实例演示了 __newindex 元方法的应用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123; __newindex = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line">print(mytable.key1)</span><br><span class="line"></span><br><span class="line">mytable.newkey = &quot;新值2&quot;</span><br><span class="line">print(mytable.newkey,mymetatable.newkey)</span><br><span class="line"></span><br><span class="line">mytable.key1 = &quot;新值1&quot;</span><br><span class="line">print(mytable.key1,mymetatable.key1)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value1</span><br><span class="line">nil    新值2</span><br><span class="line">新值1    nil</span><br></pre></td></tr></table></figure>

<p>以上实例中表设置了元方法__newindex，在对新索引键（newkey）赋值时（mytable.newkey &#x3D; “新值2”），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。</p>
<p>以下实例使用了 rawset 函数来更新表：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = setmetatable(&#123;key1 = &quot;value1&quot;&#125;, &#123;</span><br><span class="line">    __newindex = function(mytable, key, value)</span><br><span class="line">        rawset(mytable, key, &quot;\&quot;&quot;..value..&quot;\&quot;&quot;)</span><br><span class="line">    end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mytable.key1 = &quot;new value&quot;</span><br><span class="line">mytable.key2 = 4</span><br><span class="line"></span><br><span class="line">print(mytable.key1,mytable.key2)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new value    &quot;4&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="为表添加操作符"><a href="#为表添加操作符" class="headerlink" title="为表添加操作符"></a>为表添加操作符</h2><p>以下实例演示了两表相加操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即返回表最大键值</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn = 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn = k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 两表相加操作</span><br><span class="line">mytable = setmetatable(&#123; 1, 2, 3 &#125;, &#123;</span><br><span class="line">  __add = function(mytable, newtable)</span><br><span class="line">    for i = 1, table_maxn(newtable) do</span><br><span class="line">      table.insert(mytable, table_maxn(mytable)+1,newtable[i])</span><br><span class="line">    end</span><br><span class="line">    return mytable</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">secondtable = &#123;4,5,6&#125;</span><br><span class="line"></span><br><span class="line">mytable = mytable + secondtable</span><br><span class="line">        for k,v in ipairs(mytable) do</span><br><span class="line">print(k,v)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1    1</span><br><span class="line">2    2</span><br><span class="line">3    3</span><br><span class="line">4    4</span><br><span class="line">5    5</span><br><span class="line">6    6</span><br></pre></td></tr></table></figure>

<p>__add 键包含在元表中，并进行相加操作。 表中对应的操作列表如下：(**注意：__是两个下划线)</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__add</td>
<td align="left">对应的运算符 ‘+’.</td>
</tr>
<tr>
<td align="left">__sub</td>
<td align="left">对应的运算符 ‘-‘.</td>
</tr>
<tr>
<td align="left">__mul</td>
<td align="left">对应的运算符 ‘*’.</td>
</tr>
<tr>
<td align="left">__div</td>
<td align="left">对应的运算符 ‘&#x2F;‘.</td>
</tr>
<tr>
<td align="left">__mod</td>
<td align="left">对应的运算符 ‘%’.</td>
</tr>
<tr>
<td align="left">__unm</td>
<td align="left">对应的运算符 ‘-‘.</td>
</tr>
<tr>
<td align="left">__concat</td>
<td align="left">对应的运算符 ‘..’.</td>
</tr>
<tr>
<td align="left">__eq</td>
<td align="left">对应的运算符 ‘&#x3D;&#x3D;’.</td>
</tr>
<tr>
<td align="left">__lt</td>
<td align="left">对应的运算符 ‘&lt;’.</td>
</tr>
<tr>
<td align="left">__le</td>
<td align="left">对应的运算符 ‘&lt;&#x3D;’.</td>
</tr>
</tbody></table>
<hr>
<h2 id="call-元方法"><a href="#call-元方法" class="headerlink" title="__call 元方法"></a>__call 元方法</h2><p>__call 元方法在 Lua 调用一个值时调用。以下实例演示了计算表中元素的和：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用</span><br><span class="line">-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数</span><br><span class="line">function table_maxn(t)</span><br><span class="line">    local mn = 0</span><br><span class="line">    for k, v in pairs(t) do</span><br><span class="line">        if mn &lt; k then</span><br><span class="line">            mn = k</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">    return mn</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 定义元方法__call</span><br><span class="line">mytable = setmetatable(&#123;10&#125;, &#123;</span><br><span class="line">  __call = function(mytable, newtable)</span><br><span class="line">        sum = 0</span><br><span class="line">        for i = 1, table_maxn(mytable) do</span><br><span class="line">                sum = sum + mytable[i]</span><br><span class="line">        end</span><br><span class="line">    for i = 1, table_maxn(newtable) do</span><br><span class="line">                sum = sum + newtable[i]</span><br><span class="line">        end</span><br><span class="line">        return sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">newtable = &#123;10,20,30&#125;</span><br><span class="line">print(mytable(newtable))</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="tostring-元方法"><a href="#tostring-元方法" class="headerlink" title="__tostring 元方法"></a>__tostring 元方法</h2><p>__tostring 元方法用于修改表的输出行为。以下实例我们自定义了表的输出内容：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = setmetatable(&#123; 10, 20, 30 &#125;, &#123;</span><br><span class="line">  __tostring = function(mytable)</span><br><span class="line">    sum = 0</span><br><span class="line">    for k, v in pairs(mytable) do</span><br><span class="line">                sum = sum + v</span><br><span class="line">        end</span><br><span class="line">    return &quot;表所有元素的和为 &quot; .. sum</span><br><span class="line">  end</span><br><span class="line">&#125;)</span><br><span class="line">print(mytable)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表所有元素的和为 60</span><br></pre></td></tr></table></figure>

<p>从本文中我们可以知道元表可以很好的简化我们的代码功能，所以了解 Lua 的元表，可以让我们写出更加简单优秀的 Lua 代码。</p>
<hr>
<h1 id="Lua-协同程序-coroutine"><a href="#Lua-协同程序-coroutine" class="headerlink" title="Lua 协同程序(coroutine)"></a>Lua 协同程序(coroutine)</h1><hr>
<h2 id="什么是协同-coroutine-？"><a href="#什么是协同-coroutine-？" class="headerlink" title="什么是协同(coroutine)？"></a>什么是协同(coroutine)？</h2><p>Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。</p>
<p>协同程序可以理解为一种特殊的线程，可以暂停和恢复其执行，从而允许非抢占式的多任务处理。</p>
<p>协同是非常强大的功能，但是用起来也很复杂。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>同程序由 <strong>coroutine</strong> 模块提供支持。</p>
<p>使用协同程序，你可以在函数中使用 <strong>coroutine.create</strong> 创建一个新的协同程序对象，并使用 <strong>coroutine.resume</strong> 启动它的执行。协同程序可以通过调用 <strong>coroutine.yield</strong> 来主动暂停自己的执行，并将控制权交还给调用者。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">coroutine.create()</td>
<td align="left">创建 coroutine，返回 coroutine， 参数是一个函数，当和 resume 配合使用的时候就唤醒函数调用</td>
</tr>
<tr>
<td align="left">coroutine.resume()</td>
<td align="left">重启 coroutine，和 create 配合使用</td>
</tr>
<tr>
<td align="left">coroutine.yield()</td>
<td align="left">挂起 coroutine，将 coroutine 设置为挂起状态，这个和 resume 配合使用能有很多有用的效果</td>
</tr>
<tr>
<td align="left">coroutine.status()</td>
<td align="left">查看 coroutine 的状态 注：coroutine 的状态有三种：dead，suspended，running，具体什么时候有这样的状态请参考下面的程序</td>
</tr>
<tr>
<td align="left">coroutine.wrap（）</td>
<td align="left">创建 coroutine，返回一个函数，一旦你调用这个函数，就进入 coroutine，和 create 功能重复</td>
</tr>
<tr>
<td align="left">coroutine.running()</td>
<td align="left">返回正在跑的 coroutine，一个 coroutine 就是一个线程，当使用running的时候，就是返回一个 coroutine 的线程号</td>
</tr>
</tbody></table>
<p>以下实例演示了如何使用 Lua 协同程序：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()</span><br><span class="line">    print(&quot;协同程序 foo 开始执行&quot;)</span><br><span class="line">    local value = coroutine.yield(&quot;暂停 foo 的执行&quot;)</span><br><span class="line">    print(&quot;协同程序 foo 恢复执行，传入的值为: &quot; .. tostring(value))</span><br><span class="line">    print(&quot;协同程序 foo 结束执行&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建协同程序</span><br><span class="line">local co = coroutine.create(foo)</span><br><span class="line"></span><br><span class="line">-- 启动协同程序</span><br><span class="line">local status, result = coroutine.resume(co)</span><br><span class="line">print(result) -- 输出: 暂停 foo 的执行</span><br><span class="line"></span><br><span class="line">-- 恢复协同程序的执行，并传入一个值</span><br><span class="line">status, result = coroutine.resume(co, 42)</span><br><span class="line">print(result) -- 输出: 协同程序 foo 恢复执行，传入的值为: 42</span><br></pre></td></tr></table></figure>

<p>以上实例中，我们定义了一个名为 foo 的函数作为协同程序。在函数中，我们使用 coroutine.yield 暂停了协同程序的执行，并返回了一个值</p>
<p>。在主程序中，我们使用 coroutine.create 创建了一个协同程序对象，并使用 coroutine.resume 启动了它的执行。</p>
<p>在第一次调用 coroutine.resume 后，协同程序执行到 coroutine.yield 处暂停，并将值返回给主程序。然后，我们再次调用 coroutine.resume，并传入一个值作为协同程序恢复执行时的参数。</p>
<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">协同程序 foo 开始执行</span><br><span class="line">暂停 foo 的执行</span><br><span class="line">协同程序 foo 恢复执行，传入的值为: 42</span><br><span class="line">协同程序 foo 结束执行</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>

<p>需要注意的是，协同程序的状态可以通过 coroutine.status 函数获取，通过检查状态可以确定协同程序的执行情况（如运行中、已挂起、已结束等）。</p>
<p><strong>以下实例演示了以上各个方法的用法：</strong></p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- coroutine_test.lua 文件</span><br><span class="line">-- 创建了一个新的协同程序对象 co，其中协同程序函数打印传入的参数 i</span><br><span class="line">co = coroutine.create(</span><br><span class="line">    function(i)</span><br><span class="line">        print(i);</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line">-- 使用 coroutine.resume 启动协同程序 co 的执行，并传入参数 1。协同程序开始执行，打印输出为 1</span><br><span class="line">coroutine.resume(co, 1)   -- 1</span><br><span class="line"></span><br><span class="line">-- 通过 coroutine.status 检查协同程序 co 的状态，输出为 dead，表示协同程序已经执行完毕</span><br><span class="line">print(coroutine.status(co))  -- dead</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line"></span><br><span class="line">-- 使用 coroutine.wrap 创建了一个协同程序包装器，将协同程序函数转换为一个可直接调用的函数对象</span><br><span class="line">co = coroutine.wrap(</span><br><span class="line">    function(i)</span><br><span class="line">        print(i);</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">co(1)</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br><span class="line">-- 创建了另一个协同程序对象 co2，其中的协同程序函数通过循环打印数字 1 到 10，在循环到 3 的时候输出当前协同程序的状态和正在运行的线程</span><br><span class="line">co2 = coroutine.create(</span><br><span class="line">    function()</span><br><span class="line">        for i=1,10 do</span><br><span class="line">            print(i)</span><br><span class="line">            if i == 3 then</span><br><span class="line">                print(coroutine.status(co2))  --running</span><br><span class="line">                print(coroutine.running()) --thread:XXXXXX</span><br><span class="line">            end</span><br><span class="line">            coroutine.yield()</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- 连续调用 coroutine.resume 启动协同程序 co2 的执行</span><br><span class="line">coroutine.resume(co2) --1</span><br><span class="line">coroutine.resume(co2) --2</span><br><span class="line">coroutine.resume(co2) --3</span><br><span class="line"></span><br><span class="line">-- 通过 coroutine.status 检查协同程序 co2 的状态，输出为 suspended，表示协同程序暂停执行</span><br><span class="line">print(coroutine.status(co2))   -- suspended</span><br><span class="line">print(coroutine.running())</span><br><span class="line"> </span><br><span class="line">print(&quot;----------&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">dead</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">----------</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">running</span><br><span class="line">thread: 0x7fb801c05868    false</span><br><span class="line">suspended</span><br><span class="line">thread: 0x7fb801c04c88    true</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>coroutine.running就可以看出来,coroutine在底层实现就是一个线程。</p>
<p>当create一个coroutine的时候就是在新线程中注册了一个事件。</p>
<p>当使用resume触发事件的时候，create的coroutine函数就被执行了，当遇到yield的时候就代表挂起当前线程，等候再次resume触发事件。</p>
<p>接下来我们分析一个更详细的实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo (a)</span><br><span class="line">    print(&quot;foo 函数输出&quot;, a)</span><br><span class="line">    return coroutine.yield(2 * a) -- 返回  2*a 的值</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line">co = coroutine.create(function (a , b)</span><br><span class="line">    print(&quot;第一次协同程序执行输出&quot;, a, b) -- co-body 1 10</span><br><span class="line">    local r = foo(a + 1)</span><br><span class="line">     </span><br><span class="line">    print(&quot;第二次协同程序执行输出&quot;, r)</span><br><span class="line">    local r, s = coroutine.yield(a + b, a - b)  -- a，b的值为第一次调用协同程序时传入</span><br><span class="line">     </span><br><span class="line">    print(&quot;第三次协同程序执行输出&quot;, r, s)</span><br><span class="line">    return b, &quot;结束协同程序&quot;                   -- b的值为第二次调用协同程序时传入</span><br><span class="line">end)</span><br><span class="line">        </span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, 1, 10)) -- true, 4</span><br><span class="line">print(&quot;--分割线----&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;r&quot;)) -- true 11 -9</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- true 10 end</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br><span class="line">print(&quot;main&quot;, coroutine.resume(co, &quot;x&quot;, &quot;y&quot;)) -- cannot resume dead coroutine</span><br><span class="line">print(&quot;---分割线---&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次协同程序执行输出    1    10</span><br><span class="line">foo 函数输出    2</span><br><span class="line">main    true    4</span><br><span class="line">--分割线----</span><br><span class="line">第二次协同程序执行输出    r</span><br><span class="line">main    true    11    -9</span><br><span class="line">---分割线---</span><br><span class="line">第三次协同程序执行输出    x    y</span><br><span class="line">main    true    10    结束协同程序</span><br><span class="line">---分割线---</span><br><span class="line">main    false    cannot resume dead coroutine</span><br><span class="line">---分割线---</span><br></pre></td></tr></table></figure>

<p>以上实例接下如下：</p>
<ul>
<li>调用resume，将协同程序唤醒,resume操作成功返回true，否则返回false；</li>
<li>协同程序运行；</li>
<li>运行到yield语句；</li>
<li>yield挂起协同程序，第一次resume返回；（注意：此处yield返回，参数是resume的参数）</li>
<li>第二次resume，再次唤醒协同程序；（注意：此处resume的参数中，除了第一个参数，剩下的参数将作为yield的参数）</li>
<li>yield返回；</li>
<li>协同程序继续运行；</li>
<li>如果使用的协同程序继续运行完成后继续调用 resume方法则输出：cannot resume dead coroutine</li>
</ul>
<p>resume和yield的配合强大之处在于，resume处于主程中，它将外部状态（数据）传入到协同程序内部；而yield则将内部的状态（数据）返回到主程中。</p>
<hr>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>现在我就使用Lua的协同程序来完成生产者-消费者这一经典问题。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local newProductor</span><br><span class="line"></span><br><span class="line">function productor()</span><br><span class="line">     local i = 0</span><br><span class="line">     while true do</span><br><span class="line">          i = i + 1</span><br><span class="line">          send(i)     -- 将生产的物品发送给消费者</span><br><span class="line">     end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function consumer()</span><br><span class="line">     while true do</span><br><span class="line">          local i = receive()     -- 从生产者那里得到物品</span><br><span class="line">          print(i)</span><br><span class="line">     end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function receive()</span><br><span class="line">     local status, value = coroutine.resume(newProductor)</span><br><span class="line">     return value</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function send(x)</span><br><span class="line">     coroutine.yield(x)     -- x表示需要发送的值，值返回以后，就挂起该协同程序</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 启动程序</span><br><span class="line">newProductor = coroutine.create(productor)</span><br><span class="line">consumer()</span><br></pre></td></tr></table></figure>

<p>以上实例执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程和协同程序区别"><a href="#线程和协同程序区别" class="headerlink" title="线程和协同程序区别"></a>线程和协同程序区别</h2><p>线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。</p>
<p>在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<p>协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。</p>
<p>主要区别归纳如下：</p>
<ul>
<li>调度方式：线程通常由操作系统的调度器进行抢占式调度，操作系统会在不同线程之间切换执行权。而协同程序是非抢占式调度的，它们由程序员显式地控制执行权的转移。</li>
<li>并发性：线程是并发执行的，多个线程可以同时运行在多个处理器核心上，或者通过时间片轮转在单个核心上切换执行。协同程序则是协作式的，只有一个协同程序处于运行状态，其他协同程序必须等待当前协同程序主动放弃执行权。</li>
<li>内存占用：线程通常需要独立的堆栈和上下文环境，因此线程的创建和销毁会带来额外的开销。而协同程序可以共享相同的堆栈和上下文，因此创建和销毁协同程序的开销较小。</li>
<li>数据共享：线程之间可以共享内存空间，但需要注意线程安全性和同步问题。协同程序通常通过参数传递和返回值来进行数据共享，不同协同程序之间的数据隔离性较好。</li>
<li>调试和错误处理：线程通常在调试和错误处理方面更复杂，因为多个线程之间的交互和并发执行可能导致难以调试的问题。协同程序则在调试和错误处理方面相对简单，因为它们是由程序员显式地控制执行流程的。</li>
</ul>
<p>总体而言，线程适用于需要并发执行的场景，例如在多核处理器上利用并行性加快任务的执行速度。而协同程序适用于需要协作和协调的场景，例如状态机、事件驱动编程或协作式任务处理。选择使用线程还是协同程序取决于具体的应用需求和编程模型。</p>
<hr>
<h1 id="Lua-文件-I-O"><a href="#Lua-文件-I-O" class="headerlink" title="Lua 文件 I&#x2F;O"></a>Lua 文件 I&#x2F;O</h1><p>Lua I&#x2F;O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。</p>
<ul>
<li>简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li>
<li>完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法</li>
</ul>
<p>简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。</p>
<p>打开文件操作语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file = io.open (filename [, mode])</span><br></pre></td></tr></table></figure>

<p>mode 的值有：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">以可读写方式打开文件，该文件必须存在。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">与a类似，但此文件可读可写</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">二进制模式，如果文件是二进制文件，可以加上b</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">号表示对文件既可以读也可以写</td>
</tr>
</tbody></table>
<hr>
<h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><p>简单模式使用标准的 I&#x2F;O 或使用一个当前输入文件和一个当前输出文件。</p>
<p>以下为 file.lua 文件代码，操作的文件为test.lua(如果没有你需要创建该文件)，代码如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">-- 设置默认输入文件为 test.lua</span><br><span class="line">io.input(file)</span><br><span class="line"></span><br><span class="line">-- 输出文件第一行</span><br><span class="line">print(io.read())</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">io.close(file)</span><br><span class="line"></span><br><span class="line">-- 以附加的方式打开只写文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">-- 设置默认输出文件为 test.lua</span><br><span class="line">io.output(file)</span><br><span class="line"></span><br><span class="line">-- 在文件最后一行添加 Lua 注释</span><br><span class="line">io.write(&quot;--  test.lua 文件末尾注释&quot;)</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">io.close(file)</span><br></pre></td></tr></table></figure>

<p>执行以上代码，你会发现，输出了 test.lua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test.lua 文件</span><br></pre></td></tr></table></figure>

<p>在以上实例中我们使用了 io.”x” 方法，其中 io.read() 中我们没有带参数，参数可以是下表中的一个：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“*n”</td>
<td align="left">读取一个数字并返回它。例：file.read(“*n”)</td>
</tr>
<tr>
<td align="left">“*a”</td>
<td align="left">从当前位置读取整个文件。例：file.read(“*a”)</td>
</tr>
<tr>
<td align="left">“*l”（默认）</td>
<td align="left">读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read(“*l”)</td>
</tr>
<tr>
<td align="left">number</td>
<td align="left">返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)</td>
</tr>
</tbody></table>
<p>其他的 io 方法有：</p>
<ul>
<li>**io.tmpfile():**返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</li>
<li><strong>io.type(file):</strong> 检测obj是否一个可用的文件句柄</li>
<li><strong>io.flush():</strong> 向文件写入缓冲中的所有数据</li>
<li><strong>io.lines(optional file name):</strong> 返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，但不关闭文件。</li>
</ul>
<hr>
<h2 id="完全模式"><a href="#完全模式" class="headerlink" title="完全模式"></a>完全模式</h2><p>通常我们需要在同一时间处理多个文件。我们需要使用 file:function_name 来代替 io.function_name 方法。以下实例演示了如何同时处理同一个文件:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">-- 输出文件第一行</span><br><span class="line">print(file:read())</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br><span class="line"></span><br><span class="line">-- 以附加的方式打开只写文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;a&quot;)</span><br><span class="line"></span><br><span class="line">-- 在文件最后一行添加 Lua 注释</span><br><span class="line">file:write(&quot;--test&quot;)</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br></pre></td></tr></table></figure>

<p>执行以上代码，你会发现，输出了 test.lua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test.lua 文件</span><br></pre></td></tr></table></figure>

<p>read 的参数与简单模式一致。</p>
<p>其他方法:</p>
<ul>
<li><p><strong>file:seek(optional whence, optional offset):</strong> 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:</p>
<ul>
<li>“set”: 从文件头开始</li>
<li>“cur”: 从当前位置开始[默认]</li>
<li>“end”: 从文件尾开始</li>
<li>offset:默认为0</li>
</ul>
<p>不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</p>
</li>
<li><p><strong>file:flush():</strong> 向文件写入缓冲中的所有数据</p>
</li>
<li><p><strong>io.lines(optional file name):</strong> 打开指定的文件 filename 为读模式并返回一个迭代函数，每次调用将获得文件中的一行内容，当到文件尾时，将返回 nil，并自动关闭文件。<br>若不带参数时io.lines() &lt;&#x3D;&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for line in io.lines(&quot;main.lua&quot;) do</span><br><span class="line"></span><br><span class="line">　　print(line)</span><br><span class="line"></span><br><span class="line">　　end</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当前位置(倒数第 25 个位置)读取整个文件。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 以只读方式打开文件</span><br><span class="line">file = io.open(&quot;test.lua&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">file:seek(&quot;end&quot;,-25)</span><br><span class="line">print(file:read(&quot;*a&quot;))</span><br><span class="line"></span><br><span class="line">-- 关闭打开的文件</span><br><span class="line">file:close()</span><br></pre></td></tr></table></figure>

<p>我这边输出的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st.lua 文件末尾--test</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-错误处理"><a href="#Lua-错误处理" class="headerlink" title="Lua 错误处理"></a>Lua 错误处理</h1><p>程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。</p>
<p>任何程序语言中，都需要错误处理。错误类型有：</p>
<ul>
<li>语法错误</li>
<li>运行错误</li>
</ul>
<hr>
<h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- test.lua 文件</span><br><span class="line">a == 2</span><br></pre></td></tr></table></figure>

<p>以上代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua: test.lua:2: syntax error near &#x27;==&#x27;</span><br></pre></td></tr></table></figure>

<p>正如你所看到的，以上出现了语法错误，一个 “&#x3D;” 号跟两个 “&#x3D;” 号是有区别的。一个 “&#x3D;” 是赋值表达式两个 “&#x3D;” 是比较运算。</p>
<p>另外一个实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua: test2.lua:2: &#x27;do&#x27; expected near &#x27;print&#x27;</span><br></pre></td></tr></table></figure>

<p>语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">do</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h2><p>运行错误是程序可以正常执行，但是会输出报错信息。如下实例由于参数输入错误，程序执行时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a,b)</span><br><span class="line">   return a+b</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add(10)</span><br></pre></td></tr></table></figure>

<p>当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua: test2.lua:2: attempt to perform arithmetic on local &#x27;b&#x27; (a nil value)</span><br><span class="line">stack traceback:</span><br><span class="line">    test2.lua:2: in function &#x27;add&#x27;</span><br><span class="line">    test2.lua:5: in main chunk</span><br><span class="line">    [C]: ?</span><br></pre></td></tr></table></figure>

<p>lua 里调用函数时，即使实参列表和形参列表不一致也能成功调用，多余的参数会被舍弃，缺少的参数会被补为 nil。</p>
<p>以上报错信息是由于参数 b 被补为 nil 后，nil 参与了 + 运算。</p>
<p>假如 <strong>add</strong> 函数内不是 <strong>“return a+b”</strong> 而是 <strong>“print(a,b)”</strong> 的话，结果会变成 <strong>“10 nil”</strong> 不会报错。</p>
<hr>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>我们可以使用两个函数：assert 和 error 来处理错误。实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local function add(a,b)</span><br><span class="line">   assert(type(a) == &quot;number&quot;, &quot;a 不是一个数字&quot;)</span><br><span class="line">   assert(type(b) == &quot;number&quot;, &quot;b 不是一个数字&quot;)</span><br><span class="line">   return a+b</span><br><span class="line">end</span><br><span class="line">add(10)</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua: test.lua:3: b 不是一个数字</span><br><span class="line">stack traceback:</span><br><span class="line">    [C]: in function &#x27;assert&#x27;</span><br><span class="line">    test.lua:3: in local &#x27;add&#x27;</span><br><span class="line">    test.lua:6: in main chunk</span><br><span class="line">    [C]: in ?</span><br></pre></td></tr></table></figure>

<p>实例中assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出。</p>
<h3 id="error函数"><a href="#error函数" class="headerlink" title="error函数"></a>error函数</h3><p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error (message [, level])</span><br></pre></td></tr></table></figure>

<p>功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)</p>
<p>通常情况下，error会附加一些错误位置的信息到message头部。</p>
<p>Level参数指示获得错误的位置:</p>
<ul>
<li>Level&#x3D;1[默认]：为调用error位置(文件+行号)</li>
<li>Level&#x3D;2：指出哪个调用error的函数的函数</li>
<li>Level&#x3D;0:不添加错误位置信息</li>
</ul>
<hr>
<h2 id="pcall-和-xpcall、debug"><a href="#pcall-和-xpcall、debug" class="headerlink" title="pcall 和 xpcall、debug"></a>pcall 和 xpcall、debug</h2><p>Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。</p>
<p>pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；返回值true或者或false, errorinfo。</p>
<p>语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if pcall(function_name, ….) then</span><br><span class="line">-- 没有错误</span><br><span class="line">else</span><br><span class="line">-- 一些错误</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>简单实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; =pcall(function(i) print(i) end, 33)</span><br><span class="line">33</span><br><span class="line">true</span><br><span class="line">   </span><br><span class="line">&gt; =pcall(function(i) print(i) error(&#x27;error..&#x27;) end, 33)</span><br><span class="line">33</span><br><span class="line">false        stdin:1: error..</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; function f() return false,2 end</span><br><span class="line">&gt; if f() then print &#x27;1&#x27; else print &#x27;0&#x27; end</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>pcall以一种”保护模式”来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。</p>
<p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。</p>
<p>Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p>
<p>debug库提供了两个通用的错误处理函数:</p>
<ul>
<li>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</li>
<li>debug.traceback：根据调用桟来构建一个扩展的错误消息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;=xpcall(function(i) print(i) error(&#x27;error..&#x27;) end, function() print(debug.traceback()) end, 33)</span><br><span class="line">33</span><br><span class="line">stack traceback:</span><br><span class="line">stdin:1: in function &lt;stdin:1&gt;</span><br><span class="line">[C]: in function &#x27;error&#x27;</span><br><span class="line">stdin:1: in function &lt;stdin:1&gt;</span><br><span class="line">[C]: in function &#x27;xpcall&#x27;</span><br><span class="line">stdin:1: in main chunk</span><br><span class="line">[C]: in ?</span><br><span class="line">false        nil</span><br></pre></td></tr></table></figure>

<p>xpcall 使用实例 2:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myfunction ()</span><br><span class="line">   n = n/nil</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function myerrorhandler( err )</span><br><span class="line">   print( &quot;ERROR:&quot;, err )</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">status = xpcall( myfunction, myerrorhandler )</span><br><span class="line">print( status )</span><br></pre></td></tr></table></figure>

<p>执行以上程序会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR:    test2.lua:2: attempt to perform arithmetic on global &#x27;n&#x27; (a nil value)</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-调试-Debug"><a href="#Lua-调试-Debug" class="headerlink" title="Lua 调试(Debug)"></a>Lua 调试(Debug)</h1><p>Lua 提供了 debug 库用于提供创建我们自定义调试器的功能。Lua 本身并未有内置的调试器，但很多开发者共享了他们的 Lua 调试器代码。</p>
<p>Lua 中 debug 库包含以下函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.</td>
<td align="left">**debug():**进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 cont 的字符串将结束这个函数， 这样调用者就可以继续向下运行。</td>
</tr>
<tr>
<td align="left">2.</td>
<td align="left">**getfenv(object):**返回对象的环境变量。</td>
</tr>
<tr>
<td align="left">3.</td>
<td align="left">**gethook(optional thread):**返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数</td>
</tr>
<tr>
<td align="left">4.</td>
<td align="left">**getinfo ([thread,] f [, what]):**返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 f 表示该函数。 数字 f 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（getinfo 自身）； 1 层表示调用 getinfo 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 f 是一个比活动函数数量还大的数字， getinfo 返回 nil。</td>
</tr>
<tr>
<td align="left">5.</td>
<td align="left">**debug.getlocal ([thread,] f, local):**此函数返回在栈的 f 层处函数的索引为 local 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。</td>
</tr>
<tr>
<td align="left">6.</td>
<td align="left">**getmetatable(value):**把给定索引指向的值的元表压入堆栈。如果索引无效，或是这个值没有元表，函数将返回 0 并且不会向栈上压任何东西。</td>
</tr>
<tr>
<td align="left">7.</td>
<td align="left">**getregistry():**返回注册表表，这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。</td>
</tr>
<tr>
<td align="left">8.</td>
<td align="left">**getupvalue (f, up)**此函数返回函数 f 的第 up 个上值的名字和值。 如果该函数没有那个上值，返回 nil 。 以 ‘(‘ （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块）。</td>
</tr>
<tr>
<td align="left">10.</td>
<td align="left"><strong>sethook ([thread,] hook, mask [, count]):<strong>将一个函数作为钩子函数设入。 字符串 mask 以及数字 count 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义：</strong>‘<code>c</code>‘:</strong> 每当 Lua 调用一个函数时，调用钩子；**’<code>r</code>‘:** 每当 Lua 从一个函数内返回时，调用钩子；**’<code>l</code>‘:** 每当 Lua 进入新的一行时，调用钩子。</td>
</tr>
<tr>
<td align="left">11.</td>
<td align="left">**setlocal ([thread,] level, local, value):**这个函数将 value 赋给 栈上第 level 层函数的第 local 个局部变量。 如果没有那个变量，函数返回 nil 。 如果 level 越界，抛出一个错误。</td>
</tr>
<tr>
<td align="left">12.</td>
<td align="left">**setmetatable (value, table):**将 value 的元表设为 table （可以是 nil）。 返回 value。</td>
</tr>
<tr>
<td align="left">13.</td>
<td align="left">**setupvalue (f, up, value):**这个函数将 value 设为函数 f 的第 up 个上值。 如果函数没有那个上值，返回 nil 否则，返回该上值的名字。</td>
</tr>
<tr>
<td align="left">14.</td>
<td align="left">**traceback ([thread,] [message [, level]]):**如果 message 有，且不是字符串或 nil， 函数不做任何处理直接返回 message。 否则，它返回调用栈的栈回溯信息。 字符串可选项 message 被添加在栈回溯信息的开头。 数字可选项 level 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 traceback 的那里）。</td>
</tr>
</tbody></table>
<p>上表列出了我们常用的调试函数，接下来我们可以看些简单的例子：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myfunction ()</span><br><span class="line">print(debug.traceback(&quot;Stack trace&quot;))</span><br><span class="line">print(debug.getinfo(1))</span><br><span class="line">print(&quot;Stack trace end&quot;)</span><br><span class="line">        return 10</span><br><span class="line">end</span><br><span class="line">myfunction ()</span><br><span class="line">print(debug.getinfo(1))</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack trace</span><br><span class="line">stack traceback:</span><br><span class="line">    test2.lua:2: in function &#x27;myfunction&#x27;</span><br><span class="line">    test2.lua:8: in main chunk</span><br><span class="line">    [C]: ?</span><br><span class="line">table: 0054C6C8</span><br><span class="line">Stack trace end</span><br></pre></td></tr></table></figure>

<p>在以实例中，我们使用到了 debug 库的 traceback 和 getinfo 函数， getinfo 函数用于返回函数信息的表。</p>
<p><strong>另一个实例</strong></p>
<p>我们经常需要调试函数的内的局部变量。我们可以使用 setupvalue 函数来设置这些局部变量。实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function newCounter ()</span><br><span class="line">  local n = 0</span><br><span class="line">  local k = 0</span><br><span class="line">  return function ()</span><br><span class="line">    k = n</span><br><span class="line">    n = n + 1</span><br><span class="line">    return n</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">counter = newCounter ()</span><br><span class="line">print(counter())</span><br><span class="line">print(counter())</span><br><span class="line"></span><br><span class="line">local i = 1</span><br><span class="line"></span><br><span class="line">repeat</span><br><span class="line">  name, val = debug.getupvalue(counter, i)</span><br><span class="line">  if name then</span><br><span class="line">    print (&quot;index&quot;, i, name, &quot;=&quot;, val)</span><br><span class="line">        if(name == &quot;n&quot;) then</span><br><span class="line">                debug.setupvalue (counter,2,10)</span><br><span class="line">        end</span><br><span class="line">    i = i + 1</span><br><span class="line">  end -- if</span><br><span class="line">until not name</span><br><span class="line"></span><br><span class="line">print(counter())</span><br></pre></td></tr></table></figure>

<p>执行以上代码输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">index    1    k    =    1</span><br><span class="line">index    2    n    =    2</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>在以上实例中，计数器在每次调用时都会自增1。实例中我们使用了 getupvalue 函数查看局部变量的当前状态。我们可以设置局部变量为新值。实例中，在设置前 n 的值为 2,使用 setupvalue 函数将其设置为 10。现在我们调用函数，执行后输出为 11 而不是 3。</p>
<hr>
<h2 id="调试类型"><a href="#调试类型" class="headerlink" title="调试类型"></a>调试类型</h2><ul>
<li>命令行调试</li>
<li>图形界面调试</li>
</ul>
<p>命令行调试器有：RemDebug、clidebugger、ctrace、xdbLua、LuaInterface - Debugger、Rldb、ModDebug。</p>
<p>图形界调试器有：SciTE、Decoda、ZeroBrane Studio、akdebugger、luaedit。</p>
<hr>
<h1 id="Lua-垃圾回收"><a href="#Lua-垃圾回收" class="headerlink" title="Lua 垃圾回收"></a>Lua 垃圾回收</h1><p>Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。</p>
<p>Lua 运行了一个<strong>垃圾收集器</strong>来收集所有<strong>死对象</strong> （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。</p>
<p>Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率和垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。</p>
<p>垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。</p>
<p>垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的”两倍”速工作。</p>
<p>如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。</p>
<hr>
<h2 id="垃圾回收器函数"><a href="#垃圾回收器函数" class="headerlink" title="垃圾回收器函数"></a>垃圾回收器函数</h2><p>Lua 提供了以下函数**collectgarbage ([opt [, arg]])**用来控制自动内存管理:</p>
<ul>
<li><strong>collectgarbage(“collect”):</strong> 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能：</li>
<li><strong>collectgarbage(“count”):</strong> 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。</li>
<li><strong>collectgarbage(“restart”):</strong> 重启垃圾收集器的自动运行。</li>
<li><strong>collectgarbage(“setpause”):</strong> 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。</li>
<li><strong>collectgarbage(“setstepmul”):</strong> 返回 步进倍率 的前一个值。</li>
<li><strong>collectgarbage(“step”):</strong> 单步运行垃圾收集器。 步长”大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。</li>
<li><strong>collectgarbage(“stop”):</strong> 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。</li>
</ul>
<p>以下演示了一个简单的垃圾回收实例:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mytable = &#123;&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&#125;</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br><span class="line"></span><br><span class="line">mytable = nil</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;collect&quot;))</span><br><span class="line"></span><br><span class="line">print(collectgarbage(&quot;count&quot;))</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下(注意内存使用的变化)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20.9560546875</span><br><span class="line">20.9853515625</span><br><span class="line">0</span><br><span class="line">19.4111328125</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-面向对象"><a href="#Lua-面向对象" class="headerlink" title="Lua 面向对象"></a>Lua 面向对象</h1><p>面向对象编程（Object Oriented Programming，OOP）是一种非常流行的计算机编程架构。</p>
<p>以下几种编程语言都支持面向对象编程：</p>
<ul>
<li>C++</li>
<li>Java</li>
<li>Objective-C</li>
<li>Smalltalk</li>
<li>C#</li>
<li>Ruby</li>
</ul>
<hr>
<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><ul>
<li>1） 封装：指能够把一个实体的信息、功能、响应都装入一个单独的对象中的特性。</li>
<li>2） 继承：继承的方法允许在不改动原程序的基础上对其进行扩充，这样使得原功能得以保存，而新功能也得以扩展。这有利于减少重复编码，提高软件的开发效率。</li>
<li>3） 多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。</li>
<li>4）抽象：抽象(Abstraction)是简化复杂的现实问题的途径，它可以为具体问题找到最恰当的类定义，并且可以在最恰当的继承级别解释问题。</li>
</ul>
<hr>
<h2 id="Lua-中面向对象"><a href="#Lua-中面向对象" class="headerlink" title="Lua 中面向对象"></a>Lua 中面向对象</h2><p>我们知道，对象由属性和方法组成。LUA中最基本的结构是table，所以需要用table来描述对象的属性。</p>
<p>lua 中的 function 可以用来表示方法。那么LUA中的类可以通过 table + function 模拟出来。</p>
<p>至于继承，可以通过 metetable 模拟出来（不推荐用，只模拟最基本的对象大部分实现够用了）。</p>
<p>Lua 中的表不仅在某种意义上是一种对象。像对象一样，表也有状态（成员变量）；也有与对象的值独立的本性，特别是拥有两个不同值的对象（table）代表两个不同的对象；一个对象在不同的时候也可以有不同的值，但他始终是一个对象；与对象类似，表的生命周期与其由什么创建、在哪创建没有关系。对象有他们的成员函数，表也有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Account = &#123;balance = 0&#125;</span><br><span class="line">function Account.withdraw (v)</span><br><span class="line">    Account.balance = Account.balance - v</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这个定义创建了一个新的函数，并且保存在Account对象的withdraw域内，下面我们可以这样调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Account.withdraw(100.00)</span><br></pre></td></tr></table></figure>

<h3 id="一个简单实例"><a href="#一个简单实例" class="headerlink" title="一个简单实例"></a>一个简单实例</h3><p>以下简单的类包含了三个属性： area, length 和 breadth，printArea方法用于打印计算结果：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 元类</span><br><span class="line">Rectangle = &#123;area = 0, length = 0, breadth = 0&#125;</span><br><span class="line"></span><br><span class="line">-- 派生类的方法 new</span><br><span class="line">function Rectangle:new (o,length,breadth)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  self.length = length or 0</span><br><span class="line">  self.breadth = breadth or 0</span><br><span class="line">  self.area = length*breadth;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类的方法 printArea</span><br><span class="line">function Rectangle:printArea ()</span><br><span class="line">  print(&quot;矩形面积为 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象是为类的实例分配内存的过程。每个类都有属于自己的内存并共享公共数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r = Rectangle:new(nil,10,20)</span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>我们可以使用点号(.)来访问类的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(r.length)</span><br></pre></td></tr></table></figure>

<h3 id="访问成员函数"><a href="#访问成员函数" class="headerlink" title="访问成员函数"></a>访问成员函数</h3><p>我们可以使用冒号 <strong>:</strong> 来访问类的成员函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r:printArea()</span><br></pre></td></tr></table></figure>

<p>内存在对象初始化时分配。</p>
<h3 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h3><p>以下我们演示了 Lua 面向对象的完整实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 元类</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line"></span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line"></span><br><span class="line">myshape:printArea()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面积为     100</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lua-继承"><a href="#Lua-继承" class="headerlink" title="Lua 继承"></a>Lua 继承</h2><p>继承是指一个对象直接使用另一对象的属性和方法。可用于扩展基础类的属性和方法。</p>
<p>以下演示了一个简单的继承实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Meta class</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>接下来的实例，Square 对象继承了 Shape 类:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Square = Shape:new()</span><br><span class="line">-- Derived class method new</span><br><span class="line">function Square:new (o,side)</span><br><span class="line">  o = o or Shape:new(o,side)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  return o</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="完整实例-1"><a href="#完整实例-1" class="headerlink" title="完整实例"></a>完整实例</h3><p>以下实例我们继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Meta class</span><br><span class="line">Shape = &#123;area = 0&#125;</span><br><span class="line">-- 基础类方法 new</span><br><span class="line">function Shape:new (o,side)</span><br><span class="line">  o = o or &#123;&#125;</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  side = side or 0</span><br><span class="line">  self.area = side*side;</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line">-- 基础类方法 printArea</span><br><span class="line">function Shape:printArea ()</span><br><span class="line">  print(&quot;面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myshape = Shape:new(nil,10)</span><br><span class="line">myshape:printArea()</span><br><span class="line"></span><br><span class="line">Square = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Square:new (o,side)</span><br><span class="line">  o = o or Shape:new(o,side)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Square:printArea ()</span><br><span class="line">  print(&quot;正方形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">mysquare = Square:new(nil,10)</span><br><span class="line">mysquare:printArea()</span><br><span class="line"></span><br><span class="line">Rectangle = Shape:new()</span><br><span class="line">-- 派生类方法 new</span><br><span class="line">function Rectangle:new (o,length,breadth)</span><br><span class="line">  o = o or Shape:new(o)</span><br><span class="line">  setmetatable(o, self)</span><br><span class="line">  self.__index = self</span><br><span class="line">  self.area = length * breadth</span><br><span class="line">  return o</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Rectangle:printArea ()</span><br><span class="line">  print(&quot;矩形面积为 &quot;,self.area)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 创建对象</span><br><span class="line">myrectangle = Rectangle:new(nil,10,20)</span><br><span class="line">myrectangle:printArea()</span><br></pre></td></tr></table></figure>

<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面积为     100</span><br><span class="line">正方形面积为     100</span><br><span class="line">矩形面积为     200</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p>Lua 中我们可以重写基础类的函数，在派生类中定义自己的实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 派生类方法 printArea</span><br><span class="line">function Square:printArea ()</span><br><span class="line">  print(&quot;正方形面积 &quot;,self.area)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Lua-数据库访问"><a href="#Lua-数据库访问" class="headerlink" title="Lua 数据库访问"></a>Lua 数据库访问</h1><p>本文主要为大家介绍 Lua 数据库的操作库：<a href="http://luaforge.net/projects/luasql/">LuaSQL</a>。他是开源的，支持的数据库有：ODBC, ADO, Oracle, MySQL, SQLite 和 PostgreSQL。</p>
<p>本文为大家介绍MySQL的数据库连接。</p>
<p>LuaSQL 可以使用 <a href="https://luarocks.org/">LuaRocks</a> 来安装可以根据需要安装你需要的数据库驱动。</p>
<p>LuaRocks 安装方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz</span><br><span class="line">$ tar zxpf luarocks-2.2.1.tar.gz</span><br><span class="line">$ cd luarocks-2.2.1</span><br><span class="line">$ ./configure; sudo make bootstrap</span><br><span class="line">$ sudo luarocks install luasocket</span><br><span class="line">$ lua</span><br><span class="line">Lua 5.3.0 Copyright (C) 1994-2015 Lua.org, PUC-Rio</span><br><span class="line">&gt; require &quot;socket&quot;</span><br></pre></td></tr></table></figure>

<p>Window 下安装 LuaRocks：<a href="https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows">https://github.com/keplerproject/luarocks/wiki/Installation-instructions-for-Windows</a></p>
<p>安装不同数据库驱动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">luarocks install luasql-sqlite3</span><br><span class="line">luarocks install luasql-postgres</span><br><span class="line">luarocks install luasql-mysql</span><br><span class="line">luarocks install luasql-sqlite</span><br><span class="line">luarocks install luasql-odbc</span><br></pre></td></tr></table></figure>

<p>你也可以使用源码安装方式，Lua Github 源码地址：<a href="https://github.com/keplerproject/luasql">https://github.com/keplerproject/luasql</a></p>
<p>Lua 连接MySql 数据库：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require &quot;luasql.mysql&quot;</span><br><span class="line"></span><br><span class="line">--创建环境对象</span><br><span class="line">env = luasql.mysql()</span><br><span class="line"></span><br><span class="line">--连接数据库</span><br><span class="line">conn = env:connect(&quot;数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;IP地址&quot;,端口)</span><br><span class="line"></span><br><span class="line">--设置数据库的编码格式</span><br><span class="line">conn:execute&quot;SET NAMES UTF8&quot;</span><br><span class="line"></span><br><span class="line">--执行数据库操作</span><br><span class="line">cur = conn:execute(&quot;select * from role&quot;)</span><br><span class="line"></span><br><span class="line">row = cur:fetch(&#123;&#125;,&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">--文件对象的创建</span><br><span class="line">file = io.open(&quot;role.txt&quot;,&quot;w+&quot;);</span><br><span class="line"></span><br><span class="line">while row do</span><br><span class="line">    var = string.format(&quot;%d %s\n&quot;, row.id, row.name)</span><br><span class="line"></span><br><span class="line">    print(var)</span><br><span class="line"></span><br><span class="line">    file:write(var)</span><br><span class="line"></span><br><span class="line">    row = cur:fetch(row,&quot;a&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file:close()  --关闭文件对象</span><br><span class="line">conn:close()  --关闭数据库连接</span><br><span class="line">env:close()   --关闭数据库环境</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
  </entry>
  <entry>
    <title>Typora快速设置文字颜色</title>
    <url>/2023/05/01/Typora%E5%BF%AB%E9%80%9F%E8%AE%BE%E7%BD%AE%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h2 id="先安装AutoHotKey"><a href="#先安装AutoHotKey" class="headerlink" title="先安装AutoHotKey"></a>先安装AutoHotKey</h2><span id="more"></span>

<p><a href="https://autohotkey.com/download/">官方下载</a></p>
<p><a href="https://www.123pan.com/s/k79SVv-tNzJ.html">网盘</a></p>
<h2 id="打开记事本，把如下内容复制粘贴进去："><a href="#打开记事本，把如下内容复制粘贴进去：" class="headerlink" title="打开记事本，把如下内容复制粘贴进去："></a>打开记事本，把如下内容复制粘贴进去：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; Typora</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">; SendInput &#123;Text&#125; 解决中文输入法问题</span><br><span class="line">#IfWinActive ahk_exe Typora.exe</span><br><span class="line">&#123;</span><br><span class="line">    ; Ctrl+Alt+O 橙色</span><br><span class="line">    ^!o::addFontColor(&quot;orange&quot;)</span><br><span class="line">    ; Ctrl+Alt+R 红色</span><br><span class="line">    ^!r::addFontColor(&quot;red&quot;)</span><br><span class="line">    ; Ctrl+Alt+B 浅蓝色</span><br><span class="line">    ^!b::addFontColor(&quot;cornflowerblue&quot;)</span><br><span class="line">&#125;</span><br><span class="line">; 快捷增加字体颜色</span><br><span class="line">addFontColor(color)&#123;</span><br><span class="line">    clipboard := &quot;&quot; ; 清空剪切板</span><br><span class="line">    Send &#123;ctrl down&#125;c&#123;ctrl up&#125; ; 复制</span><br><span class="line">    SendInput &#123;TEXT&#125;&lt;font color=&#x27;%color%&#x27;&gt;</span><br><span class="line">    SendInput &#123;ctrl down&#125;v&#123;ctrl up&#125; ; 粘贴</span><br><span class="line">    If(clipboard = &quot;&quot;)&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;/font&gt; ; Typora 在这不会自动补充</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        SendInput &#123;TEXT&#125;&lt;/ ; Typora中自动补全标签</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="将文件保存为ahk后缀的文件"><a href="#将文件保存为ahk后缀的文件" class="headerlink" title="将文件保存为ahk后缀的文件"></a>将文件保存为ahk后缀的文件</h2><p>如<code>TyporaHotKey.ahk</code></p>
<h2 id="双击运行"><a href="#双击运行" class="headerlink" title="双击运行"></a>双击运行</h2><h2 id="在Typora软件里就可以使用快捷键："><a href="#在Typora软件里就可以使用快捷键：" class="headerlink" title="在Typora软件里就可以使用快捷键："></a>在Typora软件里就可以使用快捷键：</h2><p>如按<code>Ctrl+Alt+O</code>添加橙色，<code>Ctrl+Alt+R</code> 红色，按<code>Ctrl+\</code>取消样式！</p>
<p>也可以右键 <code>MyHotkeyScript.ahk</code> 脚本文件，点击<code>Compile Script</code>编译脚本成exe程序，就可以不用下载<code>Autohotkey</code>在其他电脑上运行了。</p>
<p>上面脚本只写了橙色、红色、浅蓝三种颜色，你可以按需照例增加其他颜色或快捷方式！</p>
<h2 id="加入到开机自启动"><a href="#加入到开机自启动" class="headerlink" title="加入到开机自启动"></a>加入到开机自启动</h2>]]></content>
  </entry>
  <entry>
    <title>Word文档转Markdown</title>
    <url>/2023/04/09/Word%E6%96%87%E6%A1%A3%E8%BD%ACMarkdown/</url>
    <content><![CDATA[<p><a href="https://www.123pan.com/s/k79SVv-PGzJ.html">下载链接</a></p>
<span id="more"></span>

<ol>
<li><p>安装软件</p>
</li>
<li><p>切换到word文件所在目录，打开命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pandoc -f docx -t markdown --extract-media ./ -o output.md input.docx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-f docx：指定源文件为 docx 格式（from）<br>-t markdown：指定我们要转为 md 格式（to）<br>–extract-media .&#x2F;：将图片文件导出到目录 .&#x2F;<br>-o output.md：表示输出的文件名为 output.md（output）<br>input.docx：表示要转换的文件为 input.docx</p>
</blockquote>
</li>
<li><p>详细信息请阅读官方文档</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Python3运算符</title>
    <url>/2023/06/03/Python3%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-运算符"><a href="#Python3-运算符" class="headerlink" title="Python3 运算符"></a>Python3 运算符</h1><hr>
<h2 id="什么是运算符？"><a href="#什么是运算符？" class="headerlink" title="什么是运算符？"></a>什么是运算符？</h2><p>本章节主要说明 Python 的运算符。</p>
<p>举个简单的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 + 5 = 9</span><br></pre></td></tr></table></figure>

<p>例子中，<strong>4</strong> 和 <strong>5</strong> 被称为<strong>操作数</strong>，**+** 称为<strong>运算符</strong>。</p>
<p>Python 语言支持以下类型的运算符:</p>
<ul>
<li>算术运算符</li>
<li>比较（关系）运算符</li>
<li>赋值运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>成员运算符</li>
<li>身份运算符</li>
<li>运算符优先级</li>
</ul>
<p>接下来让我们一个个来学习Python的运算符。</p>
<hr>
<h2 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h2><p>以下假设变量 <strong>a&#x3D;10</strong>，变量 <strong>b&#x3D;21</strong>：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加 - 两个对象相加</td>
<td align="left">a + b 输出结果 31</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减 - 得到负数或是一个数减去另一个数</td>
<td align="left">a - b 输出结果 -11</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td align="left">a * b 输出结果 210</td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除 - x 除以 y</td>
<td align="left">b &#x2F; a 输出结果 2.1</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取模 - 返回除法的余数</td>
<td align="left">b % a 输出结果 1</td>
</tr>
<tr>
<td align="left">**</td>
<td align="left">幂 - 返回x的y次幂</td>
<td align="left">a**b 为10的21次方</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;</td>
<td align="left">取整除 - 往小的方向取整数</td>
<td align="left"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有算术运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line">c = 0</span><br><span class="line"> </span><br><span class="line">c = a + b</span><br><span class="line">print (&quot;1 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a - b</span><br><span class="line">print (&quot;2 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a * b</span><br><span class="line">print (&quot;3 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a / b</span><br><span class="line">print (&quot;4 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a % b</span><br><span class="line">print (&quot;5 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line"># 修改变量 a 、b 、c</span><br><span class="line">a = 2</span><br><span class="line">b = 3</span><br><span class="line">c = a**b </span><br><span class="line">print (&quot;6 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line">b = 5</span><br><span class="line">c = a//b </span><br><span class="line">print (&quot;7 - c 的值为：&quot;, c)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - c 的值为： 31</span><br><span class="line">2 - c 的值为： 11</span><br><span class="line">3 - c 的值为： 210</span><br><span class="line">4 - c 的值为： 2.1</span><br><span class="line">5 - c 的值为： 1</span><br><span class="line">6 - c 的值为： 8</span><br><span class="line">7 - c 的值为： 2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">等于 - 比较对象是否相等</td>
<td align="left">(a &#x3D;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">不等于 - 比较两个对象是否不相等</td>
<td align="left">(a !&#x3D; b) 返回 True。</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于 - 返回x是否大于y</td>
<td align="left">(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td align="left">(a &lt; b) 返回 True。</td>
</tr>
<tr>
<td align="left">&gt;&#x3D;</td>
<td align="left">大于等于 - 返回x是否大于等于y。</td>
<td align="left">(a &gt;&#x3D; b) 返回 False。</td>
</tr>
<tr>
<td align="left">&lt;&#x3D;</td>
<td align="left">小于等于 - 返回x是否小于等于y。</td>
<td align="left">(a &lt;&#x3D; b) 返回 True。</td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有比较运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line">c = 0</span><br><span class="line"> </span><br><span class="line">if ( a == b ):</span><br><span class="line">   print (&quot;1 - a 等于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;1 - a 不等于 b&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a != b ):</span><br><span class="line">   print (&quot;2 - a 不等于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;2 - a 等于 b&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a &lt; b ):</span><br><span class="line">   print (&quot;3 - a 小于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;3 - a 大于等于 b&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a &gt; b ):</span><br><span class="line">   print (&quot;4 - a 大于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;4 - a 小于等于 b&quot;)</span><br><span class="line"> </span><br><span class="line"># 修改变量 a 和 b 的值</span><br><span class="line">a = 5</span><br><span class="line">b = 20</span><br><span class="line">if ( a &lt;= b ):</span><br><span class="line">   print (&quot;5 - a 小于等于 b&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;5 - a 大于  b&quot;)</span><br><span class="line"> </span><br><span class="line">if ( b &gt;= a ):</span><br><span class="line">   print (&quot;6 - b 大于等于 a&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;6 - b 小于 a&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - a 不等于 b</span><br><span class="line">2 - a 不等于 b</span><br><span class="line">3 - a 大于等于 b</span><br><span class="line">4 - a 大于 b</span><br><span class="line">5 - a 小于等于 b</span><br><span class="line">6 - b 大于等于 a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h2><p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#x3D;</td>
<td align="left">简单的赋值运算符</td>
<td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td align="left">+&#x3D;</td>
<td align="left">加法赋值运算符</td>
<td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td>
</tr>
<tr>
<td align="left">-&#x3D;</td>
<td align="left">减法赋值运算符</td>
<td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td>
</tr>
<tr>
<td align="left">*&#x3D;</td>
<td align="left">乘法赋值运算符</td>
<td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td>
</tr>
<tr>
<td align="left">&#x2F;&#x3D;</td>
<td align="left">除法赋值运算符</td>
<td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td>
</tr>
<tr>
<td align="left">%&#x3D;</td>
<td align="left">取模赋值运算符</td>
<td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td>
</tr>
<tr>
<td align="left">**&#x3D;</td>
<td align="left">幂赋值运算符</td>
<td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td>
</tr>
<tr>
<td align="left">&#x2F;&#x2F;&#x3D;</td>
<td align="left">取整除赋值运算符</td>
<td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td>
</tr>
<tr>
<td align="left">:&#x3D;</td>
<td align="left">海象运算符，可在表达式内部为变量赋值。<strong>Python3.8 版本新增运算符</strong>。</td>
<td align="left">在这个示例中，赋值表达式可以避免调用 len() 两次:<code>if (n := len(a)) &gt; 10:    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;= 10)&quot;)</code></td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有赋值运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 21</span><br><span class="line">b = 10</span><br><span class="line">c = 0</span><br><span class="line"> </span><br><span class="line">c = a + b</span><br><span class="line">print (&quot;1 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c += a</span><br><span class="line">print (&quot;2 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c *= a</span><br><span class="line">print (&quot;3 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c /= a </span><br><span class="line">print (&quot;4 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = 2</span><br><span class="line">c %= a</span><br><span class="line">print (&quot;5 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c **= a</span><br><span class="line">print (&quot;6 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c //= a</span><br><span class="line">print (&quot;7 - c 的值为：&quot;, c)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - c 的值为： 31</span><br><span class="line">2 - c 的值为： 52</span><br><span class="line">3 - c 的值为： 1092</span><br><span class="line">4 - c 的值为： 52.0</span><br><span class="line">5 - c 的值为： 2</span><br><span class="line">6 - c 的值为： 2097152</span><br><span class="line">7 - c 的值为： 99864</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p>
<p>下表中变量 a 为 60，b 为 13二进制格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 0011 1100</span><br><span class="line"></span><br><span class="line">b = 0000 1101</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = 0000 1100</span><br><span class="line"></span><br><span class="line">a|b = 0011 1101</span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = 1100 0011</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;</td>
<td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td align="left">~</td>
<td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 <strong>-x-1</strong></td>
<td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td align="left">&lt;&lt;</td>
<td align="left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td align="left">&gt;&gt;</td>
<td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有位运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 60            # 60 = 0011 1100 </span><br><span class="line">b = 13            # 13 = 0000 1101 </span><br><span class="line">c = 0</span><br><span class="line"> </span><br><span class="line">c = a &amp; b        # 12 = 0000 1100</span><br><span class="line">print (&quot;1 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a | b        # 61 = 0011 1101 </span><br><span class="line">print (&quot;2 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a ^ b        # 49 = 0011 0001</span><br><span class="line">print (&quot;3 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = ~a           # -61 = 1100 0011</span><br><span class="line">print (&quot;4 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a &lt;&lt; 2       # 240 = 1111 0000</span><br><span class="line">print (&quot;5 - c 的值为：&quot;, c)</span><br><span class="line"> </span><br><span class="line">c = a &gt;&gt; 2       # 15 = 0000 1111</span><br><span class="line">print (&quot;6 - c 的值为：&quot;, c)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - c 的值为： 12</span><br><span class="line">2 - c 的值为： 61</span><br><span class="line">3 - c 的值为： 49</span><br><span class="line">4 - c 的值为： -61</span><br><span class="line">5 - c 的值为： 240</span><br><span class="line">6 - c 的值为： 15</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">逻辑表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">and</td>
<td align="left">x and y</td>
<td align="left">布尔”与” - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td>
<td align="left">(a and b) 返回 20。</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">x or y</td>
<td align="left">布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td>
<td align="left">(a or b) 返回 10。</td>
</tr>
<tr>
<td align="left">not</td>
<td align="left">not x</td>
<td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td align="left">not(a and b) 返回 False</td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有逻辑运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"> </span><br><span class="line">if ( a and b ):</span><br><span class="line">   print (&quot;1 - 变量 a 和 b 都为 true&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;1 - 变量 a 和 b 有一个不为 true&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a or b ):</span><br><span class="line">   print (&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;2 - 变量 a 和 b 都不为 true&quot;)</span><br><span class="line"> </span><br><span class="line"># 修改变量 a 的值</span><br><span class="line">a = 0</span><br><span class="line">if ( a and b ):</span><br><span class="line">   print (&quot;3 - 变量 a 和 b 都为 true&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;3 - 变量 a 和 b 有一个不为 true&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a or b ):</span><br><span class="line">   print (&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;4 - 变量 a 和 b 都不为 true&quot;)</span><br><span class="line"> </span><br><span class="line">if not( a and b ):</span><br><span class="line">   print (&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;5 - 变量 a 和 b 都为 true&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - 变量 a 和 b 都为 true</span><br><span class="line">2 - 变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">3 - 变量 a 和 b 有一个不为 true</span><br><span class="line">4 - 变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">5 - 变量 a 和 b 都为 false，或其中一个变量为 false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">in</td>
<td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td align="left">not in</td>
<td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有成员运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line">list = [1, 2, 3, 4, 5 ]</span><br><span class="line"> </span><br><span class="line">if ( a in list ):</span><br><span class="line">   print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)</span><br><span class="line"> </span><br><span class="line">if ( b not in list ):</span><br><span class="line">   print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)</span><br><span class="line"> </span><br><span class="line"># 修改变量 a 的值</span><br><span class="line">a = 2</span><br><span class="line">if ( a in list ):</span><br><span class="line">   print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - 变量 a 不在给定的列表中 list 中</span><br><span class="line">2 - 变量 b 不在给定的列表中 list 中</span><br><span class="line">3 - 变量 a 在给定的列表中 list 中</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">is</td>
<td align="left">is 是判断两个标识符是不是引用自一个对象</td>
<td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td align="left">is not</td>
<td align="left">is not 是判断两个标识符是不是引用自不同对象</td>
<td align="left"><strong>x is not y</strong> ， 类似 **id(x) !&#x3D; id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody></table>
<p><strong>注：</strong> <code>id()</code>函数用于获取对象内存地址。</p>
<p>以下实例演示了Python所有身份运算符的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 20</span><br><span class="line"> </span><br><span class="line">if ( a is b ):</span><br><span class="line">   print (&quot;1 - a 和 b 有相同的标识&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;1 - a 和 b 没有相同的标识&quot;)</span><br><span class="line"> </span><br><span class="line">if ( id(a) == id(b) ):</span><br><span class="line">   print (&quot;2 - a 和 b 有相同的标识&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;2 - a 和 b 没有相同的标识&quot;)</span><br><span class="line"> </span><br><span class="line"># 修改变量 b 的值</span><br><span class="line">b = 30</span><br><span class="line">if ( a is b ):</span><br><span class="line">   print (&quot;3 - a 和 b 有相同的标识&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;3 - a 和 b 没有相同的标识&quot;)</span><br><span class="line"> </span><br><span class="line">if ( a is not b ):</span><br><span class="line">   print (&quot;4 - a 和 b 没有相同的标识&quot;)</span><br><span class="line">else:</span><br><span class="line">   print (&quot;4 - a 和 b 有相同的标识&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - a 和 b 有相同的标识</span><br><span class="line">2 - a 和 b 有相同的标识</span><br><span class="line">3 - a 和 b 没有相同的标识</span><br><span class="line">4 - a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure>

<blockquote>
<p>is 与 &#x3D;&#x3D; 区别：</p>
<p>is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p>
<p>&gt;&gt;&gt;a &#x3D; [1, 2, 3] &gt;&gt;&gt; b &#x3D; a &gt;&gt;&gt; b is a  True &gt;&gt;&gt; b &#x3D;&#x3D; a True &gt;&gt;&gt; b &#x3D; a[:] &gt;&gt;&gt; b is a False &gt;&gt;&gt; b &#x3D;&#x3D; a True</p>
</blockquote>
<hr>
<h2 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符， 相同单元格内的运算符具有相同优先级。 运算符均指二元运算，除非特别指出。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>(expressions...)</code>,<code>[expressions...]</code>, <code>&#123;key: value...&#125;</code>, <code>&#123;expressions...&#125;</code></td>
<td align="left">圆括号的表达式</td>
</tr>
<tr>
<td align="left"><code>x[index]</code>, <code>x[index:index]</code>, <code>x(arguments...)</code>, <code>x.attribute</code></td>
<td align="left">读取，切片，调用，属性引用</td>
</tr>
<tr>
<td align="left">await x</td>
<td align="left">await 表达式</td>
</tr>
<tr>
<td align="left"><code>**</code></td>
<td align="left">乘方(指数)</td>
</tr>
<tr>
<td align="left"><code>+x</code>, <code>-x</code>, <code>~x</code></td>
<td align="left">正，负，按位非 NOT</td>
</tr>
<tr>
<td align="left"><code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
<td align="left">乘，矩阵乘，除，整除，取余</td>
</tr>
<tr>
<td align="left"><code>+</code>, <code>-</code></td>
<td align="left">加和减</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td align="left">移位</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="left">按位与 AND</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left">按位异或 XOR</td>
</tr>
<tr>
<td align="left">&#96;</td>
<td align="left">&#96;</td>
</tr>
<tr>
<td align="left"><code>in,not in, is,is not, &lt;, &lt;=, &gt;, &gt;=, !=, ==</code></td>
<td align="left">比较运算，包括成员检测和标识号检测</td>
</tr>
<tr>
<td align="left"><code>not x</code></td>
<td align="left">逻辑非 NOT</td>
</tr>
<tr>
<td align="left"><code>and</code></td>
<td align="left">逻辑与 AND</td>
</tr>
<tr>
<td align="left"><code>or</code></td>
<td align="left">逻辑或 OR</td>
</tr>
<tr>
<td align="left"><code>if -- else</code></td>
<td align="left">条件表达式</td>
</tr>
<tr>
<td align="left"><code>lambda</code></td>
<td align="left">lambda 表达式</td>
</tr>
<tr>
<td align="left"><code>:=</code></td>
<td align="left">赋值表达式</td>
</tr>
</tbody></table>
<p>以下实例演示了Python所有运算符优先级的操作：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">c = 15</span><br><span class="line">d = 5</span><br><span class="line">e = 0</span><br><span class="line"> </span><br><span class="line">e = (a + b) * c / d       #( 30 * 15 ) / 5</span><br><span class="line">print (&quot;(a + b) * c / d 运算结果为：&quot;,  e)</span><br><span class="line"> </span><br><span class="line">e = ((a + b) * c) / d     # (30 * 15 ) / 5</span><br><span class="line">print (&quot;((a + b) * c) / d 运算结果为：&quot;,  e)</span><br><span class="line"> </span><br><span class="line">e = (a + b) * (c / d)    # (30) * (15/5)</span><br><span class="line">print (&quot;(a + b) * (c / d) 运算结果为：&quot;,  e)</span><br><span class="line"> </span><br><span class="line">e = a + (b * c) / d      #  20 + (150/5)</span><br><span class="line">print (&quot;a + (b * c) / d 运算结果为：&quot;,  e)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a + b) * c / d 运算结果为： 90.0</span><br><span class="line">((a + b) * c) / d 运算结果为： 90.0</span><br><span class="line">(a + b) * (c / d) 运算结果为： 90.0</span><br><span class="line">a + (b * c) / d 运算结果为： 50.0</span><br></pre></td></tr></table></figure>

<p>and 拥有更高优先级:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = True</span><br><span class="line">y = False</span><br><span class="line">z = False</span><br><span class="line"> </span><br><span class="line">if x or y and z:</span><br><span class="line">    print(&quot;yes&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;no&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例先计算 <strong>y and z</strong> 并返回 False ，然后 <strong>x or False</strong> 返回 True，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yes</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>Python3 已不支持 <strong>&lt;&gt;</strong> 运算符，可以使用 <strong>!&#x3D;</strong> 代替，如果你一定要使用这种比较运算符，可以使用以下的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from __future__ import barry_as_FLUFL</span><br><span class="line">&gt;&gt;&gt; 1 &lt;&gt; 2</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>hexo文章加密</title>
    <url>/2023/03/11/hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><span id="more"></span>

<ol>
<li><p>在你的<code>hexo</code>根目录的<em>package.json</em>文件夹中添加：</p>
<p><code>&quot;hexo-blog-encrypt: &quot;2.0.*”</code></p>
</li>
<li><p>然后在命令行中输入：</p>
<p><code>npm install</code></p>
</li>
<li><p>找到根目录下的<code>_config.yml</code>文件，添加如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在你要加密的文章头部写入<code>password: </code></p>
]]></content>
  </entry>
  <entry>
    <title>pip换源</title>
    <url>/2023/02/25/pip%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/  [包名]</code></p>
<span id="more"></span>

<p><code>pip config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple</code></p>
<p><code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p>
<p><code>pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://repo.huaweicloud.com/repository/pypi/simple/ 华为源 19ms</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/ 清华安装源 28ms</span><br><span class="line">https://mirrors.aliyun.com/pypi/simple/ 阿里安装源 28ms</span><br><span class="line">https://mirrors.bfsu.edu.cn/pypi/web/simple/ 中国科技大学源 31ms</span><br><span class="line">http://mirrors.cloud.tencent.com/pypi/simple 腾讯源</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>lora模型</title>
    <url>/2023/05/01/lora%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Stable-Diffusion使用"><a href="#Stable-Diffusion使用" class="headerlink" title="Stable Diffusion使用"></a>Stable Diffusion使用</h2><span id="more"></span>

<ol>
<li><p>点击拓展模型面板</p>
<p><img src="https://pic2.imgdb.cn/item/644f86f70d2dde577736aeb7.jpg"></p>
</li>
<li><p>选择Lora，点击即可</p>
<p><img src="https://pic2.imgdb.cn/item/644f87080d2dde577736c4b3.jpg"></p>
</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>关于Dreambooth，想必大家都已经知道了。LoRA和Dreambooth的关系又是什么？为什么这两个东西都有正则化？</p>
</blockquote>
<p>简单来说，目前微调AI绘画模型是这样的：</p>
<p><img src="https://pic2.imgdb.cn/item/644f871e0d2dde577736f299.jpg"></p>
<p>区别只有一个：<font color='red'>正则化图像</font></p>
<p>没有正则化图像，他就叫直接微调，有正则化图像，他才叫Dreambooth。</p>
<p>那LoRA又在哪里？LoRA的全称是：LoRA: Low-Rank Adaptation of Large Language Models、他是为了解决大语言模型太大了（以亿计的参数）才出现的，AI绘画是拿过来借用的。</p>
<p>LoRA，他只是一种为了简化微调超级大模型需要巨多算力、传大模型麻烦而产生的算法，本质上，还是上面两种微调方法</p>
<p>转自B站@<a href="https://space.bilibili.com/12566101/dynamic">秋葉aaaki</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python3模块</title>
    <url>/2023/07/13/python3%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h1><p>在前面的几个章节中我们基本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># 文件名: using_sys.py</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">print(&#x27;命令行参数如下:&#x27;)</span><br><span class="line">for i in sys.argv:</span><br><span class="line">   print(i)</span><br><span class="line"> </span><br><span class="line">print(&#x27;\n\nPython 路径为：&#x27;, sys.path, &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

<p>执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python using_sys.py 参数1 参数2</span><br><span class="line">命令行参数如下:</span><br><span class="line">using_sys.py</span><br><span class="line">参数1</span><br><span class="line">参数2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： [&#x27;/root&#x27;, &#x27;/usr/lib/python3.4&#x27;, &#x27;/usr/lib/python3.4/plat-x86_64-linux-gnu&#x27;, &#x27;/usr/lib/python3.4/lib-dynload&#x27;, &#x27;/usr/local/lib/python3.4/dist-packages&#x27;, &#x27;/usr/lib/python3/dist-packages&#x27;] </span><br></pre></td></tr></table></figure>

<ul>
<li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li>
<li>2、sys.argv 是一个包含命令行参数的列表。</li>
<li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li>
</ul>
<hr>
<h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>

<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">support.py 文件代码</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"># Filename: support.py</span><br><span class="line"> </span><br><span class="line">def print_func( par ):</span><br><span class="line">    print (&quot;Hello : &quot;, par)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>

<p><strong>test.py 引入 support 模块：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.py 文件代码</span><br><span class="line">#!/usr/bin/python3</span><br><span class="line"># Filename: test.py</span><br><span class="line"> </span><br><span class="line"># 导入模块</span><br><span class="line">import support</span><br><span class="line"> </span><br><span class="line"># 现在可以调用模块里包含的函数了</span><br><span class="line">support.print_func(&quot;Runoob&quot;)</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 test.py </span><br><span class="line">Hello :  Runoob</span><br></pre></td></tr></table></figure>

<p><a href="https://static.runoob.com/download/runoob-python-module-test.zip">下载代码</a></p>
<p>一个模块只会被导入一次，不管你执行了多少次 <strong>import</strong>。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用 import 语句的时候，Python 解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到 Python 的搜索路径，搜索路径是由一系列目录名组成的，Python 解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在 Python 编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在 sys 模块中的 path 变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#x27;&#x27;, &#x27;/usr/lib/python3.4&#x27;, &#x27;/usr/lib/python3.4/plat-x86_64-linux-gnu&#x27;, &#x27;/usr/lib/python3.4/lib-dynload&#x27;, &#x27;/usr/local/lib/python3.4/dist-packages&#x27;, &#x27;/usr/lib/python3/dist-packages&#x27;]</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>

<p>sys.path 输出是一个列表，其中第一项是空串 ‘’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 斐波那契(fibonacci)数列模块</span><br><span class="line"> </span><br><span class="line">def fib(n):    # 定义到 n 的斐波那契数列</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    while b &lt; n:</span><br><span class="line">        print(b, end=&#x27; &#x27;)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    print()</span><br><span class="line"> </span><br><span class="line">def fib2(n): # 返回到 n 的斐波那契数列</span><br><span class="line">    result = []</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    while b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo</span><br></pre></td></tr></table></figure>

<p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;fibo.fib(1000)</span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span><br><span class="line">&gt;&gt;&gt; fibo.fib2(100)</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span><br><span class="line">&gt;&gt;&gt; fibo.__name__</span><br><span class="line">&#x27;fibo&#x27;</span><br></pre></td></tr></table></figure>

<p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fib = fibo.fib</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import 语句"></a>from … import 语句</h2><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from modname import name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>

<p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import fib, fib2</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<hr>
<h2 id="from-…-import-语句-1"><a href="#from-…-import-语句-1" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h2><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from modname import *</span><br></pre></td></tr></table></figure>

<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<hr>
<h2 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h2><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import fib, fib2</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from fibo import *</span><br><span class="line">&gt;&gt;&gt; fib(500)</span><br><span class="line">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure>

<p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<hr>
<h2 id="name-属性"><a href="#name-属性" class="headerlink" title="__name__属性"></a>__name__属性</h2><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># Filename: using_name.py</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">   print(&#x27;程序自身在运行&#x27;)</span><br><span class="line">else:</span><br><span class="line">   print(&#x27;我来自另一模块&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">程序自身在运行</span><br><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import using_name</span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 每个模块都有一个__name__属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p>
<p>说明：**<strong>name</strong>** 与 <strong><strong>main</strong></strong> 底下是双下划线， <strong>_ _</strong> 是这样去掉中间的那个空格。</p>
<hr>
<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h2><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import fibo, sys</span><br><span class="line">&gt;&gt;&gt; dir(fibo)</span><br><span class="line">[&#x27;__name__&#x27;, &#x27;fib&#x27;, &#x27;fib2&#x27;]</span><br><span class="line">&gt;&gt;&gt; dir(sys)  </span><br><span class="line">[&#x27;__displayhook__&#x27;, &#x27;__doc__&#x27;, &#x27;__excepthook__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;,</span><br><span class="line"> &#x27;__package__&#x27;, &#x27;__stderr__&#x27;, &#x27;__stdin__&#x27;, &#x27;__stdout__&#x27;,</span><br><span class="line"> &#x27;_clear_type_cache&#x27;, &#x27;_current_frames&#x27;, &#x27;_debugmallocstats&#x27;, &#x27;_getframe&#x27;,</span><br><span class="line"> &#x27;_home&#x27;, &#x27;_mercurial&#x27;, &#x27;_xoptions&#x27;, &#x27;abiflags&#x27;, &#x27;api_version&#x27;, &#x27;argv&#x27;,</span><br><span class="line"> &#x27;base_exec_prefix&#x27;, &#x27;base_prefix&#x27;, &#x27;builtin_module_names&#x27;, &#x27;byteorder&#x27;,</span><br><span class="line"> &#x27;call_tracing&#x27;, &#x27;callstats&#x27;, &#x27;copyright&#x27;, &#x27;displayhook&#x27;,</span><br><span class="line"> &#x27;dont_write_bytecode&#x27;, &#x27;exc_info&#x27;, &#x27;excepthook&#x27;, &#x27;exec_prefix&#x27;,</span><br><span class="line"> &#x27;executable&#x27;, &#x27;exit&#x27;, &#x27;flags&#x27;, &#x27;float_info&#x27;, &#x27;float_repr_style&#x27;,</span><br><span class="line"> &#x27;getcheckinterval&#x27;, &#x27;getdefaultencoding&#x27;, &#x27;getdlopenflags&#x27;,</span><br><span class="line"> &#x27;getfilesystemencoding&#x27;, &#x27;getobjects&#x27;, &#x27;getprofile&#x27;, &#x27;getrecursionlimit&#x27;,</span><br><span class="line"> &#x27;getrefcount&#x27;, &#x27;getsizeof&#x27;, &#x27;getswitchinterval&#x27;, &#x27;gettotalrefcount&#x27;,</span><br><span class="line"> &#x27;gettrace&#x27;, &#x27;hash_info&#x27;, &#x27;hexversion&#x27;, &#x27;implementation&#x27;, &#x27;int_info&#x27;,</span><br><span class="line"> &#x27;intern&#x27;, &#x27;maxsize&#x27;, &#x27;maxunicode&#x27;, &#x27;meta_path&#x27;, &#x27;modules&#x27;, &#x27;path&#x27;,</span><br><span class="line"> &#x27;path_hooks&#x27;, &#x27;path_importer_cache&#x27;, &#x27;platform&#x27;, &#x27;prefix&#x27;, &#x27;ps1&#x27;,</span><br><span class="line"> &#x27;setcheckinterval&#x27;, &#x27;setdlopenflags&#x27;, &#x27;setprofile&#x27;, &#x27;setrecursionlimit&#x27;,</span><br><span class="line"> &#x27;setswitchinterval&#x27;, &#x27;settrace&#x27;, &#x27;stderr&#x27;, &#x27;stdin&#x27;, &#x27;stdout&#x27;,</span><br><span class="line"> &#x27;thread_info&#x27;, &#x27;version&#x27;, &#x27;version_info&#x27;, &#x27;warnoptions&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; import fibo</span><br><span class="line">&gt;&gt;&gt; fib = fibo.fib</span><br><span class="line">&gt;&gt;&gt; dir() # 得到一个当前模块中定义的属性列表</span><br><span class="line">[&#x27;__builtins__&#x27;, &#x27;__name__&#x27;, &#x27;a&#x27;, &#x27;fib&#x27;, &#x27;fibo&#x27;, &#x27;sys&#x27;]</span><br><span class="line">&gt;&gt;&gt; a = 5 # 建立一个新的变量 &#x27;a&#x27;</span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__name__&#x27;, &#x27;a&#x27;, &#x27;sys&#x27;]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; del a # 删除变量名a</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[&#x27;__builtins__&#x27;, &#x27;__doc__&#x27;, &#x27;__name__&#x27;, &#x27;sys&#x27;]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h2><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.ps1</span><br><span class="line">&#x27;&gt;&gt;&gt; &#x27;</span><br><span class="line">&gt;&gt;&gt; sys.ps2</span><br><span class="line">&#x27;... &#x27;</span><br><span class="line">&gt;&gt;&gt; sys.ps1 = &#x27;C&gt; &#x27;</span><br><span class="line">C&gt; print(&#x27;Runoob!&#x27;)</span><br><span class="line">Runoob!</span><br><span class="line">C&gt; </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sound/                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>

<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） __all__变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sound.effects.echo</span><br></pre></td></tr></table></figure>

<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure>

<p>还有一种导入子模块的方法是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sound.effects import echo</span><br></pre></td></tr></table></figure>

<p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure>

<p>还有一种变化就是直接导入一个函数或者变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from sound.effects.echo import echofilter</span><br></pre></td></tr></table></figure>

<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure>

<p>注意当使用 <strong>from package import item</strong> 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p>
<p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<hr>
<h2 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h2><p>如果我们使用 <strong>from sound.effects import *</strong> 会发生什么呢？</p>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，然后一个一个的把它们都导入进来。</p>
<p>但这个方法在 Windows 平台上工作的就不是非常好，因为 Windows 是一个不区分大小写的系统。</p>
<p>在 Windows 平台上，我们无法确定一个叫做 ECHO.py 的文件导入为模块是 echo 还是 Echo，或者是 ECHO。</p>
<p>为了解决这个问题，我们只需要提供一个精确包的索引。</p>
<p>导入语句遵循如下规则：如果包定义文件 <strong><strong>init</strong>.py</strong> 存在一个叫做 <strong><strong>all</strong></strong> 的列表变量，那么在使用 <strong>from package import *</strong> 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 <strong><strong>all</strong></strong> 也更新了啊。</p>
<p>以下实例在 file:sounds&#x2F;effects&#x2F;<strong>init</strong>.py 中包含如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure>

<p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong><strong>all</strong></strong> 真的没有定义，那么使用**from sound.effects import ***这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p>
<p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sound.effects.echo</span><br><span class="line">import sound.effects.surround</span><br><span class="line">from sound.effects import *</span><br></pre></td></tr></table></figure>

<p>这个例子中，在执行 from…import 前，包 sound.effects 中的 echo 和 surround 模块都被导入到当前的命名空间中了。（当然如果定义了 <strong>all</strong> 就更没问题了）</p>
<p>通常我们并不主张使用 ***** 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用 <strong>from Package import specific_submodule</strong> 这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包 sound.effects 中的模块 echo，你就要写成 from sound.effects import echo。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from . import echo</span><br><span class="line">from .. import formats</span><br><span class="line">from ..filters import equalizer</span><br></pre></td></tr></table></figure>

<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
]]></content>
  </entry>
  <entry>
    <title>Python3 OS</title>
    <url>/2023/07/13/pythonOS/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-OS-文件-目录方法"><a href="#Python3-OS-文件-目录方法" class="headerlink" title="Python3 OS 文件&#x2F;目录方法"></a>Python3 OS 文件&#x2F;目录方法</h1><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-access.html">os.access(path, mode)</a> 检验权限模式</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-chmod.html">os.chmod(path, mode)</a> 更改权限</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">[os.fdopen(fd<a href="https://www.runoob.com/python3/python3-os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwdb.html">os.getcwdb()</a> 返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">[os.makedirs(path<a href="https://www.runoob.com/python3/python3-os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left">[os.mkdir(path<a href="https://www.runoob.com/python3/python3-os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left">[os.mkfifo(path<a href="https://www.runoob.com/python3/python3-os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left">[os.mknod(filename<a href="https://www.runoob.com/python3/python3-os-mknod.html">, mode&#x3D;0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left">[os.open(file, flags<a href="https://www.runoob.com/python3/python3-os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left">[os.popen(command<a href="https://www.runoob.com/python3/python3-os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td align="left">49</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td align="left">50</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td align="left">51</td>
<td align="left">[os.stat_float_times(<a href="https://www.runoob.com/python3/python3-os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td align="left">52</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td align="left">53</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td>
</tr>
<tr>
<td align="left">54</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td align="left">55</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td align="left">56</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td align="left">57</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-unlink.html">os.unlink(path)</a> 删除文件路径</td>
</tr>
<tr>
<td align="left">58</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td align="left">59</td>
<td align="left">os.walk(top[, topdown&#x3D;True[, onerror&#x3D;None[, followlinks&#x3D;False]]])(<a href="https://www.runoob.com/python3/python3-os-walk.html">https://www.runoob.com/python3/python3-os-walk.html</a>)</td>
</tr>
<tr>
<td align="left">60</td>
<td align="left">输出在文件夹中的文件名通过在树中游走，向上或者向下。<a href="https://www.runoob.com/python3/python3-os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
<tr>
<td align="left">61</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-path.html">os.path 模块</a> 获取文件的属性信息。</td>
</tr>
<tr>
<td align="left">62</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-pardir.html">os.pardir()</a> 获取当前目录的父目录，以字符串形式显示目录名。</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-os-replace.html">os.replace()</a> 重命名文件或目录。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>python实现OpenAI的API调用</title>
    <url>/2023/02/26/python%E5%AE%9E%E7%8E%B0OpenAI%E7%9A%84API%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p><code>pip install -i https://mirrors.aliyun.com/pypi/simple/ openai</code></p>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenAI API</span></span><br><span class="line">openai.api_key=<span class="string">&quot;YOUR_API_KEY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型</span></span><br><span class="line">model_engine=<span class="string">&quot;text-davinci-003&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要询问的话</span></span><br><span class="line">prompt = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">completion = openai.Completion.create(</span><br><span class="line">    engine=model_engine,</span><br><span class="line">    prompt=prompt,max_tokens=<span class="number">1024</span>,</span><br><span class="line">    n=<span class="number">1</span>,</span><br><span class="line">    stop=<span class="literal">None</span>,</span><br><span class="line">    temperature=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出回复</span></span><br><span class="line">Response = completion.choices[<span class="number">0</span>].text</span><br><span class="line"><span class="built_in">print</span>(Response)</span><br></pre></td></tr></table></figure>

<h2 id="下面是GPT-3和Codex模型支持的参数："><a href="#下面是GPT-3和Codex模型支持的参数：" class="headerlink" title="下面是GPT-3和Codex模型支持的参数："></a>下面是GPT-3和Codex模型支持的参数：</h2><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>model</code></td>
<td>string</td>
<td></td>
<td>模型名称</td>
</tr>
<tr>
<td><code>prompt</code></td>
<td>string</td>
<td></td>
<td>输入的提示</td>
</tr>
<tr>
<td><code>suffix</code></td>
<td>string</td>
<td><code>null</code></td>
<td>文本生成后在文末插入的后缀</td>
</tr>
<tr>
<td><code>max_tokens</code></td>
<td>int</td>
<td><code>16</code></td>
<td>文本生成时要生成的最大token数。 提示的token数加上<code>max_tokens</code>不能超过模型的上下文长度。 大多数模型的上下文长度为2048个token（最新模型支持4096 tokens）</td>
</tr>
<tr>
<td><code>temperature</code></td>
<td>float</td>
<td><code>1</code></td>
<td>采样温度。值越高意味着模型承担的风险越大。 对于需要创意的场景，可以尝试0.9， 对于答案明确的场景，建议用0（argmax采样） 建议不要与<code>top_p</code>同时改变。</td>
</tr>
<tr>
<td><code>top_p</code></td>
<td>float</td>
<td><code>1</code></td>
<td>核采样（温度采样的另一种方式），其中模型考虑具有<code>top_p</code>概率质量的token的结果。因此，0.1意味着只考虑包含最高10%概率质量的token 建议不要与<code>temperature</code>同时改变。</td>
</tr>
<tr>
<td><code>n</code></td>
<td>int</td>
<td><code>1</code></td>
<td>每个提示要生成多少个答案</td>
</tr>
<tr>
<td><code>stream</code></td>
<td>boolean</td>
<td><code>false</code></td>
<td>是否返回流传输进度。如果设置，token将在可用时以纯数据服务器端推送事件发送，流以<code>data:[DONE]</code>消息终止。</td>
</tr>
<tr>
<td><code>logprobs</code></td>
<td>int</td>
<td><code>nul</code></td>
<td>如果传值（最大值5）则表示包括<code>logprobs</code>个最可能的token以及所选令牌的对数概率。例如，如果<code>logprobs</code>为5，则API将返回包含5个最可能Token的列表。</td>
</tr>
<tr>
<td><code>echo</code></td>
<td>boolean</td>
<td><code>false</code></td>
<td>是否回传提示</td>
</tr>
<tr>
<td><code>stop</code></td>
<td>string</td>
<td><code>null</code></td>
<td>最多4个序列，遇到<code>stop</code>API将停止生成。 返回的文本不包含停止序列。</td>
</tr>
<tr>
<td><code>presence_penalty</code></td>
<td>float</td>
<td><code>0</code></td>
<td>数值介于-2.0和2.0之间。正值将根据到目前为止新token是否出现在文本中来惩罚新token，从而增加模型谈论新主题的可能性。</td>
</tr>
<tr>
<td><code>frequency_penalty</code></td>
<td>float</td>
<td><code>0</code></td>
<td>数值介于-2.0和2.0之间。正值根据文本中新token已经出现的频率惩罚新token，从而降低模型逐字重复同一行的可能性。</td>
</tr>
<tr>
<td><code>best_of</code></td>
<td>int</td>
<td><code>1</code></td>
<td>在服务端生成<code>best_of</code>个完成，并返回“最佳”（每个token的log概率最高的一条）。结果无法流式传输。与<code>n</code>一起使用时，<code>best_of</code>控制候选回应的数量，<code>n</code>指定要返回的数量–<code>best_of</code>必须大于等于<code>n</code>。注意：由于此参数生成许多回应，因此会快速消耗token配额。小心使用并确保对<code>max_tokens</code>和<code>stop</code>进行了合理的设置。</td>
</tr>
<tr>
<td><code>logit_bias</code></td>
<td>map</td>
<td><code>null</code></td>
<td>修改回应种出现指定token的可能性。接受一个json对象，该对象将token（由<a href="https://platform.openai.com/tokenizer?view=bpe">GPT tokenizer</a>的token ID指定）映射到-100到100之间的相关偏差值。可以用 <a href="https://platform.openai.com/tokenizer?view=bpe">tokenizer tool</a> 将文本转换成token ID。在数学上，在采样之前，将偏差添加到模型生成的逻辑中。每个模型的确切效果会有所不同，但介于-1和1之间的值应该会降低或增加选择的可能性；像-100或100这样的值应该会导致相关token的禁用或必现。例如，可以传递<code>｛&quot;50256&quot;: -100｝</code>以防止生成。</td>
</tr>
<tr>
<td><code>user</code></td>
<td>string</td>
<td><code>null</code></td>
<td>代表终端用户的唯一标识符，OpenAI用来监控和检测滥用。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>python实现最优选科方案</title>
    <url>/2023/02/25/python%E5%AE%9E%E7%8E%B0%E6%9C%80%E4%BC%98%E9%80%89%E7%A7%91%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>python实现最优选科方案</p>
<span id="more"></span>

<p><a href="https://wwft.lanzoul.com/ifxbK0ojw96b">程序下载链接，密码：1111</a></p>
<p>注意：在有排名相同的情况时则会按照科目顺序给出选科方案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置学科列表</span></span><br><span class="line">sub = [<span class="string">&quot;物理&quot;</span>,<span class="string">&quot;历史&quot;</span>,<span class="string">&quot;化学&quot;</span>,<span class="string">&quot;生物&quot;</span>,<span class="string">&quot;地理&quot;</span>,<span class="string">&quot;政治&quot;</span>]</span><br><span class="line">mainsub = [<span class="string">&quot;物理&quot;</span>,<span class="string">&quot;历史&quot;</span>]</span><br><span class="line">minorsub = [<span class="string">&quot;化学&quot;</span>,<span class="string">&quot;生物&quot;</span>,<span class="string">&quot;地理&quot;</span>,<span class="string">&quot;政治&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取学生的6门学科成绩</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请按照所示顺序输入你的学科排名，排名之间请用一个空格隔开！&quot;</span>)</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>(<span class="string">&quot;物理 历史 化学 生物 地理 政治\n&quot;</span>).split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"><span class="comment">#将学生的6门成绩存入rating字典中</span></span><br><span class="line">rating = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    rating[sub[i]] = a[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出学生6门成绩</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">fr&quot;你的<span class="subst">&#123;sub[i]&#125;</span>成绩为第<span class="subst">&#123;rating[sub[i]]&#125;</span>&quot;</span>, <span class="string">&quot;名&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置存放3门课程的列表</span></span><br><span class="line">select = []</span><br><span class="line"><span class="comment">#设置最小总成绩</span></span><br><span class="line"><span class="built_in">min</span> = <span class="number">1145141919810</span></span><br><span class="line"><span class="comment">#遍历每种情况</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#若两门课相同，则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(k == j):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#计算3门课程总成绩</span></span><br><span class="line">            tot = rating[mainsub[i]]+rating[minorsub[j]]+rating[minorsub[k]]</span><br><span class="line">            <span class="comment">#若当前总成绩比最小总成绩小，则更新最小总成绩和3门课程</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span> &gt; tot):</span><br><span class="line">                <span class="built_in">min</span> = tot</span><br><span class="line">                <span class="keyword">del</span> select[<span class="number">0</span>:]</span><br><span class="line">                select.append(mainsub[i]), select.append(minorsub[j]), select.append(minorsub[k])</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出3门课程</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;根据排名计算，你的最优选科组合为：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(select[i], end = <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>Python3 数据结构</title>
    <url>/2023/07/13/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-数据结构"><a href="#Python3-数据结构" class="headerlink" title="Python3 数据结构"></a>Python3 数据结构</h1><p>本章节我们主要结合前面所学的知识点来介绍Python数据结构。</p>
<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p>
<p>以下是 Python 中列表的方法：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">list.append(x)</td>
<td align="left">把一个元素添加到列表的结尾，相当于 a[len(a):] &#x3D; [x]。</td>
</tr>
<tr>
<td align="left">list.extend(L)</td>
<td align="left">通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] &#x3D; L。</td>
</tr>
<tr>
<td align="left">list.insert(i, x)</td>
<td align="left">在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td>
</tr>
<tr>
<td align="left">list.remove(x)</td>
<td align="left">删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td>
</tr>
<tr>
<td align="left">list.pop([i])</td>
<td align="left">从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td>
</tr>
<tr>
<td align="left">list.clear()</td>
<td align="left">移除列表中的所有项，等于del a[:]。</td>
</tr>
<tr>
<td align="left">list.index(x)</td>
<td align="left">返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td>
</tr>
<tr>
<td align="left">list.count(x)</td>
<td align="left">返回 x 在列表中出现的次数。</td>
</tr>
<tr>
<td align="left">list.sort()</td>
<td align="left">对列表中的元素进行排序。</td>
</tr>
<tr>
<td align="left">list.reverse()</td>
<td align="left">倒排列表中的元素。</td>
</tr>
<tr>
<td align="left">list.copy()</td>
<td align="left">返回列表的浅复制，等于a[:]。</td>
</tr>
</tbody></table>
<p>下面示例演示了列表的大部分方法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [66.25, 333, 333, 1, 1234.5]</span><br><span class="line">&gt;&gt;&gt; print(a.count(333), a.count(66.25), a.count(&#x27;x&#x27;))</span><br><span class="line">2 1 0</span><br><span class="line">&gt;&gt;&gt; a.insert(2, -1)</span><br><span class="line">&gt;&gt;&gt; a.append(333)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[66.25, 333, -1, 333, 1, 1234.5, 333]</span><br><span class="line">&gt;&gt;&gt; a.index(333)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; a.remove(333)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[66.25, -1, 333, 1, 1234.5, 333]</span><br><span class="line">&gt;&gt;&gt; a.reverse()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[333, 1234.5, 1, 333, -1, 66.25]</span><br><span class="line">&gt;&gt;&gt; a.sort()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[-1, 1, 66.25, 333, 333, 1234.5]</span><br></pre></td></tr></table></figure>

<p>注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p>
<hr>
<h2 id="将列表当做堆栈使用"><a href="#将列表当做堆栈使用" class="headerlink" title="将列表当做堆栈使用"></a>将列表当做堆栈使用</h2><p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; stack = [3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; stack.append(6)</span><br><span class="line">&gt;&gt;&gt; stack.append(7)</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="将列表当作队列使用"><a href="#将列表当作队列使用" class="headerlink" title="将列表当作队列使用"></a>将列表当作队列使用</h2><p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])</span><br><span class="line">&gt;&gt;&gt; queue.append(&quot;Terry&quot;)           # Terry arrives</span><br><span class="line">&gt;&gt;&gt; queue.append(&quot;Graham&quot;)          # Graham arrives</span><br><span class="line">&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves</span><br><span class="line">&#x27;Eric&#x27;</span><br><span class="line">&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves</span><br><span class="line">&#x27;John&#x27;</span><br><span class="line">&gt;&gt;&gt; queue                           # Remaining queue in order of arrival</span><br><span class="line">deque([&#x27;Michael&#x27;, &#x27;Terry&#x27;, &#x27;Graham&#x27;])</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>
<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<p>这里我们将列表中每个数值乘三，获得一个新的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; vec = [2, 4, 6]</span><br><span class="line">&gt;&gt;&gt; [3*x for x in vec]</span><br><span class="line">[6, 12, 18]</span><br></pre></td></tr></table></figure>

<p>现在我们玩一点小花样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [[x, x**2] for x in vec]</span><br><span class="line">[[2, 4], [4, 16], [6, 36]]</span><br></pre></td></tr></table></figure>

<p>这里我们对序列里每一个元素逐个调用某方法：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; freshfruit = [&#x27;  banana&#x27;, &#x27;  loganberry &#x27;, &#x27;passion fruit  &#x27;]</span><br><span class="line">&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]</span><br><span class="line">[&#x27;banana&#x27;, &#x27;loganberry&#x27;, &#x27;passion fruit&#x27;]</span><br></pre></td></tr></table></figure>

<p>我们可以用 if 子句作为过滤器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [3*x for x in vec if x &gt; 3]</span><br><span class="line">[12, 18]</span><br><span class="line">&gt;&gt;&gt; [3*x for x in vec if x &lt; 2]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>以下是一些关于循环和其它技巧的演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; vec1 = [2, 4, 6]</span><br><span class="line">&gt;&gt;&gt; vec2 = [4, 3, -9]</span><br><span class="line">&gt;&gt;&gt; [x*y for x in vec1 for y in vec2]</span><br><span class="line">[8, 6, -18, 16, 12, -36, 24, 18, -54]</span><br><span class="line">&gt;&gt;&gt; [x+y for x in vec1 for y in vec2]</span><br><span class="line">[6, 5, -7, 8, 7, -5, 10, 9, -3]</span><br><span class="line">&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))]</span><br><span class="line">[8, 12, -54]</span><br></pre></td></tr></table></figure>

<p>列表推导式可以使用复杂表达式或嵌套函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)]</span><br><span class="line">[&#x27;3.1&#x27;, &#x27;3.14&#x27;, &#x27;3.142&#x27;, &#x27;3.1416&#x27;, &#x27;3.14159&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="嵌套列表解析"><a href="#嵌套列表解析" class="headerlink" title="嵌套列表解析"></a>嵌套列表解析</h2><p>Python的列表还可以嵌套。</p>
<p>以下实例展示了3X4的矩阵列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix = [</span><br><span class="line">...     [1, 2, 3, 4],</span><br><span class="line">...     [5, 6, 7, 8],</span><br><span class="line">...     [9, 10, 11, 12],</span><br><span class="line">... ]</span><br></pre></td></tr></table></figure>

<p>以下实例将3X4的矩阵列表转换为4X3列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)]</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<p>以下实例也可以使用以下方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; transposed = []</span><br><span class="line">&gt;&gt;&gt; for i in range(4):</span><br><span class="line">...     transposed.append([row[i] for row in matrix])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; transposed</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<p>另外一种实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; transposed = []</span><br><span class="line">&gt;&gt;&gt; for i in range(4):</span><br><span class="line">...     # the following 3 lines implement the nested listcomp</span><br><span class="line">...     transposed_row = []</span><br><span class="line">...     for row in matrix:</span><br><span class="line">...         transposed_row.append(row[i])</span><br><span class="line">...     transposed.append(transposed_row)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; transposed</span><br><span class="line">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h2><p>使用 del 语句可以从一个列表中根据索引来删除一个元素，而不是值来删除元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[0]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 66.25, 333, 333, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[2:4]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 66.25, 1234.5]</span><br><span class="line">&gt;&gt;&gt; del a[:]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>也可以用 del 删除实体变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; del a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h2><p>元组由若干逗号分隔的值组成，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = 12345, 54321, &#x27;hello!&#x27;</span><br><span class="line">&gt;&gt;&gt; t[0]</span><br><span class="line">12345</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(12345, 54321, &#x27;hello!&#x27;)</span><br><span class="line">&gt;&gt;&gt; # Tuples may be nested:</span><br><span class="line">... u = t, (1, 2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; u</span><br><span class="line">((12345, 54321, &#x27;hello!&#x27;), (1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure>

<p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<hr>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p>
<p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p>
<p>以下是一个简单的演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; print(basket)                      # 删除重复的</span><br><span class="line">&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; &#x27;orange&#x27; in basket                 # 检测成员</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;crabgrass&#x27; in basket</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; # 以下演示了两个集合的操作</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)</span><br><span class="line">&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)</span><br><span class="line">&gt;&gt;&gt; a                                  # a 中唯一的字母</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a - b                              # 在 a 中的字母，但不在 b 中</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a | b                              # 在 a 或 b 中的字母</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a &amp; b                              # 在 a 和 b 中都有的字母</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a ^ b                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>集合也支持推导式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>另一个非常有用的 Python 内建数据类型是字典。</p>
<p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>理解字典的最佳方式是把它看做无序的键&#x3D;&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p>
<p>一对大括号创建一个空的字典：{}。</p>
<p>这是一个字典运用的简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tel = &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span><br><span class="line">&gt;&gt;&gt; tel[&#x27;guido&#x27;] = 4127</span><br><span class="line">&gt;&gt;&gt; tel</span><br><span class="line">&#123;&#x27;sape&#x27;: 4139, &#x27;guido&#x27;: 4127, &#x27;jack&#x27;: 4098&#125;</span><br><span class="line">&gt;&gt;&gt; tel[&#x27;jack&#x27;]</span><br><span class="line">4098</span><br><span class="line">&gt;&gt;&gt; del tel[&#x27;sape&#x27;]</span><br><span class="line">&gt;&gt;&gt; tel[&#x27;irv&#x27;] = 4127</span><br><span class="line">&gt;&gt;&gt; tel</span><br><span class="line">&#123;&#x27;guido&#x27;: 4127, &#x27;irv&#x27;: 4127, &#x27;jack&#x27;: 4098&#125;</span><br><span class="line">&gt;&gt;&gt; list(tel.keys())</span><br><span class="line">[&#x27;irv&#x27;, &#x27;guido&#x27;, &#x27;jack&#x27;]</span><br><span class="line">&gt;&gt;&gt; sorted(tel.keys())</span><br><span class="line">[&#x27;guido&#x27;, &#x27;irv&#x27;, &#x27;jack&#x27;]</span><br><span class="line">&gt;&gt;&gt; &#x27;guido&#x27; in tel</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;jack&#x27; not in tel</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(&#x27;sape&#x27;, 4139), (&#x27;guido&#x27;, 4127), (&#x27;jack&#x27;, 4098)])</span><br><span class="line">&#123;&#x27;sape&#x27;: 4139, &#x27;jack&#x27;: 4098, &#x27;guido&#x27;: 4127&#125;</span><br></pre></td></tr></table></figure>

<p>此外，字典推导可以用来创建任意键和值的表达式词典：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br></pre></td></tr></table></figure>

<p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)</span><br><span class="line">&#123;&#x27;sape&#x27;: 4139, &#x27;jack&#x27;: 4098, &#x27;guido&#x27;: 4127&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="遍历技巧"><a href="#遍历技巧" class="headerlink" title="遍历技巧"></a>遍历技巧</h2><p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; knights = &#123;&#x27;gallahad&#x27;: &#x27;the pure&#x27;, &#x27;robin&#x27;: &#x27;the brave&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class="line">...     print(k, v)</span><br><span class="line">...</span><br><span class="line">gallahad the pure</span><br><span class="line">robin the brave</span><br></pre></td></tr></table></figure>

<p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, v in enumerate([&#x27;tic&#x27;, &#x27;tac&#x27;, &#x27;toe&#x27;]):</span><br><span class="line">...     print(i, v)</span><br><span class="line">...</span><br><span class="line">0 tic</span><br><span class="line">1 tac</span><br><span class="line">2 toe</span><br></pre></td></tr></table></figure>

<p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; questions = [&#x27;name&#x27;, &#x27;quest&#x27;, &#x27;favorite color&#x27;]</span><br><span class="line">&gt;&gt;&gt; answers = [&#x27;lancelot&#x27;, &#x27;the holy grail&#x27;, &#x27;blue&#x27;]</span><br><span class="line">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class="line">...     print(&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;.format(q, a))</span><br><span class="line">...</span><br><span class="line">What is your name?  It is lancelot.</span><br><span class="line">What is your quest?  It is the holy grail.</span><br><span class="line">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure>

<p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; basket = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]</span><br><span class="line">&gt;&gt;&gt; for f in sorted(set(basket)):</span><br><span class="line">...     print(f)</span><br><span class="line">...</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>python循环结构（第一节）</title>
    <url>/2023/02/25/python%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%88%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%89/</url>
    <content><![CDATA[<p>第一节<span id="more"></span></p>
<ol>
<li>用python for循环写一个计算一百以内整数之和的程序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>):    </span><br><span class="line"></span><br><span class="line">	<span class="built_in">sum</span> += i </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;1-100的整数之和为：&quot;</span>,<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>用python for循环写一个计算0到用户输入整数之间所有整数之和的程序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入一个非零整数：&#x27;</span>)) </span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n+<span class="number">1</span>):    </span><br><span class="line"></span><br><span class="line">	<span class="built_in">sum</span> += num </span><br><span class="line">	</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从0加到%d的和为：%d&#x27;</span> % (n,<span class="built_in">sum</span>))</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>用python写一个计算0到100之间所有是3的倍数的整数之和的程序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义变量s用于存储整数之和 </span></span><br><span class="line">s = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历0到100之间的整数 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">101</span>):    </span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 判断整数是否为3的倍数    </span></span><br><span class="line">	<span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>:        </span><br><span class="line">		s += i </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 打印计算结果 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0到100之间所有是3的倍数的整数之和为：&#x27;</span>, s)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Python3 推导式、迭代器与生成器</title>
    <url>/2023/07/13/python%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-推导式"><a href="#Python3-推导式" class="headerlink" title="Python3 推导式"></a>Python3 推导式</h1><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[表达式 for 变量 in 列表] </span><br><span class="line">[out_exp_res for out_exp in input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 for 变量 in 列表 if 条件]</span><br><span class="line">[out_exp_res for out_exp in input_list if condition]</span><br></pre></td></tr></table></figure>

<ul>
<li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li>
<li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li>
<li>if condition：条件语句，可以过滤列表中不符合条件的值。</li>
</ul>
<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]</span><br><span class="line">&gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3]</span><br><span class="line">&gt;&gt;&gt; print(new_names)</span><br><span class="line">[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]</span><br></pre></td></tr></table></figure>

<p>计算 30 以内可以被 3 整除的整数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; multiples = [i for i in range(30) if i % 3 == 0]</span><br><span class="line">&gt;&gt;&gt; print(multiples)</span><br><span class="line">[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>字典推导基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr for value in collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr for value in collection if condition &#125;</span><br></pre></td></tr></table></figure>

<p>使用字符串及其长度创建字典：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span><br><span class="line">&gt;&gt;&gt; newdict = &#123;key:len(key) for key in listdemo&#125;</span><br><span class="line">&gt;&gt;&gt; newdict</span><br><span class="line">&#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;</span><br></pre></td></tr></table></figure>

<p>提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line">&gt;&gt;&gt; type(dic)</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>集合推导式基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; expression for item in Sequence &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression for item in Sequence if conditional &#125;</span><br></pre></td></tr></table></figure>

<p>计算数字 1,2,3 的平方数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; setnew = &#123;i**2 for i in (1,2,3)&#125;</span><br><span class="line">&gt;&gt;&gt; setnew</span><br><span class="line">&#123;1, 4, 9&#125;</span><br></pre></td></tr></table></figure>

<p>判断不是 abc 的字母并输出：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#x27;d&#x27;, &#x27;r&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h2><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>
<p>元组推导式基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(expression for item in Sequence )</span><br><span class="line">或</span><br><span class="line">(expression for item in Sequence if conditional )</span><br></pre></td></tr></table></figure>

<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。</p>
<p>例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (x for x in range(1,10))</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  # 返回的是生成器对象</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Python3-迭代器与生成器"><a href="#Python3-迭代器与生成器" class="headerlink" title="Python3 迭代器与生成器"></a>Python3 迭代器与生成器</h1><hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象</span><br><span class="line">&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print (next(it))</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>迭代器对象可以使用常规for语句进行遍历：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line">for x in it:</span><br><span class="line">    print (x, end=&quot; &quot;)</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<p>也可以使用 next() 函数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">import sys         # 引入 sys 模块</span><br><span class="line"> </span><br><span class="line">list=[1,2,3,4]</span><br><span class="line">it = iter(list)    # 创建迭代器对象</span><br><span class="line"> </span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (next(it))</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
<p>如果你已经了解的面向对象编程，就知道类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p>更多内容查阅：<a href="https://www.runoob.com/python3/python3-class.html">Python3 面向对象</a></p>
<p><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    return self</span><br><span class="line"> </span><br><span class="line">  def __next__(self):</span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += 1</span><br><span class="line">    return x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h3><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<p>在 20 次迭代后停止执行：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    return self</span><br><span class="line"> </span><br><span class="line">  def __next__(self):</span><br><span class="line">    if self.a &lt;= 20:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += 1</span><br><span class="line">      return x</span><br><span class="line">    else:</span><br><span class="line">      raise StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">for x in myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure>

<p>执行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在 Python 中，使用了 <strong>yield</strong> 的函数被称为生成器（generator）。</p>
<p><strong>yield</strong> 是一个关键字，用于定义生成器函数，生成器函数是一种特殊的函数，可以在迭代过程中逐步产生值，而不是一次性返回所有结果。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>当在生成器函数中使用 <strong>yield</strong> 语句时，函数的执行将会暂停，并将 <strong>yield</strong> 后面的表达式作为当前迭代的值返回。</p>
<p>然后，每次调用生成器的 <strong>next()</strong> 方法或使用 <strong>for</strong> 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 <strong>yield</strong> 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>下面是一个简单的示例，展示了生成器函数的使用：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def countdown(n):</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        yield n</span><br><span class="line">        n -= 1</span><br><span class="line"> </span><br><span class="line"># 创建生成器对象</span><br><span class="line">generator = countdown(5)</span><br><span class="line"> </span><br><span class="line"># 通过迭代生成器获取值</span><br><span class="line">print(next(generator))  # 输出: 5</span><br><span class="line">print(next(generator))  # 输出: 4</span><br><span class="line">print(next(generator))  # 输出: 3</span><br><span class="line"> </span><br><span class="line"># 使用 for 循环迭代生成器</span><br><span class="line">for value in generator:</span><br><span class="line">    print(value)  # 输出: 2 1</span><br></pre></td></tr></table></figure>

<p>以上实例中，<strong>countdown</strong> 函数是一个生成器函数。它使用 yield 语句逐步产生从 n 到 1 的倒数数字。在每次调用 yield 语句时，函数会返回当前的倒数值，并在下一次调用时从上次暂停的地方继续执行。</p>
<p>通过创建生成器对象并使用 next() 函数或 for 循环迭代生成器，我们可以逐步获取生成器函数产生的值。在这个例子中，我们首先使用 next() 函数获取前三个倒数值，然后通过 for 循环获取剩下的两个倒数值。</p>
<p>生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。此外，生成器还可以与其他迭代工具（如for循环）无缝配合使用，提供简洁和高效的迭代方式。</p>
<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>以下实例使用 yield 实现斐波那契数列：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"> </span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">def fibonacci(n): # 生成器函数 - 斐波那契</span><br><span class="line">    a, b, counter = 0, 1, 0</span><br><span class="line">    while True:</span><br><span class="line">        if (counter &gt; n): </span><br><span class="line">            return</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += 1</span><br><span class="line">f = fibonacci(10) # f 是一个迭代器，由生成器返回生成</span><br><span class="line"> </span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print (next(f), end=&quot; &quot;)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Python3 输入与输出、文件方法</title>
    <url>/2023/07/13/python%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-输入和输出"><a href="#Python3-输入和输出" class="headerlink" title="Python3 输入和输出"></a>Python3 输入和输出</h1><p>在前面几个章节中，我们其实已经接触了 Python 的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。</p>
<hr>
<h2 id="输出格式美化"><a href="#输出格式美化" class="headerlink" title="输出格式美化"></a>输出格式美化</h2><p>Python两种输出值的方式: 表达式语句和 print() 函数。</p>
<p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。</p>
<p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p>
<p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p>
<ul>
<li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li>
<li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;Hello, Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; str(s)</span><br><span class="line">&#x27;Hello, Runoob&#x27;</span><br><span class="line">&gt;&gt;&gt; repr(s)</span><br><span class="line">&quot;&#x27;Hello, Runoob&#x27;&quot;</span><br><span class="line">&gt;&gt;&gt; str(1/7)</span><br><span class="line">&#x27;0.14285714285714285&#x27;</span><br><span class="line">&gt;&gt;&gt; x = 10 * 3.25</span><br><span class="line">&gt;&gt;&gt; y = 200 * 200</span><br><span class="line">&gt;&gt;&gt; s = &#x27;x 的值为： &#x27; + repr(x) + &#x27;,  y 的值为：&#x27; + repr(y) + &#x27;...&#x27;</span><br><span class="line">&gt;&gt;&gt; print(s)</span><br><span class="line">x 的值为： 32.5,  y 的值为：40000...</span><br><span class="line">&gt;&gt;&gt; #  repr() 函数可以转义字符串中的特殊字符</span><br><span class="line">... hello = &#x27;hello, runoob\n&#x27;</span><br><span class="line">&gt;&gt;&gt; hellos = repr(hello)</span><br><span class="line">&gt;&gt;&gt; print(hellos)</span><br><span class="line">&#x27;hello, runoob\n&#x27;</span><br><span class="line">&gt;&gt;&gt; # repr() 的参数可以是 Python 的任何对象</span><br><span class="line">... repr((x, y, (&#x27;Google&#x27;, &#x27;Runoob&#x27;)))</span><br><span class="line">&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot;</span><br></pre></td></tr></table></figure>

<p>这里有两种方式输出一个平方与立方的表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&#x27; &#x27;)</span><br><span class="line">...     # 注意前一行 &#x27;end&#x27; 的使用</span><br><span class="line">...     print(repr(x*x*x).rjust(4))</span><br><span class="line">...</span><br><span class="line"> 1   1    1</span><br><span class="line"> 2   4    8</span><br><span class="line"> 3   9   27</span><br><span class="line"> 4  16   64</span><br><span class="line"> 5  25  125</span><br><span class="line"> 6  36  216</span><br><span class="line"> 7  49  343</span><br><span class="line"> 8  64  512</span><br><span class="line"> 9  81  729</span><br><span class="line">10 100 1000</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...     print(&#x27;&#123;0:2d&#125; &#123;1:3d&#125; &#123;2:4d&#125;&#x27;.format(x, x*x, x*x*x))</span><br><span class="line">...</span><br><span class="line"> 1   1    1</span><br><span class="line"> 2   4    8</span><br><span class="line"> 3   9   27</span><br><span class="line"> 4  16   64</span><br><span class="line"> 5  25  125</span><br><span class="line"> 6  36  216</span><br><span class="line"> 7  49  343</span><br><span class="line"> 8  64  512</span><br><span class="line"> 9  81  729</span><br><span class="line">10 100 1000</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>在第一个例子中, 每列间的空格由 print() 添加。</p>
<p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。</p>
<p>还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。</p>
<p>另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;12&#x27;.zfill(5)</span><br><span class="line">&#x27;00012&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;-3.14&#x27;.zfill(7)</span><br><span class="line">&#x27;-003.14&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;3.14159265359&#x27;.zfill(5)</span><br><span class="line">&#x27;3.14159265359&#x27;</span><br></pre></td></tr></table></figure>

<p>str.format() 的基本使用如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;.format(&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;))</span><br><span class="line">菜鸟教程网址： &quot;www.runoob.com!&quot;</span><br></pre></td></tr></table></figure>

<p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。</p>
<p>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;.format(&#x27;Google&#x27;, &#x27;Runoob&#x27;))</span><br><span class="line">Google 和 Runoob</span><br><span class="line">&gt;&gt;&gt; print(&#x27;&#123;1&#125; 和 &#123;0&#125;&#x27;.format(&#x27;Google&#x27;, &#x27;Runoob&#x27;))</span><br><span class="line">Runoob 和 Google</span><br></pre></td></tr></table></figure>

<p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;&#123;name&#125;网址： &#123;site&#125;&#x27;.format(name=&#x27;菜鸟教程&#x27;, site=&#x27;www.runoob.com&#x27;))</span><br><span class="line">菜鸟教程网址： www.runoob.com</span><br></pre></td></tr></table></figure>

<p>位置及关键字参数可以任意的结合:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。&#x27;.format(&#x27;Google&#x27;, &#x27;Runoob&#x27;, other=&#x27;Taobao&#x27;))</span><br><span class="line">站点列表 Google, Runoob, 和 Taobao。</span><br></pre></td></tr></table></figure>

<p><strong>!a</strong> (使用 <strong>ascii()</strong>), <strong>!s</strong> (使用 <strong>str()</strong>) 和 <strong>!r</strong> (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;.format(math.pi))</span><br><span class="line">常量 PI 的值近似为： 3.141592653589793。</span><br><span class="line">&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;.format(math.pi))</span><br><span class="line">常量 PI 的值近似为： 3.141592653589793。</span><br></pre></td></tr></table></figure>

<p>可选项 <strong>:</strong> 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;.format(math.pi))</span><br><span class="line">常量 PI 的值近似为 3.142。</span><br></pre></td></tr></table></figure>

<p>在 <strong>:</strong> 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for name, number in table.items():</span><br><span class="line">...     print(&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;.format(name, number))</span><br><span class="line">... </span><br><span class="line">Google     ==&gt;          1</span><br><span class="line">Runoob     ==&gt;          2</span><br><span class="line">Taobao     ==&gt;          3</span><br></pre></td></tr></table></figure>

<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。</p>
<p>最简单的就是传入一个字典, 然后使用方括号 <strong>[]</strong> 来访问键值 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; print(&#x27;Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;&#x27;.format(table))</span><br><span class="line">Runoob: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure>

<p>也可以通过在 table 变量前使用 *<strong>*</strong> 来实现相同的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; print(&#x27;Runoob: &#123;Runoob:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;&#x27;.format(**table))</span><br><span class="line">Runoob: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="旧式字符串格式化"><a href="#旧式字符串格式化" class="headerlink" title="旧式字符串格式化"></a>旧式字符串格式化</h2><p><strong>%</strong> 操作符也可以实现字符串格式化。 它将左边的参数作为类似 <strong>sprintf()</strong> 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为：%5.3f。&#x27; % math.pi)</span><br><span class="line">常量 PI 的值近似为：3.142。</span><br></pre></td></tr></table></figure>

<p>因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p>
<hr>
<h2 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h2><p>Python 提供了 <a href="https://www.runoob.com/python3/python3-func-input.html">input() 内置函数</a>从标准输入读入一行文本，默认的标准输入是键盘。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">str = input(&quot;请输入：&quot;);</span><br><span class="line">print (&quot;你输入的内容是: &quot;, str)</span><br></pre></td></tr></table></figure>

<p>这会产生如下的对应着输入的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入：菜鸟教程</span><br><span class="line">你输入的内容是:  菜鸟教程</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="读和写文件"><a href="#读和写文件" class="headerlink" title="读和写文件"></a>读和写文件</h2><p>open() 将会返回一个 file 对象，基本语法格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(filename, mode)</span><br></pre></td></tr></table></figure>

<ul>
<li>filename：包含了你要访问的文件名称的字符串值。</li>
<li>mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td align="left">rb</td>
<td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">rb+</td>
<td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb</td>
<td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb+</td>
<td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td align="left">ab+</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<p>下图很好的总结了这几种模式：</p>
<p><img src="https://pic.imgdb.cn/item/64b00e711ddac507cc708a8c.png"></p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">r</th>
<th align="center">r+</th>
<th align="center">w</th>
<th align="center">w+</th>
<th align="center">a</th>
<th align="center">a+</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center">+</td>
<td align="center"></td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">写</td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
<tr>
<td align="center">覆盖</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">指针在开始</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center">+</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">指针在结尾</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">+</td>
<td align="center">+</td>
</tr>
</tbody></table>
<p>以下实例将字符串写入到文件 foo.txt 中：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为要打开的文件名。</li>
<li>第二个参数描述文件如何使用的字符。 mode 可以是 ‘r’ 如果文件只读, ‘w’ 只用于写 (如果存在同名文件则将被删除), 和 ‘a’ 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. ‘r+’ 同时用于读写。 mode 参数是可选的; ‘r’ 将是默认值。</li>
</ul>
<p>此时打开文件 foo.txt,显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /tmp/foo.txt </span><br><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h2><p>本节中剩下的例子假设已经创建了一个称为 f 的文件对象。</p>
<h3 id="f-read"><a href="#f-read" class="headerlink" title="f.read()"></a>f.read()</h3><p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。</p>
<p>size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。</p>
<p>以下实例假定文件 foo.txt 已存在（上面实例中已创建）：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">str = f.read()</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure>

<h3 id="f-readline"><a href="#f-readline" class="headerlink" title="f.readline()"></a>f.readline()</h3><p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">str = f.readline()</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br></pre></td></tr></table></figure>

<h3 id="f-readlines"><a href="#f-readlines" class="headerlink" title="f.readlines()"></a>f.readlines()</h3><p>f.readlines() 将返回该文件中包含的所有行。</p>
<p>如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">str = f.readlines()</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Python 是一个非常好的语言。\n&#x27;, &#x27;是的，的确非常好!!\n&#x27;]</span><br></pre></td></tr></table></figure>

<p>另一种方式是迭代一个文件对象然后读取每行:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">for line in f:</span><br><span class="line">    print(line, end=&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure>

<p>这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用。</p>
<h3 id="f-write"><a href="#f-write" class="headerlink" title="f.write()"></a>f.write()</h3><p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">num = f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )</span><br><span class="line">print(num)</span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">29</span><br></pre></td></tr></table></figure>

<p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line"># 打开一个文件</span><br><span class="line">f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)</span><br><span class="line"></span><br><span class="line">value = (&#x27;www.runoob.com&#x27;, 14)</span><br><span class="line">s = str(value)</span><br><span class="line">f.write(s)</span><br><span class="line"></span><br><span class="line"># 关闭打开的文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>执行以上程序，打开 foo1.txt 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /tmp/foo1.txt </span><br><span class="line">(&#x27;www.runoob.com&#x27;, 14)</span><br></pre></td></tr></table></figure>

<h3 id="f-tell"><a href="#f-tell" class="headerlink" title="f.tell()"></a>f.tell()</h3><p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p>
<h3 id="f-seek"><a href="#f-seek" class="headerlink" title="f.seek()"></a>f.seek()</h3><p>如果要改变文件指针当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p>
<p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：</p>
<ul>
<li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li>
<li>seek(x,1) ： 表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li>
</ul>
<p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&#x27;/tmp/foo.txt&#x27;, &#x27;rb+&#x27;)</span><br><span class="line">&gt;&gt;&gt; f.write(b&#x27;0123456789abcdef&#x27;)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; f.seek(5)     # 移动到文件的第六个字节</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">b&#x27;5&#x27;</span><br><span class="line">&gt;&gt;&gt; f.seek(-3, 2) # 移动到文件的倒数第三字节</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.read(1)</span><br><span class="line">b&#x27;d&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="f-close"><a href="#f-close" class="headerlink" title="f.close()"></a>f.close()</h3><p>在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。</p>
<p>当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class="line">ValueError: I/O operation on closed file</span><br></pre></td></tr></table></figure>

<p>当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">...     read_data = f.read()</span><br><span class="line">&gt;&gt;&gt; f.closed</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。</p>
<hr>
<h2 id="pickle-模块"><a href="#pickle-模块" class="headerlink" title="pickle 模块"></a>pickle 模块</h2><p>python的pickle模块实现了基本的数据序列和反序列化。</p>
<p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p>
<p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p>
<p>基本接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pickle.dump(obj, file, [,protocol])</span><br></pre></td></tr></table></figure>

<p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = pickle.load(file)</span><br></pre></td></tr></table></figure>

<p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p>
<p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p>
<p><strong>实例1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import pickle</span><br><span class="line"></span><br><span class="line"># 使用pickle模块将数据对象保存到文件</span><br><span class="line">data1 = &#123;&#x27;a&#x27;: [1, 2.0, 3, 4+6j],</span><br><span class="line">         &#x27;b&#x27;: (&#x27;string&#x27;, u&#x27;Unicode string&#x27;),</span><br><span class="line">         &#x27;c&#x27;: None&#125;</span><br><span class="line"></span><br><span class="line">selfref_list = [1, 2, 3]</span><br><span class="line">selfref_list.append(selfref_list)</span><br><span class="line"></span><br><span class="line">output = open(&#x27;data.pkl&#x27;, &#x27;wb&#x27;)</span><br><span class="line"></span><br><span class="line"># Pickle dictionary using protocol 0.</span><br><span class="line">pickle.dump(data1, output)</span><br><span class="line"></span><br><span class="line"># Pickle the list using the highest protocol available.</span><br><span class="line">pickle.dump(selfref_list, output, -1)</span><br><span class="line"></span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure>

<p><strong>实例2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import pprint, pickle</span><br><span class="line"></span><br><span class="line">#使用pickle模块从文件中重构python对象</span><br><span class="line">pkl_file = open(&#x27;data.pkl&#x27;, &#x27;rb&#x27;)</span><br><span class="line"></span><br><span class="line">data1 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data1)</span><br><span class="line"></span><br><span class="line">data2 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data2)</span><br><span class="line"></span><br><span class="line">pkl_file.close()</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Python3-File-文件-方法"><a href="#Python3-File-文件-方法" class="headerlink" title="Python3 File(文件) 方法"></a>Python3 File(文件) 方法</h1><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h3><p>Python <strong>open()</strong> 方法用于打开一个文件，并返回文件对象。</p>
<p>在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 <strong>OSError</strong>。</p>
<p><strong>注意：</strong>使用 <strong>open()</strong> 方法一定要保证关闭文件对象，即调用 <strong>close()</strong> 方法。</p>
<p><strong>open()</strong> 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(file, mode=&#x27;r&#x27;)</span><br></pre></td></tr></table></figure>

<p>完整的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<ul>
<li>file: 必需，文件路径（相对或者绝对路径）。</li>
<li>mode: 可选，文件打开模式</li>
<li>buffering: 设置缓冲</li>
<li>encoding: 一般使用utf8</li>
<li>errors: 报错级别</li>
<li>newline: 区分换行符</li>
<li>closefd: 传入的file参数类型</li>
<li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li>
</ul>
<p>mode 参数有：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">t</td>
<td align="left">文本模式 (默认)。</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">二进制模式。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">打开一个文件进行更新(可读可写)。</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td align="left">rb</td>
<td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td align="left">rb+</td>
<td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb</td>
<td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">w+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td align="left">wb+</td>
<td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">ab</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td align="left">a+</td>
<td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td align="left">ab+</td>
<td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody></table>
<p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p>
<h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a><strong>Python 3 中的 File 对象不支持 next() 方法。</strong>返回文件下一行。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>中华人民共和国计算机信息网络国际联网管理暂行规定</title>
    <url>/2023/04/01/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%9B%BD%E9%99%85%E8%81%94%E7%BD%91%E7%AE%A1%E7%90%86%E6%9A%82%E8%A1%8C%E8%A7%84%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="中华人民共和国计算机信息网络国际联网管理暂行规定"><a href="#中华人民共和国计算机信息网络国际联网管理暂行规定" class="headerlink" title="中华人民共和国计算机信息网络国际联网管理暂行规定"></a><strong>中华人民共和国计算机信息网络国际联网管理暂行规定</strong></h3><span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/6427faa7a682492fcc964c6b.jpg"></p>
<blockquote>
<p>　　第一条 为了加强对计算机信息网络国际联网的管理，保障国际计算机信息交流的健康发展，制定本规定。</p>
<p>　　第二条 中华人民共和国境内的计算机信息网络进行国际联网，应当依照本规定办理。</p>
<p>　　第三条 本规定下列用语的含义是：</p>
<p>　　（一）计算机信息网络国际联网（以下简称国际联网），是指中华人民共和国境内的计算机信息网络为实现信息的国际交流，同外国的计算机信息网络相联接。</p>
<p>　　（二）互联网络，是指直接进行国际联网的计算机信息网络；互联单位，是指负责互联网络运行的单位。</p>
<p>　　（三）接入网络，是指通过接入互联网络进行国际联网的计算机信息网络；接入单位，是指负责接入网络运行的单位。</p>
<p>　　第四条 国家对国际联网实行统筹规划、统一标准、分级管理、促进发展的原则。</p>
<p>　　第五条 国务院经济信息化领导小组（以下简称领导小组），负责协调、解决有关国际联网工作中的重大问题。</p>
<p>　　领导小组办公室按照本规定制定具体管理办法，明确国际出入口信道提供单位、互联单位、接入单位和用户的权利、义务和责任，并负责对国际联网工作的检查监督。</p>
<p>　　<strong>第六条 计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。</strong></p>
<p>　　<strong>任何单位和个人不得自行建立或者使用其他信道进行国际联网。</strong></p>
<p>　　第七条 已经建立的互联网络，根据国务院有关规定调整后，分别由邮电部、电子工业部、国家教育委员会和中国科学院管理。</p>
<p>　　新建互联网络，必须报经国务院批准。</p>
<p>　　第八条 接入网络必须通过互联网络进行国际联网。</p>
<p>　　拟建立接入网络的单位，应当报经互联单位的主管部门或者主管单位审批；办理审批手续时，应当提供其计算机信息网络的性质、应用范围和所需主机地址等资料。</p>
<p>　　第九条 接入单位必须具备下列条件：</p>
<p>　　（一）是依法设立的企业法人或者事业法人；</p>
<p>　　（二）具有相应的计算机信息网络、装备以及相应的技术人员和管理人员；</p>
<p>　　（三）具有健全的安全保密管理制度和技术保护措施；</p>
<p>　　（四）符合法律和国务院规定的其他条件。</p>
<p>　　第十条 个人、法人和其他组织（以下统称用户）使用的计算机或者计算机信息网络，需要进行国际联网的，必须通过接入网络进行国际联网。</p>
<p>　　前款规定的计算机或者计算机信息网络，需要接入接入网络的，应当征得接入单位的同意，并办理登记手续。</p>
<p>　　第十—条 国际出入口信道提供单位、互联单位和接入单位，应当建立相应的网络管理中心，依照法律和国家有关规定加强对本单位及其用户的管理，做好网络信息安全管理工作，确保为用户提供良好、安全的服务。</p>
<p>　　第十二条 互联单位与接入单位，应当负责本单位及其用户有关国际联网的技术培训和管理教育工作。</p>
<p>　　第十三条 从事国际联网业务的单位和个人，应当遵守国家有关法律、行政法规，严格执行安全保密制度，不得利用国际联网从事危害国家安全、泄露国家秘密等违法犯罪活动，不得制作、查阅、复制和传播妨碍社会治安的信息和淫秽色情等信息。</p>
<p>　　第十四条 违反本规定第六条、第八条和第十条规定的，由公安机关或者公安机关根据国际出入口信道提供单位、互联单位、接入单位的意见，给予警告、通报批评、责令停止联网，可以并处15000元以下的罚款。</p>
<p>　　第十五条 违反本规定，同时触犯其他有关法律、行政法规的，依照有关法律、行政法规的规定予以处罚；构成犯罪的，依法追究刑事责任。</p>
<p>　　第十六条 与台湾、香港、澳门地区的计算机信息网络的联网，参照本规定执行。</p>
<p>　　第十七条 本规定自发布之日起施行。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>《云服务在电子游戏领域的应用》</title>
    <url>/2023/04/09/%E3%80%8A%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%9C%A8%E7%94%B5%E5%AD%90%E6%B8%B8%E6%88%8F%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%8B/</url>
    <content><![CDATA[<p><strong>云服务在电子游戏领域的应用</strong></p>
<p><strong>摘要：</strong></p>
<span id="more"></span>

<p>​	随着互联网的迅速发展以及网络数据传输服务的迅速发展，云服务逐渐被应用在更多的领域以及更大的范围，以云计算为基础的新型游戏模式”云游戏”也逐步走进大众视野。本文主要介绍了云计算和云游戏的概念，阐述云游戏的相应的基础技术以及云游戏平台的运营模式，并对云游戏产业链进行了相应调查。总结了云游戏相比以往传统游戏模式的优势以及云游戏市场的发展状况。</p>
<p><strong>【关键词】云服务，云计算，云游戏，市场</strong></p>
<h1 id="云游戏及其基本技术概念"><a href="#云游戏及其基本技术概念" class="headerlink" title="云游戏及其基本技术概念"></a>云游戏及其基本技术概念</h1><h2 id="云服务概念"><a href="#云服务概念" class="headerlink" title="云服务概念"></a>云服务概念</h2><blockquote>
<p>云服务（cloud service）是基于互联网的相关服务的增加、使用和交互模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。云是网络、互联网的一种比喻说法。过去在图中往往用云来表示电信网，后来也用来表示互联网和底层基础设施的抽象。云服务指通过网络以按需、易扩展的方式获得所需服务。这种服务可以是IT和软件、互联网相关，也可是其他服务。它意味着计算能力也可作为一种商品通过互联网进行流通。</p>
</blockquote>
<h2 id="云计算概念"><a href="#云计算概念" class="headerlink" title="云计算概念"></a>云计算概念</h2><blockquote>
<p>云计算（cloud computing）是分布式计算的一种，指的是通过网络”云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。</p>
</blockquote>
<h2 id="云游戏概念"><a href="#云游戏概念" class="headerlink" title="云游戏概念"></a>云游戏概念</h2><blockquote>
<p>云游戏（cloud game）是以云计算为基础的游戏方式，在云游戏的运行模式下，所有游戏都在服务器端运行，并将渲染完毕后的游戏画面压缩后通过网络传送给用户。在客户端，用户的游戏设备不需要任何高端处理器和显卡，只需要基本的视频解压能力就可以了。</p>
</blockquote>
<h1 id="云游戏产生原因分析"><a href="#云游戏产生原因分析" class="headerlink" title="云游戏产生原因分析"></a>云游戏产生原因分析</h1><h2 id="大型网络游戏的普及"><a href="#大型网络游戏的普及" class="headerlink" title="大型网络游戏的普及"></a><strong>大型网络游戏的普及</strong></h2><blockquote>
<p><img src="https://pic.imgdb.cn/item/64321da80d2dde5777bb995b.jpg">近年来，越来越多大型网络游戏出现，同时玩家人数也一直在不断上涨。</p>
</blockquote>
<h2 id="硬件性能的限制"><a href="#硬件性能的限制" class="headerlink" title="硬件性能的限制"></a>硬件性能的限制</h2><blockquote>
<p>一般来说，此类大型网络游戏对于游戏设备的性能都有相对较高的要求，同时游戏的包体也很大（如《原神》3.4版本PC端占用53.1GB，云游戏则只有300多MB）而一般的游戏玩家并不愿意因此承担高昂的硬件费用，所以云游戏便成为了相当一部分的用户选择。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/64321dd30d2dde5777bbd706.jpg"></p>
<p>上图为<code>原神</code>Windows端完整包体</p>
<p><img src="https://pic.imgdb.cn/item/64321de10d2dde5777bbe7a6.jpg"></p>
<p>上图为<code>原神</code>云游戏包体</p>
<h1 id="云游戏相关基础技术"><a href="#云游戏相关基础技术" class="headerlink" title="云游戏相关基础技术"></a>云游戏相关基础技术</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><blockquote>
<p>虚拟化技术（Virtualization Technology）和多任务（Multitasking）、超线程技术（Hyper-Threading）是完全不同的。多任务是指在一个操作系统中多个程序同时并行运行，而在虚拟化技术中，你可以拥有多个独立的操作系统同时运行，每一个操作系统中都有多个程序运行，每一个操作系统都运行在一个虚拟的CPU或虚拟主机（虚拟机）上。而Hyper-Threading超线程只是在SMP系统（Symmetric Multi Processing）中单CPU模拟双CPU来平衡程序运行性能，这两个模拟出来的CPU是不能分离的，只能协同工作。如果一个CPU同时支持Hyper-Threading和虚拟化技术的话，每一个虚拟CPU在各自的操作系统中都被看成是两个对称多任务处理的CPU。</p>
<p>虚拟化技术使得游戏厂商并不用将游戏进行很大的改动便可以移植到云游戏平台上同时让玩家获得原汁原味的游戏体验。虚拟化技术是云计算对实现计算资源和存储资源充分高效利用的关键。这项技术可以将对象的操作系统、计算机系统、存储设备和网络资源等进行虚拟化并生成--个虚拟版本,使得用户可以用与访问抽象前资源--致的方法访问抽象后的资源。从而隐藏属性和操作之间的差异并允许通过一种通用的方式来查看和维护资源，将应用程序以及数据，在不同的层次以不同的面貌加以展现,进而使不同层次的使用者、开发者及维持人员能够方便的使用，开发，维护和管理程序。</p>
</blockquote>
<h2 id="远程渲染映射（Remote-Rendering-Mapping）技术"><a href="#远程渲染映射（Remote-Rendering-Mapping）技术" class="headerlink" title="远程渲染映射（Remote Rendering Mapping）技术"></a>远程渲染映射（Remote Rendering Mapping）技术</h2><blockquote>
<p>基本原理是用户在客户端发出各种游戏的指令和控制信号，由网络传送到云游戏的云端服务器平台，云端服务器运用其强大的处理器和显卡对游戏画面进行渲染并对游戏涉及到的数据进行运算。最后将渲染完毕的游戏画面形成视频流并压缩（一般基于H.264或H.265编码）通过高速网络传送至客户端解压呈现在终端显示部件上。是云游戏的核心技术。</p>
</blockquote>
<p>a.  指令流的实现框架<img src="https://pic.imgdb.cn/item/64321e370d2dde5777bc4481.jpg"></p>
<p>b.  音视频流的实现框架<img src="https://pic.imgdb.cn/item/64321e490d2dde5777bc580f.jpg"></p>
<p>c.  云游戏完整框架</p>
<p><img src="https://pic.imgdb.cn/item/64321e640d2dde5777bc77d5.jpg"></p>
<h1 id="云游戏运营模式"><a href="#云游戏运营模式" class="headerlink" title="云游戏运营模式"></a>云游戏运营模式</h1><blockquote>
<p>云游戏运维主要包含边缘节点管理，游戏管理，游戏自动更新，账户管理，游戏安全管理，服务器通信等工作。云游戏需要维护大量的边缘计算节点，大量的游戏，而且游戏一般都比较大且更新频繁，需要及时处理游戏自动更新分发同步等问题。</p>
</blockquote>
<h2 id="边缘计算节点管理"><a href="#边缘计算节点管理" class="headerlink" title="边缘计算节点管理"></a>边缘计算节点管理</h2><blockquote>
<p>云游戏服务的云端是服务器集群，为了保证低延时，一般会在不同地域设置多个服务器集群，要同时维护这些节点是云游戏运营重要的一环。</p>
</blockquote>
<h1 id="云游戏相对于传统游戏的优势和劣势"><a href="#云游戏相对于传统游戏的优势和劣势" class="headerlink" title="云游戏相对于传统游戏的优势和劣势"></a>云游戏相对于传统游戏的优势和劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><blockquote>
<ol>
<li><p>云游戏不需要安装，可以快速进行游戏的访问。</p>
</li>
<li><p>云游戏的画质一般都高于终端设备。</p>
</li>
<li><p>云游戏的处理主要在服务器上进行，因此，云游戏对终端设备的要求比较低。</p>
</li>
<li><p>云游戏的游戏版本升级，全部都在服务器上进行，终端只需要更新云服务平台版本，因此游戏的版本升级，非常方便，终端无感知，每次都可以玩最新的游戏版本。</p>
</li>
</ol>
</blockquote>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><blockquote>
<ol>
<li><p>云游戏对网络传输带宽要求很高，在网络传输带宽限制下，一些高清晰度的游戏在特定的网络环境下是无法基于云游戏实现的。</p>
</li>
<li><p>云游戏对网络的时延要求也比较高，在无线网络中传输的时候，如采用4G，5G网络来传输时，容易在一些区域造成卡顿，影响玩家的体验。</p>
</li>
</ol>
</blockquote>
<h1 id="云游戏产业链"><a href="#云游戏产业链" class="headerlink" title="云游戏产业链"></a>云游戏产业链</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>云游戏产业链可以分为上游的游戏研发、中游的游戏运营云服务、下游的游戏终端。而中游的游戏运营云服务包含游戏云平台、云服务商及通信运营商三个主体。</p>
</blockquote>
<h2 id="游戏研发商"><a href="#游戏研发商" class="headerlink" title="游戏研发商"></a>游戏研发商</h2><blockquote>
<p>研发、制作游戏产品，提供内容。在云游戏时代，游戏体验跨越设备限制，用户对于游戏品质的要求预计越来越高，预计游戏品类更加重度化，龙头游戏研发商的优势有望扩大。</p>
</blockquote>
<h2 id="云游戏平台"><a href="#云游戏平台" class="headerlink" title="云游戏平台"></a>云游戏平台</h2><blockquote>
<p>负责云游戏运营，基于云化技术，负责游戏指令流和视频流的编解码，将游戏内容和IaaS （Infrastructure as a Service，基础设施即服务）有云对接。分为 PC云游戏平台和移动云游戏平台两大赛道，大量初创公司在 2012-2015年切入此领域，通过提过游戏运营的云化服务，产生订阅收入。巨头如华为、腾讯2019年通过合作和推出自有平台的方式切入该领域。预计订阅收入将成为云游戏平台的主要收入来源，也将成为云游戏时代除了游戏内道具付费之外的重要变现方式。</p>
</blockquote>
<h2 id="云服务商"><a href="#云服务商" class="headerlink" title="云服务商"></a>云服务商</h2><blockquote>
<p>具备IDC（Internet Data Center，互联网数据中心）提供算力和存储服务，主要为 IaaS公有云平台，包括阿里云、腾讯云、华为云、百度云等。游戏只是其云计算服务的一个领域。</p>
</blockquote>
<h2 id="通信运营商"><a href="#通信运营商" class="headerlink" title="通信运营商"></a>通信运营商</h2><blockquote>
<p>高速稳定的网络是游戏数据传输和游戏画面流畅的先决条件。运营商的 5G网络具备高下载速度、低延迟等优势，成为用户终端-云平台数据传输的重要通道。同时，运营商在推广5G套餐时，云游戏可能成为重要的内容抓手，因此运营商在云游戏领域或将拥有用户入口优势，成为重要的分发平台。</p>
</blockquote>
<h2 id="设备提供商"><a href="#设备提供商" class="headerlink" title="设备提供商"></a>设备提供商</h2><blockquote>
<p>由于云游戏将游戏的运行放在云端，终端设备只需有游戏画面呈现功能即可，用户存量的智能手机、平板电脑、PC、智能电视以及集成游戏内容的智能机顶盒等都可成为云游戏的终端。因为云游戏对终端设备较低的要求，设备提供商在云游戏产业链中处于相对弱势地位。</p>
</blockquote>
<h1 id="云游戏未来发展趋势"><a href="#云游戏未来发展趋势" class="headerlink" title="云游戏未来发展趋势"></a>云游戏未来发展趋势</h1><h2 id="游戏研发商-1"><a href="#游戏研发商-1" class="headerlink" title="游戏研发商"></a>游戏研发商</h2><blockquote>
<p>游戏重度化趋势加剧，头部研发商市场份额将进一步提升。</p>
</blockquote>
<h2 id="游戏云平台"><a href="#游戏云平台" class="headerlink" title="游戏云平台"></a>游戏云平台</h2><blockquote>
<p>由初创公司百花齐放，到初创公司与新入局的巨头加强合作，最终具备 IaaS资源的云计算巨头和拥有用户、流量优势的企业有望主导产业链该环节。云游戏产业链中，由于游戏云平台这一环节的出现，订阅云服务有望成为游戏行业继付费下载、游戏内付费（主要为道具付费）之后又一主流变现模式。订阅服务收入在游戏收入中的占比有望不断提升，云游戏带来用户对硬件需求的降低将转移对订阅云服务需求的提升。</p>
</blockquote>
<h2 id="通信运营商-1"><a href="#通信运营商-1" class="headerlink" title="通信运营商"></a>通信运营商</h2><blockquote>
<p>云游戏时代，由于游戏即点即玩、无需下载，应用商店等渠道作用将弱化，但云游戏作为5G重要应用领域，通信运营商基于5G 网络入口优势，较过去 4G时代有望更多切入游戏云平台运营、甚至研发环节。在 4G时代，三大通信运营商更多承担数据传输通道的作用，数据业务收入取得大幅增长。而随着5G来临，四大运营商将不甘于仅仅起到数据通道作用，而是纷纷通过自身加大资金投入以及外部合作的方式，力图深度参与5G应用。尤其是在5G推广的初期，将流量与内容绑定、通过内容来吸引用户订购5G套餐，或将成为运营商的重要营销方式。云游戏是5G娱乐应用领域比超高清视频、VR&#x2F;AR更早爆发和更成熟的应用，通信运营商或将基于自身海量用户，通过与游戏内容方、硬件终端合作的方式，切入游戏云平台运营、甚至研发领域。</p>
</blockquote>
<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><blockquote>
<p>《2020-2026年中国云游戏行业市场研究分析及未来前景展望报告》数据显示：随着5G网络的正式商用，让云游戏再次成为了行业风口。据调查数据显示，2020年中国云游戏用户达到 2.47 亿人，同比增长 114.8%，并在 2023 年增至6.58亿;云游戏市场在 2020 年将达到 68 亿元，并在 2023 年增至 986 亿元</p>
<p>如大家所见，云游戏必将成为云计算中的相当重要的应用，随着广电技术的推广和网络的改善，云游戏的时代已经接近。在未来，云游戏一定会为我们的生活创造更多的精彩!</p>
</blockquote>
<p>参考文献：</p>
<ol>
<li><p><a href="https://baike.baidu.com/item/%E4%BA%91%E6%9C%8D%E5%8A%A1/7843499?fr=aladdin">百度百科：云服务</a>[引用日期：2023年1月30日]</p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97/9969353?fromModule=lemma-qiyi_sense-lemma">百度百科：云计算</a>[引用日期：2023年1月30日]</p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E4%BA%91%E6%B8%B8%E6%88%8F/1404089?fr=aladdin">百度百科：云服务</a>[引用日期：2023年1月30日]</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>すずめの戸締まり</title>
    <url>/2023/03/26/%E3%81%99%E3%81%9A%E3%82%81%E3%81%AE%E6%88%B8%E7%B7%A0%E3%81%BE%E3%82%8A/</url>
    <content><![CDATA[<blockquote>
<p><strong>我深知命如蜉蝣，深知死亡总是如影随形。再多一时也好。我辈仍愿人生得续。</strong></p>
</blockquote>
<span id="more"></span>

<p><img src="https://pic.imgdb.cn/item/641ff1d9a682492fcc77838b.jpg"></p>
<blockquote>
<p><strong>思而复思 祈唤日不见之神，祈唤祖祖代代之土地神。此山此河 承恩甚久 不胜感激。</strong></p>
<p><strong>诚惶诚恐。</strong></p>
<p><strong>诚惶诚恐。</strong></p>
<p><strong>谨遵神旨，予以奉还。</strong></p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/641ff914a682492fcc854747.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ff914a682492fcc85479e.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ff914a682492fcc854826.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ff914a682492fcc85487e.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ff915a682492fcc85490f.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ffad5a682492fcc88066e.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ffa4da682492fcc87388d.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/641ff916a682492fcc854cb1.jpg"></p>
<p><strong>虽然你觉得世界一片黑暗，但是黎明总会到来。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>作业1</title>
    <url>/2023/04/08/%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<p><strong>作业1</strong></p>
<span id="more"></span>

<p><a href="https://wwft.lanzoul.com/iwnxG0siclej">下载</a></p>
<h1 id="任务1：恐龙山洞"><a href="#任务1：恐龙山洞" class="headerlink" title="任务1：恐龙山洞"></a>任务1：恐龙山洞</h1><h2 id="【任务要求】"><a href="#【任务要求】" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>设计一个恐龙山洞的游戏，在游戏开始逐句呈现游戏故事背景，营造出紧张的氛围。</p>
</li>
<li><p>玩家选择进入1号或2号山洞，如果进入圆顶龙的山洞，获得宝藏；如果进入窃蛋龙的山洞，被窃蛋龙吞进肚子。圆顶龙和窃蛋龙所住的山洞每次游戏随机决定。</p>
</li>
<li><p>玩家输入的过程需设置检查机制，如果玩家输入了除1或2之外的其他内容，提示玩家重新选择，增强程序的容错性。</p>
</li>
<li><p>可发挥自己的创意，为游戏添加其他功能和剧情。</p>
</li>
</ol>
<h2 id="【示例代码】"><a href="#【示例代码】" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">game</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;恐龙山洞游戏开始！\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;现在，你来到了1亿4500万年前，侏罗纪时期。\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这里有体型巨大的圆顶龙、梁龙，有凶猛的永川龙、窃蛋龙……稍不注意，你就可能被巨大的恐龙一脚踩成一张纸片!\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你跑啊跑，忽然看见前方有两个山洞。\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你来到了山洞口，发现有两个山洞，一个是圆顶龙的山洞，另一个是窃蛋龙的山洞。\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其中一个山洞里，住着友好的食草恐龙圆顶龙，它会送你一个宝藏，助你回到21世纪。而另一个山洞里…….\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;住着一只贪婪又饥饿的食肉恐龙窃蛋龙，它可能会把你吞进肚子里!\n&quot;</span>)</span><br><span class="line">    chosen_cave = <span class="built_in">input</span>(<span class="string">&quot;你要选择进入哪个山洞？输入 1 或 2：&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> chosen_cave != <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> chosen_cave != <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        chosen_cave = <span class="built_in">input</span>(<span class="string">&quot;输入无效，请重新选择：&quot;</span>)</span><br><span class="line">    chosen_cave = <span class="built_in">int</span>(chosen_cave)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你走进了山洞...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;黑暗中，你听到了一阵咆哮声...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你看到了一双发光的眼睛，它们向你靠近...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你发现你已经走进了&quot;</span>, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    cave_number = random.randint(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> cave_number == chosen_cave:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;圆顶龙的山洞！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你发现了宝藏！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;窃蛋龙的山洞！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;窃蛋龙把你吞进了肚子里！&quot;</span>)</span><br><span class="line">    play_again = <span class="built_in">input</span>(<span class="string">&quot;再来一局？输入 y 或 n：&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> play_again != <span class="string">&#x27;y&#x27;</span> <span class="keyword">and</span> play_again != <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        play_again = <span class="built_in">input</span>(<span class="string">&quot;输入无效，请重新选择：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> play_again == <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        game()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;游戏结束！&quot;</span>)</span><br><span class="line"></span><br><span class="line">game()</span><br></pre></td></tr></table></figure>



<h2 id="【运行示例】"><a href="#【运行示例】" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/643141da0d2dde5777842d1b.jpg"></p>
<h1 id="任务2：绘制迷宫"><a href="#任务2：绘制迷宫" class="headerlink" title="任务2：绘制迷宫"></a>任务2：绘制迷宫</h1><h2 id="【任务要求】-1"><a href="#【任务要求】-1" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>使用turtle模块绘制一个迷宫，迷宫可如运行示例中所示，也可自行设计一个更为复杂的迷宫。</p>
</li>
<li><p>如有重复执行的代码，需用函数进行封装。</p>
</li>
</ol>
<h2 id="【示例代码】-1"><a href="#【示例代码】-1" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画笔移动函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_pen</span>(<span class="params">x, y</span>):</span><br><span class="line">    turtle.penup()</span><br><span class="line">    turtle.goto(x, y)</span><br><span class="line">    turtle.pendown()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义绘制迷宫函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_maze</span>():</span><br><span class="line">    <span class="comment"># 画笔起始位置</span></span><br><span class="line">    move_pen(-<span class="number">150</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制迷宫外框</span></span><br><span class="line">    turtle.forward(<span class="number">300</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">300</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">300</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">300</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制迷宫内部线条</span></span><br><span class="line">    move_pen(-<span class="number">150</span>, <span class="number">50</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(-<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(-<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(-<span class="number">50</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(-<span class="number">100</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(-<span class="number">100</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line">    move_pen(<span class="number">50</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(<span class="number">100</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">50</span>)</span><br><span class="line">    move_pen(<span class="number">100</span>, -<span class="number">50</span>)</span><br><span class="line">    turtle.right(<span class="number">90</span>)</span><br><span class="line">    turtle.forward(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画布大小和背景颜色</span></span><br><span class="line">turtle.setup(<span class="number">500</span>, <span class="number">500</span>)</span><br><span class="line">turtle.bgcolor(<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐藏画笔形状</span></span><br><span class="line">turtle.hideturtle()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用绘制迷宫函数</span></span><br><span class="line">draw_maze()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示画布</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在这个程序中，我们首先定义了两个函数 <code>move_pen</code> 和 <code>draw_maze</code>。其中 <code>move_pen</code> 函数用于移动画笔到指定的位置，<code>draw_maze</code> 函数用于绘制迷宫。在绘制迷宫时，我们使用了 <code>move_pen</code> 函数来移动画笔到指定的位置，并使用 <code>turtle.forward</code> 和 <code>turtle.right</code> 函数来控制画笔的移动和转向。</p>
<p>最后，我们设置了画布的大小和背景颜色，并调用 <code>draw_maze</code> 函数来绘制迷宫。完成绘制后，我们展示了画布并结束程序。</p>
</blockquote>
<h2 id="【运行示例】-1"><a href="#【运行示例】-1" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/6431424e0d2dde5777859825.jpg"></p>
<h1 id="任务3：绘制爱心"><a href="#任务3：绘制爱心" class="headerlink" title="任务3：绘制爱心"></a>任务3：绘制爱心</h1><h2 id="【任务要求】-2"><a href="#【任务要求】-2" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>绘制一个爱心，边线为红色，填充为粉色。并在爱心下面写一段祝福语。</p>
</li>
<li><p>如有其他设计，可在图中添加。</p>
</li>
</ol>
<h2 id="【示例代码】-2"><a href="#【示例代码】-2" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置画布大小和背景颜色</span></span><br><span class="line">turtle.setup(<span class="number">600</span>, <span class="number">400</span>)</span><br><span class="line">turtle.bgcolor(<span class="string">&quot;white&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画笔</span></span><br><span class="line">pen = turtle.Turtle()</span><br><span class="line">pen.speed(<span class="number">0</span>)  <span class="comment"># 设置画笔速度为最快</span></span><br><span class="line">pen.hideturtle()  <span class="comment"># 隐藏画笔形状</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制爱心</span></span><br><span class="line">pen.color(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;pink&quot;</span>)  <span class="comment"># 设置边线颜色和填充颜色</span></span><br><span class="line">pen.begin_fill()  <span class="comment"># 开始填充</span></span><br><span class="line">pen.left(<span class="number">45</span>)  <span class="comment"># 向左旋转45度</span></span><br><span class="line">pen.forward(<span class="number">150</span>)  <span class="comment"># 向前移动150像素</span></span><br><span class="line">pen.circle(<span class="number">75</span>, <span class="number">180</span>)  <span class="comment"># 绘制半圆弧</span></span><br><span class="line">pen.right(<span class="number">90</span>)  <span class="comment"># 向右旋转90度</span></span><br><span class="line">pen.circle(<span class="number">75</span>, <span class="number">180</span>)  <span class="comment"># 绘制半圆弧</span></span><br><span class="line">pen.forward(<span class="number">150</span>)  <span class="comment"># 向前移动150像素</span></span><br><span class="line">pen.end_fill()  <span class="comment"># 结束填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写祝福语</span></span><br><span class="line">pen.penup()  <span class="comment"># 抬起画笔</span></span><br><span class="line">pen.goto(<span class="number">0</span>, -<span class="number">180</span>)  <span class="comment"># 移动到爱心下方</span></span><br><span class="line">pen.color(<span class="string">&quot;black&quot;</span>)  <span class="comment"># 设置字体颜色</span></span><br><span class="line">pen.write(<span class="string">&quot;Sherryforever!&quot;</span>, align=<span class="string">&quot;center&quot;</span>, font=(<span class="string">&quot;Arial&quot;</span>, <span class="number">20</span>, <span class="string">&quot;normal&quot;</span>))  <span class="comment"># 编写祝福语</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示画布</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>



<h2 id="【运行示例】-2"><a href="#【运行示例】-2" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/643144430d2dde57778ae8ad.jpg"></p>
<h1 id="任务4：绘制年轮"><a href="#任务4：绘制年轮" class="headerlink" title="任务4：绘制年轮"></a>任务4：绘制年轮</h1><h2 id="【任务要求】-3"><a href="#【任务要求】-3" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>假设一棵树每长一年，就增加一圈年轮，且相邻年轮之间的宽度大约是1cm（gap &#x3D; 1）。请设计程序，让用户输入树的半径，然后画出这棵树的年轮图，并计算它的树龄。</p>
</li>
<li><p>请用循环和递归两种方法完成。</p>
</li>
</ol>
<h2 id="【示例代码】-3"><a href="#【示例代码】-3" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><ol>
<li><p>循环实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt user for tree radius</span></span><br><span class="line">radius = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the radius of the tree(cm): &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate tree age</span></span><br><span class="line">age = radius / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics window</span></span><br><span class="line">window = turtle.Screen()</span><br><span class="line">window.bgcolor(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">window.title(<span class="string">&quot;Tree Ring Chart&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics pen</span></span><br><span class="line">pen = turtle.Turtle()</span><br><span class="line">pen.speed(<span class="number">0</span>)</span><br><span class="line">pen.color(<span class="string">&quot;brown&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw tree rings</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(radius)):</span><br><span class="line">    pen.circle(i * <span class="number">10</span>)</span><br><span class="line">    pen.penup()</span><br><span class="line">    pen.goto(<span class="number">0</span>,-i*<span class="number">10</span>)</span><br><span class="line">    pen.pendown()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display tree age</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Age:&quot;</span> , radius/<span class="number">1</span> ,<span class="string">&quot;years&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keep turtle graphics window open until user closes it</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_tree_rings</span>(<span class="params">radius, max_radius</span>):</span><br><span class="line">    pen.circle(radius * <span class="number">10</span>)</span><br><span class="line">    pen.penup()</span><br><span class="line">    pen.goto(<span class="number">0</span>, -radius * <span class="number">10</span>)</span><br><span class="line">    pen.pendown()</span><br><span class="line">    <span class="keyword">if</span> radius &lt; max_radius:</span><br><span class="line">        draw_tree_rings(radius + <span class="number">1</span>, max_radius)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt user for tree radius</span></span><br><span class="line">radius = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;Enter the radius of the tree(cm): &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate tree age</span></span><br><span class="line">age = radius / <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics window</span></span><br><span class="line">window = turtle.Screen()</span><br><span class="line">window.bgcolor(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">window.title(<span class="string">&quot;Tree Ring Chart&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics pen</span></span><br><span class="line">pen = turtle.Turtle()</span><br><span class="line">pen.speed(<span class="number">0</span>)</span><br><span class="line">pen.color(<span class="string">&quot;brown&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw tree rings recursively</span></span><br><span class="line">draw_tree_rings(<span class="number">0</span>, <span class="built_in">int</span>(radius))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display tree age</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Age:&quot;</span>, radius / <span class="number">1</span>, <span class="string">&quot;years&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keep turtle graphics window open until user closes it</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="【运行示例】-3"><a href="#【运行示例】-3" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p>用户输入半径为10，程序绘制出10圈年轮，年轮间隔为1。</p>
<h1 id="任务5：数字炸弹"><a href="#任务5：数字炸弹" class="headerlink" title="任务5：数字炸弹"></a>任务5：数字炸弹</h1><h2 id="【任务要求】-4"><a href="#【任务要求】-4" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>设计一个数字炸弹的游戏，用户输入炸弹的上限和下限，程序随机设置上限和下限之间的某个数为“炸弹数字”。</p>
</li>
<li><p>玩家轮流输入一个数字，当输入的数字是“炸弹数字”，触发“爆炸”，游戏结束；若输入的数字不是“炸弹数字”，程序提示玩家“炸弹数字”新的范围，游戏继续。</p>
</li>
<li><p>玩家输入数字时需设置检查机制，当玩家输入新范围以外的数字，提示玩家重新输入。</p>
</li>
</ol>
<h2 id="【示例代码】-4"><a href="#【示例代码】-4" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_number_within_range</span>(<span class="params">lower, upper</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取一个在指定范围内的随机整数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> random.randint(lower, upper)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取炸弹数字的上下限</span></span><br><span class="line">    lower = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入炸弹数字的下限：&quot;</span>))</span><br><span class="line">    upper = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入炸弹数字的上限：&quot;</span>))</span><br><span class="line">    <span class="comment"># 随机生成炸弹数字</span></span><br><span class="line">    bomb_number = get_number_within_range(lower, upper)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;炸弹数字已经生成，游戏开始！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 玩家轮流猜数字</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请猜一个数字：&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> guess == bomb_number:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;炸弹爆炸了，游戏结束！&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> guess &lt; lower <span class="keyword">or</span> guess &gt; upper:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入的数字不在炸弹数字的范围内，请重新输入！&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> guess &lt; bomb_number:</span><br><span class="line">            lower = guess</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;炸弹数字现在的范围是：&#123;&#125; ~ &#123;&#125;&quot;</span>.<span class="built_in">format</span>(lower, upper))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            upper = guess</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;炸弹数字现在的范围是：&#123;&#125; ~ &#123;&#125;&quot;</span>.<span class="built_in">format</span>(lower, upper))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这个程序首先通过 <code>get_number_within_range()</code> 函数随机生成了一个炸弹数字，然后进入了一个无限循环，直到玩家猜中了炸弹数字或者输入了一个范围外的数字。每次循环中，程序会首先判断玩家猜的数字是否等于炸弹数字，如果是则游戏结束；否则，程序会判断玩家猜的数字是否在炸弹数字的范围内，如果不是则提示玩家重新输入；如果是，则更新炸弹数字的范围，并提示玩家新的范围。</p>
</blockquote>
<h2 id="【运行示例】-4"><a href="#【运行示例】-4" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/64314e580d2dde5777a1845f.jpg"></p>
<h1 id="任务6：绘制螺旋爆炸"><a href="#任务6：绘制螺旋爆炸" class="headerlink" title="任务6：绘制螺旋爆炸"></a>任务6：绘制螺旋爆炸</h1><h2 id="【任务要求】-5"><a href="#【任务要求】-5" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>绘制一个螺旋爆炸图案。该图案由5组呈发射状的圆形组成，同一条曲线上有10个圆形，圆形半径逐渐增大，且颜色相同；不同曲线上的圆形颜色不同。</p>
</li>
<li><p>可再次基础上进行再创作。</p>
</li>
</ol>
<h2 id="【示例代码】-5"><a href="#【示例代码】-5" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define colors for each curve</span></span><br><span class="line">colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics window</span></span><br><span class="line">window = turtle.Screen()</span><br><span class="line">window.bgcolor(<span class="string">&quot;white&quot;</span>)</span><br><span class="line">window.title(<span class="string">&quot;Spiral Explosion Pattern&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up turtle graphics pen</span></span><br><span class="line">pen = turtle.Turtle()</span><br><span class="line">pen.speed(<span class="number">0</span>)</span><br><span class="line">pen.width(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw spiral explosion pattern</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    pen.color(colors[i])</span><br><span class="line">    pen.fillcolor(colors[i])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pen.begin_fill()</span><br><span class="line">        pen.circle((j+<span class="number">1</span>)*<span class="number">3</span>)</span><br><span class="line">        pen.end_fill()</span><br><span class="line">        pen.left(<span class="number">15</span>)</span><br><span class="line">        pen.penup()</span><br><span class="line">        pen.forward((j+<span class="number">1</span>) * <span class="number">10</span>)</span><br><span class="line">        pen.pendown()</span><br><span class="line">    </span><br><span class="line">    pen.penup()</span><br><span class="line">    pen.goto(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    pen.right(<span class="number">150</span>)</span><br><span class="line">    pen.left(<span class="number">72</span>)</span><br><span class="line">    pen.pendown()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keep turtle graphics window open until user closes it</span></span><br><span class="line">turtle.done()</span><br></pre></td></tr></table></figure>



<h2 id="【运行示例】-5"><a href="#【运行示例】-5" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/64318d350d2dde577709e22f.jpg"></p>
<h1 id="任务7：田忌赛马1"><a href="#任务7：田忌赛马1" class="headerlink" title="任务7：田忌赛马1"></a>任务7：田忌赛马1</h1><h2 id="【任务要求】-6"><a href="#【任务要求】-6" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li>田忌赛马的故事我们都听过，齐国大将田忌和齐威王约定赛马，三局两胜。双方都有三个等级的马，分别是上马、中马和下马。齐威王各个等级的马都比田忌各个等级的马要厉害，但田忌的上马能赢齐王的中马；田忌的中马能赢齐王的下马。假设齐王的出马顺序总为“上马-中马-下马”，请设计程序，遍历输出田忌所有可能的出马顺序，及相应的获胜情况。</li>
</ol>
<h2 id="【示例代码】-6"><a href="#【示例代码】-6" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">horses = &#123;<span class="string">&quot;上马&quot;</span>: <span class="number">3</span>, <span class="string">&quot;中马&quot;</span>: <span class="number">2</span>, <span class="string">&quot;下马&quot;</span>: <span class="number">1</span>&#125; <span class="comment"># 马匹等级</span></span><br><span class="line">tianji_horses = &#123;<span class="string">&quot;上马&quot;</span>: <span class="number">6</span>, <span class="string">&quot;中马&quot;</span>: <span class="number">4</span>, <span class="string">&quot;下马&quot;</span>: <span class="number">2</span>&#125; <span class="comment"># 田忌的马</span></span><br><span class="line">qi_horses = &#123;<span class="string">&quot;上马&quot;</span>: <span class="number">7</span>, <span class="string">&quot;中马&quot;</span>: <span class="number">5</span>, <span class="string">&quot;下马&quot;</span>: <span class="number">3</span>&#125; <span class="comment"># 齐王的马</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compete</span>(<span class="params">h1, h2</span>): <span class="comment"># 两匹马比赛，返回1代表田忌胜利，返回0代表平局，返回-1代表田忌失败</span></span><br><span class="line">    <span class="keyword">if</span> tianji_horses[h1] &gt; qi_horses[h2]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> tianji_horses[h1] == qi_horses[h2]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">horses_order</span>): <span class="comment"># 一局比赛</span></span><br><span class="line">    tianji_order = horses_order</span><br><span class="line">    qi_order = [<span class="string">&quot;上马&quot;</span>, <span class="string">&quot;中马&quot;</span>, <span class="string">&quot;下马&quot;</span>]</span><br><span class="line">    win_count = <span class="number">0</span> <span class="comment"># 获胜场数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment"># 三局比赛</span></span><br><span class="line">        result = compete(tianji_order[i], qi_order[i])</span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">1</span>:</span><br><span class="line">            win_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> result == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            win_count -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> win_count &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_horses_order</span>(<span class="params">horses_list</span>): <span class="comment"># 从马匹列表中获取所有可能的出马顺序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(horses_list) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [horses_list]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        orders = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(horses_list)):</span><br><span class="line">            rest_horses = horses_list[:i] + horses_list[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> order <span class="keyword">in</span> get_horses_order(rest_horses):</span><br><span class="line">                orders.append([horses_list[i]] + order)</span><br><span class="line">        <span class="keyword">return</span> orders</span><br><span class="line"></span><br><span class="line">all_orders = get_horses_order(<span class="built_in">list</span>(horses.keys())) <span class="comment"># 获取所有可能的出马顺序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> order <span class="keyword">in</span> all_orders:</span><br><span class="line">    <span class="keyword">if</span> play_game(order):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;田忌获胜，出马顺序为：&quot;</span>, order)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;田忌失败，出马顺序为：&quot;</span>, order)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这段代码是一个田忌赛马的游戏，其中包含了三个字典，分别表示马匹等级、田忌的马和齐王的马。其中，马匹等级分为上马、中马和下马三个等级。</p>
<p>函数compete表示两匹马比赛的结果，当田忌的马的等级高于齐王的马时，返回1；当两者等级相同时，返回0；否则返回-1。</p>
<p>函数play_game表示一局比赛的过程，首先用传入的马匹顺序来排列田忌和齐王的马，然后进行三次比赛，统计田忌获胜的次数，最后判断获胜次数是否大于平局和失败的次数之和，如果是则返回True，否则返回False。</p>
<p>函数get_horses_order用于获取所有可能的出马顺序，通过递归来获取所有可能的排列方式。</p>
<p>最后，通过获取所有可能的出马顺序，分别进行比赛，并输出胜利或失败的结果以及出马顺序。</p>
</blockquote>
<h2 id="【运行示例】-6"><a href="#【运行示例】-6" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/643158e80d2dde5777b63498.jpg"></p>
<h1 id="任务8：田忌赛马2"><a href="#任务8：田忌赛马2" class="headerlink" title="任务8：田忌赛马2"></a>任务8：田忌赛马2</h1><h2 id="【任务要求】-7"><a href="#【任务要求】-7" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><p>生活中，胜利与否具有一定概率。假设田马的三匹马分别为A、B、C，齐马的三匹马分别为X、Y、Z，田马赢得齐马的胜率如下表所示。例如，田忌的A马赢得齐王的X马的概率为0.4，赢得齐王的Y马的概率为0.8，赢得齐王的Z马的概率为0.9。</p>
<p><img src="https://pic.imgdb.cn/item/643174240d2dde5777e2e2e1.jpg"></p>
<p>假设齐王的出马顺序总为“X-Y-Z”，请设计程序，遍历田马所有可能的出场顺序，并计算各个出场顺序的胜率，输出田马获胜的最大胜率和对应的出场顺序。</p>
<h2 id="【示例代码】-7"><a href="#【示例代码】-7" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 马的赢率矩阵</span></span><br><span class="line">win_rate = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;X&#x27;</span>: <span class="number">0.4</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">0.8</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="number">0.9</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;X&#x27;</span>: <span class="number">0.2</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">0.3</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="number">0.8</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;X&#x27;</span>: <span class="number">0.1</span>, <span class="string">&#x27;Y&#x27;</span>: <span class="number">0.2</span>, <span class="string">&#x27;Z&#x27;</span>: <span class="number">0.4</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义出场顺序</span></span><br><span class="line">tianqi = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">qiwang = [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算田忌所有可能的出场顺序</span></span><br><span class="line">tianqi_order = <span class="built_in">list</span>(itertools.permutations(tianqi))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化最大胜率和对应的出场顺序</span></span><br><span class="line">max_win_rate = <span class="number">0</span></span><br><span class="line">max_order = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有可能的出场顺序</span></span><br><span class="line"><span class="keyword">for</span> order <span class="keyword">in</span> tianqi_order:</span><br><span class="line">    <span class="comment"># 计算当前出场顺序的胜率</span></span><br><span class="line">    win_rate_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(order)):</span><br><span class="line">        win_rate_sum += win_rate[order[i]][qiwang[i]]</span><br><span class="line">    current_win_rate = win_rate_sum / <span class="built_in">len</span>(order)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果当前胜率大于最大胜率，更新最大胜率和对应的出场顺序</span></span><br><span class="line">    <span class="keyword">if</span> current_win_rate &gt; max_win_rate:</span><br><span class="line">        max_win_rate = current_win_rate</span><br><span class="line">        max_order = order</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;田忌获胜的最大胜率为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(max_win_rate))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;田忌出场顺序为：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(max_order))</span><br></pre></td></tr></table></figure>



<blockquote>
<p>田忌赛马问题的解法思路是使用贪心算法，即优先选择赢率最大的马进行比赛。</p>
<p>在该 Python 代码实现中，使用了 <code>itertools</code> 库中的 <code>permutations</code> 函数。<code>permutations</code> 函数可以生成给定序列的所有可能排列，以元组(tuple)的形式返回。该函数可以帮助我们实现田忌和齐王马的出战排列组合，将所有可能的出战顺序排列生成，方便计算每个排列的胜率并比较胜率大小。</p>
<p>具体实现方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有可能的出场顺序</span></span><br><span class="line">orders = <span class="built_in">list</span>(itertools.permutations([<span class="string">&#x27;t1&#x27;</span>, <span class="string">&#x27;t2&#x27;</span>, <span class="string">&#x27;t3&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>上述代码将生成 [“t1”, “t2”, “t3”] 的所有可能排列，排序结果为 [(‘t1’, ‘t2’, ‘t3’), (‘t1’, ‘t3’, ‘t2’), (‘t2’, ‘t1’, ‘t3’), (‘t2’, ‘t3’, ‘t1’), (‘t3’, ‘t1’, ‘t2’), (‘t3’, ‘t2’, ‘t1’)]。我们可以将其看作是一张表格，每行数据表示一种可能的出战顺序。可以方便地遍历所有排列组合，通过计算每种排列的胜率并比较胜率大小来得到最佳出战顺序。</p>
</blockquote>
<h2 id="【运行示例】-7"><a href="#【运行示例】-7" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/643178760d2dde5777e9de75.jpg"></p>
<h1 id="任务9：单词密码1"><a href="#任务9：单词密码1" class="headerlink" title="任务9：单词密码1"></a>任务9：单词密码1</h1><h2 id="【任务要求】-8"><a href="#【任务要求】-8" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>设计一个单词密码游戏。每次游戏从备选单词中随机选择一个单词作为要猜的单词密码，所有备选单词存放在文件中，通过文件读取的方式获得单词。</p>
</li>
<li><p>在游戏开始时，提示玩家单词密码的位数和总的能量数，玩家初始能量有6颗星。</p>
</li>
<li><p>玩家每次输入一个字母，若该字母是单词中的字母，猜对，将字母显示出来，其余没有被猜出来的字母用下划线“_”占位；若该字母不是单词中的字母，猜错，能量星减1，程序提示玩家剩余的能量值，并将所有猜错的字母显示出来（错误记录）。</p>
</li>
<li><p>当能量星减为0，还没有猜出来，游戏失败。</p>
</li>
<li><p>游戏可以重复玩，每次游戏结束询问玩家是否再次游戏。</p>
</li>
<li><p>可在此游戏基础上继续增加创意，丰富功能。</p>
</li>
</ol>
<h2 id="【示例代码】-8"><a href="#【示例代码】-8" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_word_list</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;文件夹名称\words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        word_list = f.read().splitlines()</span><br><span class="line">    <span class="keyword">return</span> word_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_word</span>(<span class="params">word_list</span>):</span><br><span class="line">    <span class="keyword">return</span> random.choice(word_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">word</span>):</span><br><span class="line">    word_length = <span class="built_in">len</span>(word)</span><br><span class="line">    energy = <span class="number">6</span></span><br><span class="line">    guessed_letters = []</span><br><span class="line">    correct_letters = []</span><br><span class="line">    wrong_letters = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to Word Password Game!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The word password has <span class="subst">&#123;word_length&#125;</span> letters.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;You have <span class="subst">&#123;energy&#125;</span> energy stars.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s start!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> letter <span class="keyword">in</span> correct_letters:</span><br><span class="line">                <span class="built_in">print</span>(letter, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;_&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(correct_letters) == word_length:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Congratulations! You guessed the password!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="built_in">input</span>(<span class="string">&quot;Guess a letter: &quot;</span>).lower()</span><br><span class="line">        <span class="keyword">if</span> guess <span class="keyword">in</span> guessed_letters:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You already guessed this letter, try another one.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        guessed_letters.append(guess)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess <span class="keyword">in</span> word:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Correct!&quot;</span>)</span><br><span class="line">            correct_letters.append(guess)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong guess!&quot;</span>)</span><br><span class="line">            energy -= <span class="number">1</span></span><br><span class="line">            wrong_letters.append(guess)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;You have <span class="subst">&#123;energy&#125;</span> energy stars left.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> energy == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Game over! You are out of energy stars!&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;The password is <span class="subst">&#123;word&#125;</span>.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letters you guessed correctly:&quot;</span>, correct_letters)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letters you guessed wrongly:&quot;</span>, wrong_letters)</span><br><span class="line"></span><br><span class="line">word_list = get_word_list()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    word = get_random_word(word_list)</span><br><span class="line">    play_game(word)</span><br><span class="line"></span><br><span class="line">    play_again = <span class="built_in">input</span>(<span class="string">&quot;Do you want to play again? (y/n): &quot;</span>).lower()</span><br><span class="line">    <span class="keyword">if</span> play_again != <span class="string">&quot;y&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thanks for playing Word Password Game!&quot;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>创建<code>words.txt</code>文件（一个单词一行，单词后不能有空格）</p>
<p>首先需要一个存储单词的文件 <code>words.txt</code>，代码中定义了一个 <code>get_word_list</code> 函数读取文件中的单词，并返回单词列表。然后定义了一个 <code>get_random_word</code> 函数，从单词列表中随机选择一个单词。接下来是 <code>play_game</code> 函数，这个函数接受一个单词作为参数，然后进入游戏循环。游戏循环中，先输出单词的长度和可用的能量星数，然后要求玩家输入字母猜测单词的字母。如果猜测正确，将字母添加到正确猜测列表中，否则将字母添加到错误猜测列表中，并减少能量星数量。如果能量星数量为零，则游戏结束。如果玩家成功猜出单词，则输出祝贺信息并结束游戏循环。最后输出玩家猜对的字母列表和错误的字母列表。在主程序中，先读取单词列表，然后无限循环，每次选择一个随机单词并开始游戏。游戏结束后询问玩家是否要再玩一次，如果不再玩一次则结束程序。</p>
</blockquote>
<h2 id="【运行示例】-8"><a href="#【运行示例】-8" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/64317ec80d2dde5777f5caa2.jpg"></p>
<h1 id="任务10：单词密码2"><a href="#任务10：单词密码2" class="headerlink" title="任务10：单词密码2"></a>任务10：单词密码2</h1><p>在任务9中，单词密码游戏已经初步成形了，但是玩几次就会发现，英文单词实在太多了，仅凭单词的字母个数猜中一个单词实在是太难了，玩家玩几次之后就容易失去兴趣。如何优化这个游戏呢？</p>
<p>我们不妨给游戏增加一个功能——提示密码单词的所属类型，比如banana、apple等都属于水果，red、yellow等都属于颜色。</p>
<h2 id="【任务要求】-9"><a href="#【任务要求】-9" class="headerlink" title="【任务要求】"></a><strong>【任务要求】</strong></h2><ol>
<li><p>在任务9的基础上，增加提示玩家密码单词所属类型的功能。包括颜色、形状、水果、动物等。</p>
</li>
<li><p>可在此游戏基础上继续增加创意，丰富功能。</p>
</li>
</ol>
<h2 id="【示例代码】-9"><a href="#【示例代码】-9" class="headerlink" title="【示例代码】"></a><strong>【示例代码】</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_word_list</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;9\words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        word_list = f.read().splitlines()</span><br><span class="line">    <span class="keyword">return</span> word_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random_word</span>(<span class="params">word_list</span>):</span><br><span class="line">    <span class="keyword">return</span> random.choice(word_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_password_type</span>(<span class="params">word</span>):</span><br><span class="line">    fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;lemon&quot;</span>, <span class="string">&quot;lime&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;strawberry&quot;</span>, <span class="string">&quot;tomato&quot;</span>,]</span><br><span class="line">    animals = [<span class="string">&quot;bat&quot;</span>, <span class="string">&quot;bear&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;deer&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;donkey&quot;</span>, <span class="string">&quot;goat&quot;</span>, <span class="string">&quot;lion&quot;</span>, <span class="string">&quot;mouse&quot;</span>, <span class="string">&quot;panda&quot;</span>, <span class="string">&quot;rabbit&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;wolf&quot;</span>]</span><br><span class="line">    colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;violet&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>,]</span><br><span class="line">    shapes = [<span class="string">&quot;square&quot;</span>, <span class="string">&quot;triangle&quot;</span>, <span class="string">&quot;rectangle&quot;</span>, <span class="string">&quot;circle&quot;</span>,]</span><br><span class="line">    <span class="keyword">if</span> word <span class="keyword">in</span> fruits:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fruit&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word <span class="keyword">in</span> animals:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;animal&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word <span class="keyword">in</span> colors:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;color&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> word <span class="keyword">in</span> shapes:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;shape&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_game</span>(<span class="params">word</span>):</span><br><span class="line">    word_length = <span class="built_in">len</span>(word)</span><br><span class="line">    energy = <span class="number">6</span></span><br><span class="line">    guessed_letters = []</span><br><span class="line">    correct_letters = []</span><br><span class="line">    wrong_letters = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_correct_letter_count</span>(<span class="params">word, correct_letters</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="built_in">set</span>(word):</span><br><span class="line">            <span class="keyword">if</span> letter <span class="keyword">in</span> correct_letters:</span><br><span class="line">                count += word.count(letter)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome to Word Password Game!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;The word password has <span class="subst">&#123;word_length&#125;</span> letters.&quot;</span>)</span><br><span class="line">    password_type = get_password_type(word)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;It belongs to the <span class="subst">&#123;password_type&#125;</span> category.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;You have <span class="subst">&#123;energy&#125;</span> energy stars.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Let&#x27;s start!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> letter <span class="keyword">in</span> correct_letters:</span><br><span class="line">                <span class="built_in">print</span>(letter, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;_&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> get_correct_letter_count(word, correct_letters) == word_length:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Congratulations! You guessed the password!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        guess = <span class="built_in">input</span>(<span class="string">&quot;Guess a letter: &quot;</span>).lower()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> guess.isalpha():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Please input a letter!&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> guess <span class="keyword">in</span> guessed_letters:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You already guessed this letter, try another one.&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        guessed_letters.append(guess)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess <span class="keyword">in</span> word:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Correct!&quot;</span>)</span><br><span class="line">            correct_letters.append(guess)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong guess!&quot;</span>)</span><br><span class="line">            energy -= <span class="number">1</span></span><br><span class="line">            wrong_letters.append(guess)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;You have <span class="subst">&#123;energy&#125;</span> energy stars left.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> energy == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Game over! You are out of energy stars!&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;The password is <span class="subst">&#123;word&#125;</span>.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letters you guessed correctly:&quot;</span>, correct_letters)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letters you guessed wrongly:&quot;</span>, wrong_letters)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">word_list = get_word_list()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    word = get_random_word(word_list)</span><br><span class="line">    play_game(word)</span><br><span class="line"></span><br><span class="line">    play_again = <span class="built_in">input</span>(<span class="string">&quot;Do you want to play again? (y/n): &quot;</span>).lower()</span><br><span class="line">    <span class="keyword">if</span> play_again != <span class="string">&quot;y&quot;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thanks for playing Word Password Game!&quot;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>这段代码实现了一个叫做“Word Password Game”（单词密码游戏）的游戏。游戏的目标是猜出一个由随机单词组成的密码，并在过程中消耗有限的能量星。游戏主体的代码是一个while循环，它在每一轮游戏中生成一个新的随机单词，并调用play_game()函数进行游戏。游戏过程中，程序会通过get_password_type()函数判断密码属于哪个类别（水果、动物、颜色和形状），并打印出相应的提示信息。玩家每次可以猜一个字母，程序会提示是否正确，同时显示已经猜中的字母和还未猜中的字母的位置。玩家在猜错时会失去能量星，当能量星消耗完毕时游戏结束，程序会告诉玩家正确的密码。如果玩家在消耗完所有能量星前猜中了密码，则玩家获胜。最后，程序会询问玩家是否想再玩一次，如果玩家选择不继续，则游戏结束，程序退出。</p>
<p>注意：如果一个单词有两个相同的字母，猜对一个的时候程序需要记录两个字符长度</p>
</blockquote>
<h2 id="【运行示例】-9"><a href="#【运行示例】-9" class="headerlink" title="【运行示例】"></a><strong>【运行示例】</strong></h2><p><img src="https://pic.imgdb.cn/item/64318a6b0d2dde5777060846.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>博客重构</title>
    <url>/2023/08/23/%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="博客重构"><a href="#博客重构" class="headerlink" title="博客重构"></a>博客重构</h1>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Python3 基本数据类型 python</title>
    <url>/2023/06/03/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>笔记</strong></p>
<span id="more"></span>

<h1 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h1><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（&#x3D;）用来给变量赋值。</p>
<p>等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">counter = 100          # 整型变量</span><br><span class="line">miles   = 1000.0       # 浮点型变量</span><br><span class="line">name    = &quot;runoob&quot;     # 字符串</span><br><span class="line"></span><br><span class="line">print (counter)</span><br><span class="line">print (miles)</span><br><span class="line">print (name)</span><br></pre></td></tr></table></figure>

<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">runoob</span><br></pre></td></tr></table></figure>

<h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b = c = 1</span><br></pre></td></tr></table></figure>

<p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a, b, c = 1, 2, &quot;runoob&quot;</span><br></pre></td></tr></table></figure>

<p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob” 分配给变量 c。</p>
<hr>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中常见的数据类型有：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>bool（布尔类型）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li>
<li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li>
</ul>
<p>此外还有一些高级的数据类型，如: 字节数组类型(bytes)。</p>
<hr>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j</span><br><span class="line">&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>此外还可以用 <code>isinstance</code> 来判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 111</span><br><span class="line">&gt;&gt;&gt; isinstance(a, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>isinstance</code> 和 <code>type</code> 的区别在于：</p>
<ul>
<li><code>type()</code>不会认为子类是一种父类类型。</li>
<li><code>isinstance()</code>会认为子类是一种父类类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; isinstance(A(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(A()) == A </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(B(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(B()) == A</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， <strong>True&#x3D;&#x3D;1、False&#x3D;&#x3D;0</strong> 会返回 <strong>True</strong>，但可以通过 <strong>is</strong> 来判断类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; issubclass(bool, int) </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True==1</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; False==0</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; True+1</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; False+1</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 1 is True</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; 0 is False</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>当你指定一个值时，Number 对象就会被创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure>

<p>您也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure>

<p>您可以通过使用del语句删除单个或多个对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>

<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>1、Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。</li>
<li>2、一个变量可以通过赋值指向不同类型的对象。</li>
<li>3、数值的除法包含两个运算符：**&#x2F;** 返回一个浮点数，**&#x2F;&#x2F;** 返回一个整数。</li>
<li>4、在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
<h3 id="数值类型实例"><a href="#数值类型实例" class="headerlink" title="数值类型实例"></a>数值类型实例</h3><table>
<thead>
<tr>
<th align="left">int</th>
<th align="left">float</th>
<th align="left">complex</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10</td>
<td align="left">0.0</td>
<td align="left">3.14j</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">15.20</td>
<td align="left">45.j</td>
</tr>
<tr>
<td align="left">-786</td>
<td align="left">-21.9</td>
<td align="left">9.322e-36j</td>
</tr>
<tr>
<td align="left">080</td>
<td align="left">32.3e+18</td>
<td align="left">.876j</td>
</tr>
<tr>
<td align="left">-0490</td>
<td align="left">-90.</td>
<td align="left">-.6545+0J</td>
</tr>
<tr>
<td align="left">-0x260</td>
<td align="left">-32.54e100</td>
<td align="left">3e+26J</td>
</tr>
<tr>
<td align="left">0x69</td>
<td align="left">70.2E-12</td>
<td align="left">4.53e-7j</td>
</tr>
</tbody></table>
<p>Python 还支持复数，复数由实数部分和虚数部分构成，可以用 <strong>a + bj</strong>，或者 <strong>complex(a,b)</strong> 表示， 复数的实部 <strong>a</strong> 和虚部 <strong>b</strong> 都是浮点型。</p>
<hr>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 括起来，同时使用反斜杠 *<em>*</em> 转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure>

<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p><a href="https://pic.imgdb.cn/item/647b2a61f024cca1731c8c36.jpg"><img src="https://pic.imgdb.cn/item/647b2a61f024cca1731c8c36.jpg"></a></p>
<p>加号 <strong>+</strong> 是字符串的连接符， 星号 ***** 表示复制当前字符串，与之结合的数字为复制的次数。实例如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">str = &#x27;Runoob&#x27;</span><br><span class="line"></span><br><span class="line">print (str)          # 输出字符串</span><br><span class="line">print (str[0:-1])    # 输出第一个到倒数第二个的所有字符</span><br><span class="line">print (str[0])       # 输出字符串第一个字符</span><br><span class="line">print (str[2:5])     # 输出从第三个开始到第五个的字符</span><br><span class="line">print (str[2:])      # 输出从第三个开始的后的所有字符</span><br><span class="line">print (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)</span><br><span class="line">print (str + &quot;TEST&quot;) # 连接字符串</span><br></pre></td></tr></table></figure>

<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob</span><br><span class="line">Runoo</span><br><span class="line">R</span><br><span class="line">noo</span><br><span class="line">noob</span><br><span class="line">RunoobRunoob</span><br><span class="line">RunoobTEST</span><br></pre></td></tr></table></figure>

<p>Python 使用反斜杠 <code>\</code> 转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 <strong>r</strong>，表示原始字符串：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;Ru\noob&#x27;)</span><br><span class="line">Ru</span><br><span class="line">oob</span><br><span class="line">&gt;&gt;&gt; print(r&#x27;Ru\noob&#x27;)</span><br><span class="line">Ru\noob</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p>
<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; word = &#x27;Python&#x27;</span><br><span class="line">&gt;&gt;&gt; print(word[0], word[5])</span><br><span class="line">P n</span><br><span class="line">&gt;&gt;&gt; print(word[-1], word[-6])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure>

<p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如 <strong>word[0] &#x3D; ‘m’</strong> 会导致错误。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li>
<li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li>
<li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>4、Python中的字符串不能改变。</li>
</ul>
<hr>
<h2 id="bool（布尔类型）"><a href="#bool（布尔类型）" class="headerlink" title="bool（布尔类型）"></a>bool（布尔类型）</h2><p>布尔类型即 True 或 False。</p>
<p>在 Python 中，True 和 False 都是关键字，表示布尔值。</p>
<p>布尔类型可以用来控制程序的流程，比如判断某个条件是否成立，或者在某个条件满足时执行某段代码。</p>
<p>布尔类型特点：</p>
<ul>
<li>布尔类型只有两个值：True 和 False。</li>
<li>布尔类型可以和其他数据类型进行比较，比如数字、字符串等。在比较时，Python 会将 True 视为 1，False 视为 0。</li>
<li>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not。这些运算符可以用来组合多个布尔表达式，生成一个新的布尔值。</li>
<li>布尔类型也可以被转换成其他数据类型，比如整数、浮点数和字符串。在转换时，True 会被转换成 1，False 会被转换成 0。</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = True</span><br><span class="line">b = False</span><br><span class="line"></span><br><span class="line"># 比较运算符</span><br><span class="line">print(2 &lt; 3)   # True</span><br><span class="line">print(2 == 3)  # False</span><br><span class="line"></span><br><span class="line"># 逻辑运算符</span><br><span class="line">print(a and b)  # False</span><br><span class="line">print(a or b)   # True</span><br><span class="line">print(not a)    # False</span><br><span class="line"></span><br><span class="line"># 类型转换</span><br><span class="line">print(int(a))   # 1</span><br><span class="line">print(float(b)) # 0.0</span><br><span class="line">print(str(a))   # &quot;True&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> 在 Python 中，所有非零的数字和非空的字符串、列表、元组等数据类型都被视为 True，只有 <strong>0、空字符串、空列表、空元组</strong>等被视为 False。因此，在进行布尔类型转换时，需要注意数据类型的真假性。</p>
<hr>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 <strong>[]</strong> 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure>

<p>索引值以 <strong>0</strong> 为开始值，**-1** 为从末尾的开始位置。</p>
<p><a href="https://pic.imgdb.cn/item/647b2b22f024cca1731d4f5a.jpg"><img src="https://pic.imgdb.cn/item/647b2b22f024cca1731d4f5a.jpg"></a></p>
<p>加号 <strong>+</strong> 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">list = [ &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2 ]</span><br><span class="line">tinylist = [123, &#x27;runoob&#x27;]</span><br><span class="line"></span><br><span class="line">print (list)            # 输出完整列表</span><br><span class="line">print (list[0])         # 输出列表第一个元素</span><br><span class="line">print (list[1:3])       # 从第二个开始输出到第三个元素</span><br><span class="line">print (list[2:])        # 输出从第三个元素开始的所有元素</span><br><span class="line">print (tinylist * 2)    # 输出两次列表</span><br><span class="line">print (list + tinylist) # 连接列表</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2]</span><br><span class="line">abcd</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &#x27;runoob&#x27;, 70.2]</span><br><span class="line">[123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;]</span><br><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;]</span><br></pre></td></tr></table></figure>

<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a[0] = 9</span><br><span class="line">&gt;&gt;&gt; a[2:5] = [13, 14, 15]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 13, 14, 15, 6]</span><br><span class="line">&gt;&gt;&gt; a[2:5] = []   # 将对应的元素值设置为 []</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 6]</span><br></pre></td></tr></table></figure>

<p>List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、List写在方括号之间，元素用逗号隔开。</li>
<li>2、和字符串一样，list可以被索引和切片。</li>
<li>3、List可以使用+操作符进行拼接。</li>
<li>4、List中的元素是可以改变的。</li>
</ul>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p>
<p><a href="https://pic.imgdb.cn/item/647b2b53f024cca1731da222.jpg"><img src="https://pic.imgdb.cn/item/647b2b53f024cca1731da222.jpg"></a></p>
<p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def reverseWords(input):</span><br><span class="line">     </span><br><span class="line">    # 通过空格将字符串分隔符，把各个单词分隔为列表</span><br><span class="line">    inputWords = input.split(&quot; &quot;)</span><br><span class="line"> </span><br><span class="line">    # 翻转字符串</span><br><span class="line">    # 假设列表 list = [1,2,3,4],  </span><br><span class="line">    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span><br><span class="line">    # inputWords[-1::-1] 有三个参数</span><br><span class="line">    # 第一个参数 -1 表示最后一个元素</span><br><span class="line">    # 第二个参数为空，表示移动到列表末尾</span><br><span class="line">    # 第三个参数为步长，-1 表示逆向</span><br><span class="line">    inputWords=inputWords[-1::-1]</span><br><span class="line"> </span><br><span class="line">    # 重新组合字符串</span><br><span class="line">    output = &#x27; &#x27;.join(inputWords)</span><br><span class="line">     </span><br><span class="line">    return output</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    input = &#x27;I like runoob&#x27;</span><br><span class="line">    rw = reverseWords(input)</span><br><span class="line">    print(rw)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob like I</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">tuple = ( &#x27;abcd&#x27;, 786 , 2.23, &#x27;runoob&#x27;, 70.2  )</span><br><span class="line">tinytuple = (123, &#x27;runoob&#x27;)</span><br><span class="line"></span><br><span class="line">print (tuple)             # 输出完整元组</span><br><span class="line">print (tuple[0])          # 输出元组的第一个元素</span><br><span class="line">print (tuple[1:3])        # 输出从第二个元素开始到第三个元素</span><br><span class="line">print (tuple[2:])         # 输出从第三个元素开始的所有元素</span><br><span class="line">print (tinytuple * 2)     # 输出两次元组</span><br><span class="line">print (tuple + tinytuple) # 连接元组</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2)</span><br><span class="line">abcd</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &#x27;runoob&#x27;, 70.2)</span><br><span class="line">(123, &#x27;runoob&#x27;, 123, &#x27;runoob&#x27;)</span><br><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;runoob&#x27;, 70.2, 123, &#x27;runoob&#x27;)</span><br></pre></td></tr></table></figure>

<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p>
<p>其实，可以把字符串看作一种特殊的元组。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; print(tup[0])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(tup[1:5])</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup1 = ()    # 空元组</span><br><span class="line">tup2 = (20,) # 一个元素，需要在元素后添加逗号</span><br></pre></td></tr></table></figure>

<p>string、list 和 tuple 都属于 sequence（序列）。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、与字符串一样，元组的元素不能修改。</li>
<li>2、元组也可以被索引和切片，方法一样。</li>
<li>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li>
<li>4、元组也可以使用+操作符进行拼接。</li>
</ul>
<hr>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 <strong>{ }</strong> 或者 <strong>set()</strong> 函数创建集合，注意：创建一个空集合必须用 <strong>set()</strong> 而不是 **{ }**，因为 <strong>{ }</strong> 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line">set(value)</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">sites = &#123;&#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Facebook&#x27;, &#x27;Zhihu&#x27;, &#x27;Baidu&#x27;&#125;</span><br><span class="line"></span><br><span class="line">print(sites)   # 输出集合，重复的元素被自动去掉</span><br><span class="line"></span><br><span class="line"># 成员测试</span><br><span class="line">if &#x27;Runoob&#x27; in sites :</span><br><span class="line">    print(&#x27;Runoob 在集合中&#x27;)</span><br><span class="line">else :</span><br><span class="line">    print(&#x27;Runoob 不在集合中&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set可以进行集合运算</span><br><span class="line">a = set(&#x27;abracadabra&#x27;)</span><br><span class="line">b = set(&#x27;alacazam&#x27;)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">print(a - b)     # a 和 b 的差集</span><br><span class="line"></span><br><span class="line">print(a | b)     # a 和 b 的并集</span><br><span class="line"></span><br><span class="line">print(a &amp; b)     # a 和 b 的交集</span><br><span class="line"></span><br><span class="line">print(a ^ b)     # a 和 b 中不同时存在的元素</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;Zhihu&#x27;, &#x27;Baidu&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;&#125;</span><br><span class="line">Runoob 在集合中</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;c&#x27;, &#x27;a&#x27;&#125;</span><br><span class="line">&#123;&#x27;z&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 <strong>{ }</strong> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">dict = &#123;&#125;</span><br><span class="line">dict[&#x27;one&#x27;] = &quot;1 - 菜鸟教程&quot;</span><br><span class="line">dict[2]     = &quot;2 - 菜鸟工具&quot;</span><br><span class="line"></span><br><span class="line">tinydict = &#123;&#x27;name&#x27;: &#x27;runoob&#x27;,&#x27;code&#x27;:1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print (dict[&#x27;one&#x27;])       # 输出键为 &#x27;one&#x27; 的值</span><br><span class="line">print (dict[2])           # 输出键为 2 的值</span><br><span class="line">print (tinydict)          # 输出完整的字典</span><br><span class="line">print (tinydict.keys())   # 输出所有键</span><br><span class="line">print (tinydict.values()) # 输出所有值</span><br></pre></td></tr></table></figure>

<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 - 菜鸟教程</span><br><span class="line">2 - 菜鸟工具</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;runoob&#x27;, &#x27;code&#x27;: 1, &#x27;site&#x27;: &#x27;www.runoob.com&#x27;&#125;</span><br><span class="line">dict_keys([&#x27;name&#x27;, &#x27;code&#x27;, &#x27;site&#x27;])</span><br><span class="line">dict_values([&#x27;runoob&#x27;, 1, &#x27;www.runoob.com&#x27;])</span><br></pre></td></tr></table></figure>

<p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dict([(&#x27;Runoob&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)])</span><br><span class="line">&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line">&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)</span><br><span class="line">&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>

<p>**{x: x*<em>2 for x in (2, 4, 6)}</em>* 该代码使用的是字典推导式，更多推导式内容可以参考：Python 推导式：</p>
<h3 id="Python-推导式"><a href="#Python-推导式" class="headerlink" title="Python 推导式"></a>Python 推导式</h3><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p>
<p>Python 支持各种数据结构的推导式：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
<li>元组(tuple)推导式</li>
</ul>
<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>列表推导式格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[表达式 for 变量 in 列表] </span><br><span class="line">[out_exp_res for out_exp in input_list]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 for 变量 in 列表 if 条件]</span><br><span class="line">[out_exp_res for out_exp in input_list if condition]</span><br></pre></td></tr></table></figure>

<ul>
<li>out_exp_res：列表生成元素表达式，可以是有返回值的函数。</li>
<li>for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</li>
<li>if condition：条件语句，可以过滤列表中不符合条件的值。</li>
</ul>
<p>过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]</span><br><span class="line">&gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3]</span><br><span class="line">&gt;&gt;&gt; print(new_names)</span><br><span class="line">[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;]</span><br></pre></td></tr></table></figure>

<p>计算 30 以内可以被 3 整除的整数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; multiples = [i for i in range(30) if i % 3 == 0]</span><br><span class="line">&gt;&gt;&gt; print(multiples)</span><br><span class="line">[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span><br></pre></td></tr></table></figure>

<h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>字典推导基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; key_expr: value_expr for value in collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr for value in collection if condition &#125;</span><br></pre></td></tr></table></figure>

<p>使用字符串及其长度创建字典：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listdemo = [&#x27;Google&#x27;,&#x27;Runoob&#x27;, &#x27;Taobao&#x27;]</span><br><span class="line"># 将列表中各字符串值为键，各字符串的长度为值，组成键值对</span><br><span class="line">&gt;&gt;&gt; newdict = &#123;key:len(key) for key in listdemo&#125;</span><br><span class="line">&gt;&gt;&gt; newdict</span><br><span class="line">&#123;&#x27;Google&#x27;: 6, &#x27;Runoob&#x27;: 6, &#x27;Taobao&#x27;: 6&#125;</span><br></pre></td></tr></table></figure>

<p>提供三个数字，以三个数字为键，三个数字的平方为值来创建字典：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line">&gt;&gt;&gt; type(dic)</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><p>集合推导式基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; expression for item in Sequence &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression for item in Sequence if conditional &#125;</span><br></pre></td></tr></table></figure>

<p>计算数字 1,2,3 的平方数：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; setnew = &#123;i**2 for i in (1,2,3)&#125;</span><br><span class="line">&gt;&gt;&gt; setnew</span><br><span class="line">&#123;1, 4, 9&#125;</span><br></pre></td></tr></table></figure>

<p>判断不是 abc 的字母并输出：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#x27;d&#x27;, &#x27;r&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#x27;set&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="元组推导式（生成器表达式）"><a href="#元组推导式（生成器表达式）" class="headerlink" title="元组推导式（生成器表达式）"></a>元组推导式（生成器表达式）</h4><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p>
<p>元组推导式基本格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(expression for item in Sequence )</span><br><span class="line">或</span><br><span class="line">(expression for item in Sequence if conditional )</span><br></pre></td></tr></table></figure>

<p>元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。</p>
<p>例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (x for x in range(1,10))</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;  # 返回的是生成器对象</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; tuple(a)       # 使用 tuple() 函数，可以直接将生成器对象转换成元组</span><br><span class="line">(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br></pre></td></tr></table></figure>



<p>另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、字典是一种映射类型，它的元素是键值对。</li>
<li>2、字典的关键字必须为不可变类型，且不能重复。</li>
<li>3、创建空字典使用 **{ }**。</li>
</ul>
<hr>
<h2 id="bytes-类型"><a href="#bytes-类型" class="headerlink" title="bytes 类型"></a>bytes 类型</h2><p>在 Python3 中，bytes 类型表示的是不可变的二进制序列（byte sequence）。</p>
<p>与字符串类型不同的是，bytes 类型中的元素是整数值（0 到 255 之间的整数），而不是 Unicode 字符。</p>
<p>bytes 类型通常用于处理二进制数据，比如图像文件、音频文件、视频文件等等。在网络编程中，也经常使用 bytes 类型来传输二进制数据。</p>
<p>创建 bytes 对象的方式有多种，最常见的方式是使用 b 前缀：</p>
<p>此外，也可以使用 bytes() 函数将其他类型的对象转换为 bytes 类型。bytes() 函数的第一个参数是要转换的对象，第二个参数是编码方式，如果省略第二个参数，则默认使用 UTF-8 编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = bytes(&quot;hello&quot;, encoding=&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>

<p>与字符串类型类似，bytes 类型也支持许多操作和方法，如切片、拼接、查找、替换等等。同时，由于 bytes 类型是不可变的，因此在进行修改操作时需要创建一个新的 bytes 对象。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = b&quot;hello&quot;</span><br><span class="line">y = x[1:3]  # 切片操作，得到 b&quot;el&quot;</span><br><span class="line">z = x + b&quot;world&quot;  # 拼接操作，得到 b&quot;helloworld&quot;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，bytes 类型中的元素是整数值，因此在进行比较操作时需要使用相应的整数值。例如：</p>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = b&quot;hello&quot;</span><br><span class="line">if x[0] == ord(&quot;h&quot;):</span><br><span class="line">    print(&quot;The first element is &#x27;h&#x27;&quot;)</span><br></pre></td></tr></table></figure>

<p>其中 ord() 函数用于将字符转换为相应的整数值。</p>
<hr>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td>
<td align="left">将x转换为一个整数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td>
<td align="left">将x转换到一个浮点数</td>
</tr>
<tr>
<td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td>
<td align="left">创建一个复数</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td>
<td align="left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td>
<td align="left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td>
<td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td>
<td align="left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td>
<td align="left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td>
<td align="left">转换为可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td>
<td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td>
<td align="left">转换为不可变集合</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td>
<td align="left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td>
<td align="left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td>
<td align="left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td>
<td align="left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>折枝落梦</title>
    <url>/2022/11/05/%E6%8A%98%E6%9E%9D%E8%90%BD%E6%A2%A6/</url>
    <content><![CDATA[<p>​	我们都栖息在智慧之树下，尝试阅读世界。<span id="more"></span>从土中读、从雨中读，尔后化身白鸟，攀上枝头，终于衔住了至关重要的那一片树叶。</p>
<p>​	曾经，我是世上唯一能够做梦的个体。在我的梦里，所有人入夜后都会进入梦乡，人们的脑海中飘出奇思异想。有些滚落地面，有些浮到天上。他将所有事物连接成一片万分夺目的网，三千世界之中，又有小小世界，所有命运，皆在此间沸腾。</p>
<p>​	我逐渐明白，这些不可被描述而又恒久变化之物，才是世间最深奥的东西。唯有它们，才能彻底祛除那些疯狂；唯有梦，才能将意识从最深沉的黑暗中唤醒。</p>
<p>​	我乃命题之人，亦是求解之人。以世人之梦挽救世界，曾是属于我的答案。而今，你们也寻到了属于自己的答案。我会将所有的梦，归还世人。</p>
]]></content>
      <categories>
        <category>原神</category>
      </categories>
  </entry>
  <entry>
    <title>工业和信息化部关于开展移动互联网应用程序备案工作的通知</title>
    <url>/2023/08/10/%E5%B7%A5%E4%B8%9A%E5%92%8C%E4%BF%A1%E6%81%AF%E5%8C%96%E9%83%A8%E5%85%B3%E4%BA%8E%E5%BC%80%E5%B1%95%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%87%E6%A1%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<p><img src="https://pic.imgdb.cn/item/64d4db271ddac507cc2cf395.jpg"></p>
<span id="more"></span>

<center>工信部信管〔2023〕105号</center>



<p>各省、自治区、直辖市通信管理局，中国信息通信研究院、中国互联网协会，基础电信企业，公益性互联单位、互联网接入服务提供者、互联网数据中心服务提供者、内容分发网络服务提供者，移动互联网应用程序分发平台（含小程序、快应用等分发）、智能终端生产企业、互联网信息服务提供者：</p>
<p>为落实《中华人民共和国反电信网络诈骗法》《互联网信息服务管理办法》（国务院令第292号）等法律法规要求，促进互联网行业规范健康发展，进一步做好移动互联网信息服务管理，现组织开展移动互联网应用程序（以下简称APP）备案工作。有关事项通知如下：</p>
<p>一、总体要求</p>
<p>以习近平新时代中国特色社会主义思想为指导，深入学习贯彻习近平总书记关于网络强国的重要思想、习近平总书记关于打击治理电信网络诈骗犯罪工作的重要指示批示精神，坚持依法行政、公开透明、便民高效原则，维护网络安全和公共利益，保护公民和组织合法权益，促进互联网行业规范健康发展。</p>
<p>二、工作内容</p>
<p>（一）在中华人民共和国境内从事互联网信息服务的APP主办者，应当依照《中华人民共和国反电信网络诈骗法》《互联网信息服务管理办法》（国务院令第292号）等规定履行备案手续，未履行备案手续的，不得从事APP互联网信息服务。</p>
<p>（二）工业和信息化部对全国APP备案工作进行监督指导，省、自治区、直辖市通信管理局负责实施监督APP备案管理工作。</p>
<p>（三）APP主办者使用的域名、IP地址等网络资源应当符合《互联网域名管理办法》（工业和信息化部令第43号）《互联网IP地址备案管理办法》（原信息产业部令第34号）《工业和信息化部关于规范互联网信息服务使用域名的通知》（工信部信管〔2017〕264号）等管理要求。</p>
<p>（四）APP主办者应当如实填报《互联网信息服务备案登记表》（以下简称《备案登记表》）以及有关承诺书。</p>
<p>从事新闻、出版、教育、影视、宗教等APP互联网信息服务的主办者，在履行备案手续时，还应向其住所所在地省级通信管理局提交相关主管部门审核同意的文件。</p>
<p>电信主管部门可根据实际情况，对《备案登记表》和有关承诺书内容进行调整。</p>
<p>（五）APP主办者应当向其住所所在地省级通信管理局履行备案手续，由其网络接入服务提供者、APP分发平台（以下简称分发平台）通过“国家互联网基础资源管理系统”（即ICP&#x2F;IP地址&#x2F;域名信息备案管理系统，以下简称备案系统），采取网上提交申请、查验审核方式进行。</p>
<p>（六）网络接入服务提供者、分发平台应对拟从事APP互联网信息服务组织或个人的用户真实身份、网络资源等信息进行查验，不得在明知或应知信息不准确情况下，为其代为履行备案手续。</p>
<p>（七）省级通信管理局在收到APP主办者提交的备案材料后，材料齐全并准确的，应在二十个工作日内予以备案，向其发放备案编号，并通过备案系统向社会公布备案信息；材料不齐全或不准确的，不予备案，并说明理由。</p>
<p>（八）APP主办者应当在APP显著位置标明其备案编号，并在备案编号下方按要求链接备案系统网址，供公众查询核对。分发平台应在显著位置标明其分发的APP备案编号信息，并向电信主管部门报送分发的APP有关信息。</p>
<p>APP信息发生变更、注销等情况，APP主办者应当向原备案机关履行变更、注销等手续。</p>
<p>（九）网络接入服务提供者、分发平台、智能终端生产企业不得为未履行备案手续的APP提供网络接入、分发、预置等服务。</p>
<p>（十）APP主办者、网络接入服务提供者、分发平台、智能终端生产企业应当建立健全违法违规信息监测和处置机制，发现法律、行政法规禁止发布或者传输的信息，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向电信主管部门报告，依据电信主管部门要求进行处置。</p>
<p>三、工作安排</p>
<p>（一）工作准备阶段（2023年8月底前）。各省、自治区、直辖市通信管理局组织辖区内APP主办者、网络接入服务提供者、分发平台等明确管理要求，制定实施计划，确保有关工作稳步推进。网络接入服务提供者、分发平台应按照要求，建设和升级企业侧备案系统，完成与部侧备案系统对接测试，具备对APP信息报备和核验等功能。</p>
<p>（二）存量APP备案阶段（2023年9月-2024年3月）。在本通知发布前已开展业务的APP应按照本通知要求，通过其网络接入服务提供者、分发平台向其住所所在地省级通信管理局履行备案手续。其中，对于已履行网站备案手续的，仅需补充完善其APP有关信息，无需重复填报主办者真实身份信息。对于没有网站备案信息的，按照本通知规定履行备案手续。</p>
<p>在本通知发布后拟开展业务的APP，应按照本通知要求先履行备案手续后再开展业务。</p>
<p>（三）监督检查阶段（2024年4月-2024年6月）。工业和信息化部组织开展APP备案检查工作，各省、自治区、直辖市通信管理局及时督促有关单位填报、补充、更新APP备案信息，对网络接入服务提供者、分发平台、智能终端生产企业接入、分发、预置的APP开展检查。对未履行备案程序、从事违法违规活动的APP，各省、自治区、直辖市通信管理局应按照相关法律法规规定处理。</p>
<p>（四）常态化工作阶段（2024年7月至长期）。各省、自治区、直辖市通信管理局定期组织网络接入服务提供者、分发平台、智能终端生产企业开展APP备案信息准确性考核工作，采取有效技术措施加强APP合规管理，提升移动互联网监管水平。</p>
<p>四、工作要求</p>
<p>（一）提高政治站位，加强组织领导。各单位要充分认识APP备案工作对于强化互联网基础管理、促进互联网行业规范健康发展、深化防范治理电信网络诈骗工作成效、维护网络与信息安全的重要意义，按照工作部署，强化主体责任落实，确保各项工作按时保质完成。</p>
<p>（二）压实主体责任，严格工作落实。各通信管理局要加强对企业的督导检查，及时发现问题隐患和薄弱环节。网络接入服务提供者、分发平台、智能终端生产企业要强化工作落实和责任考核，及时处理工作中遇到的问题，并向电信主管部门报告。</p>
<p>（三）强化技术保障，提供有力支撑。中国信息通信研究院、中国互联网协会要做好备案系统建设运维工作，强化APP备案数据共享和分析能力，积极配合电信主管部门做好APP备案管理工作的问题解答、宣传引导等工作，有效支撑APP各项监管工作。</p>
<p>附件：<a href="https://wap.miit.gov.cn/cms_files/filemanager/1226211233/attach/20237/a7733cb3557c40718d433843da95526f.wps">互联网信息服务备案登记表.wps</a></p>
<p align="right">转自 工业和信息化部</p>

<p align="right">2023年7月21日</p>

]]></content>
  </entry>
  <entry>
    <title>某动漫游戏3.2服务器搭建</title>
    <url>/2023/08/24/%E6%9F%90%E5%8A%A8%E6%BC%AB%E6%B8%B8%E6%88%8F3-2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="先挖个坑，有时间再填"><a href="#先挖个坑，有时间再填" class="headerlink" title="先挖个坑，有时间再填"></a>先挖个坑，有时间再填</h1>]]></content>
      <categories>
        <category>原神</category>
      </categories>
      <tags>
        <tag>原神</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降算法简介</title>
    <url>/2023/06/03/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><span id="more"></span>

<p>梯度下降（gradient descent）在机器学习中应用十分的广泛，不论是在线性回归还是Logistic回归中，它的主要目的是通过迭代找到目标函数的最小值，或者收敛到最小值。<br>本文将从一个下山的场景开始，先提出梯度下降算法的基本思想，进而从数学上解释梯度下降算法的原理，解释为什么要用梯度，最后实现一个简单的梯度下降算法的实例！</p>
<h1 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h1><h2 id="场景假设"><a href="#场景假设" class="headerlink" title="场景假设"></a>场景假设</h2><p>梯度下降法的基本思想可以类比为一个下山的过程。<br>假设这样一个场景：一个人被困在山上，需要从山上下来(找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低；因此，下山的路径就无法确定，必须利用自己周围的信息一步一步地找到下山的路。这个时候，便可利用梯度下降算法来帮助自己下山。怎么做呢，首先以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着下降方向走一步，然后又继续以当前位置为基准，再找最陡峭的地方，再走直到最后到达最低处；同理上山也是如此，只是这时候就变成梯度上升算法了</p>
<p><a href="https://pic.imgdb.cn/item/647b3c72f024cca1733051c3.jpg"><img src="https://pic.imgdb.cn/item/647b3c72f024cca1733051c3.jpg"></a></p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降的基本过程就和下山的场景很类似。</p>
<p>首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释)<br>所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。那么为什么梯度的方向就是最陡峭的方向呢？接下来，我们从微分开始讲起：</p>
<h3 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h3><p>看待微分的意义，可以有不同的角度，最常用的两种是：</p>
<p>函数图像中，某点的切线的斜率<br>函数的变化率<br>几个微分的例子：</p>
<ol>
<li>单变量的微分，函数只有一个变量时</li>
</ol>
<p>$$<br>\frac{\mathrm{d}\left(\mathrm{x}^2\right)}{\mathrm{dx}}&#x3D;2 \mathrm{x}<br>$$</p>
<p>$$<br>\frac{\mathrm{d}(-2y^{5})}{\mathrm{d}y}{&#x3D;}-10y^{4}<br>$$</p>
<p>$$<br>{\frac{\operatorname*{d}(5-θ)^{2}}{\operatorname*{d}θ}}{&#x3D;}-2(5-\Theta)<br>$$</p>
<ol start="2">
<li>多变量的微分，当函数有多个变量的时候，即分别对每个变量进行求微分</li>
</ol>
<p>$$<br>\frac{\partial}{\partial x}\left({\bf x}^{2}{\bf y}^{2}\right)&#x3D;2{\bf x}y^{2}<br>$$</p>
<p>$$<br>\frac{\partial}{\partial\mathbf{y}}\left(-2\mathbf{y}^{5}+\mathbf{z}^{2}\right)&#x3D;-10\mathbf{y}^{4}<br>$$</p>
<p>$$<br>\frac{\partial}{\partial\theta_{2}}\left(5\theta_{1}+2\theta_{2},-12\theta_{3}\right)&#x3D;2<br>$$</p>
<p>$$<br>\frac{\partial}{\partial\theta_{2}}\left(0.55-\left(50_{1},+\ 2\theta_{2},-,12\theta_{3}\right)\right)&#x3D;-2<br>$$</p>
<h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>梯度实际上就是多变量微分的一般化。<br>下面这个例子：<br>$$<br>\operatorname{J}(\Theta)&#x3D;0.55-(5\theta_{1}+2\theta_{2}-12\theta_{3})<br>$$</p>
<p>$$<br>\nabla J\left(\Theta\right){&#x3D;}\langle\frac{\partial{ J}}{\partial\theta_{1}},\frac{\partial{ J}}{\partial\theta_{2}},\frac{\partial{ J}}{\partial\theta_{3}}\rangle{&#x3D;}\left(-5,-2,12\right)<br>$$</p>
<p>我们可以看到，梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。</p>
<p>梯度是微积分中一个很重要的概念，之前提到过梯度的意义</p>
<p>在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率<br>在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向<br>这也就说明了为什么我们需要千方百计的求取梯度！我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的方向一直走，就能走到局部的最低点！</p>
<h2 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h2><p>首先给出数学公式：<br>$$<br>\Theta^{1}&#x3D;\Theta^{0}+a\nabla\mathrm{J}\left(\Theta\right)\rightarrow\mathrm{evaluatedat}\Theta^{0}<br>$$<br>此公式的意义是：J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点！</p>
<p><a href="https://pic.imgdb.cn/item/647b4a0cf024cca1734e29c2.jpg"><img src="https://pic.imgdb.cn/item/647b4a0cf024cca1734e29c2.jpg"></a></p>
<h3 id="α"><a href="#α" class="headerlink" title="α"></a>α</h3><p>α在梯度下降算法中被称作为学习率或者步长，意味着我们可以通过α来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈，其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！</p>
<h3 id="梯度要乘以一个负号"><a href="#梯度要乘以一个负号" class="headerlink" title="梯度要乘以一个负号"></a>梯度要乘以一个负号</h3><p>梯度前加一个负号，就意味着朝着梯度相反的方向前进！我们在前文提到，梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号；那么如果时上坡，也就是梯度上升算法，当然就不需要添加负号了。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>我们已经基本了解了梯度下降算法的计算过程，那么我们就来看几个梯度下降算法的小实例，首先从单变量的函数开始，然后介绍多变量的函数。</p>
<h2 id="单变量函数的梯度下降"><a href="#单变量函数的梯度下降" class="headerlink" title="单变量函数的梯度下降"></a>单变量函数的梯度下降</h2><p>我们假设有一个单变量的函数<br>$$<br>{\mathbf{J}}(\theta)&#x3D;\theta^{2}<br>$$<br>函数的微分，直接求导就可以得到<br>$$<br>J^′(θ)&#x3D;2θ<br>$$<br>初始化，也就是起点，起点可以随意的设置，这里设置为1<br>$$<br>θ ^0<br> &#x3D;1<br>$$<br>学习率也可以随意的设置，这里设置为0.4<br>$$<br>α&#x3D;0.4<br>$$<br>根据梯度下降的计算公式</p>
<p>我们开始进行梯度下降的迭代计算过程：</p>
<p><a href="https://pic.imgdb.cn/item/647b4b29f024cca1735137e0.jpg"><img src="https://pic.imgdb.cn/item/647b4b29f024cca1735137e0.jpg"></a></p>
<p>如图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底</p>
<p><a href="https://pic.imgdb.cn/item/647b4b39f024cca1735161bb.jpg"><img src="https://pic.imgdb.cn/item/647b4b39f024cca1735161bb.jpg"></a></p>
<h2 id="多变量函数的梯度下降"><a href="#多变量函数的梯度下降" class="headerlink" title="多变量函数的梯度下降"></a>多变量函数的梯度下降</h2><p>我们假设有一个目标函数<br>$$<br>\operatorname{J}(\Theta)&#x3D;\theta_{1}^{2}+\theta_{2}^{2}<br>$$<br>现在要通过梯度下降法计算这个函数的最小值。我们通过观察就能发现最小值其实就是 (0，0)点。但是接下来，我们会从梯度下降算法开始一步步计算到这个最小值！<br>我们假设初始的起点为：<br>$$<br>Θ _0<br> &#x3D;(1,3)<br>$$<br>初始的学习率为：</p>
<p>$$<br>α&#x3D;0.1<br>$$<br>函数的梯度为：<br>$$<br>▽J(Θ)&#x3D;⟨2θ_1,2θ_2⟩<br>$$<br>进行多次迭代：</p>
<p><a href="https://pic.imgdb.cn/item/647bfbb9f024cca1730d4327.jpg"><img src="https://pic.imgdb.cn/item/647bfbb9f024cca1730d4327.jpg"></a></p>
<p>我们发现，已经基本靠近函数的最小值点</p>
<p><a href="https://pic.imgdb.cn/item/647bfbcef024cca1730d5562.jpg"><img src="https://pic.imgdb.cn/item/647bfbcef024cca1730d5562.jpg"></a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>下面我们将用python实现一个简单的梯度下降算法。场景是一个简单的线性回归的例子：假设现在我们有一系列的点，如下图所示：</p>
<p><a href="https://pic.imgdb.cn/item/647bfbe0f024cca1730d6375.jpg"><img src="https://pic.imgdb.cn/item/647bfbe0f024cca1730d6375.jpg"></a></p>
<p>我们将用梯度下降法来拟合出这条直线！</p>
<p>首先，我们需要定义一个代价函数，在此我们选用<a href="https://en.wikipedia.org/wiki/Least_squares"><strong>均方误差代价函数</strong></a>（也称平方误差代价函数）<br>$$<br>J\left(\Theta\right)&#x3D;{\frac{1}{2\mathrm{m}}}\sum_{\mathrm{i&#x3D;1}}^{\mathrm{m}}\left(\mathrm{h}_{\theta}\left(\mathbf{x}^{\mathrm{(i)}}\right)-\mathbf{y}^{\mathrm{(i)}}\right)^{2}<br>$$<br>此公式中</p>
<ul>
<li>m是数据集中数据点的个数，也就是样本数</li>
<li>1&#x2F;2m是一个常量，这样是为了在求梯度的时候，二次方乘下来的2就和这里的½抵消了，自然就没有多余的常数系数，方便后续的计算，同时对结果不会有影响</li>
<li>y 是数据集中每个点的真实y坐标的值，也就是类标签</li>
<li>h 是我们的预测函数（假设函数），根据每一个输入x，根据Θ 计算得到预测的y值，即</li>
</ul>
<p><a href="https://imgse.com/i/pC9cop6"><img src="https://s1.ax1x.com/2023/06/04/pC9cop6.png"></a></p>
<p>我们可以根据代价函数看到，代价函数中的变量有两个，所以是一个多变量的梯度下降问题，求解出代价函数的梯度，也就是分别对两个变量进行微分</p>
<p><a href="https://pic.imgdb.cn/item/647bfd73f024cca1730eac24.jpg"><img src="https://pic.imgdb.cn/item/647bfd73f024cca1730eac24.jpg"></a></p>
<p>明确了代价函数和梯度，以及预测的函数形式。我们就可以开始编写代码了。但在这之前，需要说明一点，就是为了方便代码的编写，我们会将所有的公式都转换为矩阵的形式，python中计算矩阵是非常方便的，同时代码也会变得非常的简洁。<br>为了转换为矩阵的计算，我们观察到预测函数的形式<br>$$<br>h_{\Theta}({\bf x}^{(\mathrm{i})}){&#x3D;}\Theta_{0}+\Theta_{1}{\bf x}^{(\mathrm{i})}<br>$$<br>我们有两个变量，为了对这个公式进行矩阵化，我们可以给每一个点x增加一维，这一维的值固定为1，这一维将会乘到Θ0上。这样就方便我们统一矩阵化的计算</p>
<p>然后我们将代价函数和梯度转化为矩阵向量相乘的形式<br>$$<br>\operatorname{J}(\Theta)&#x3D;{\textstyle\frac{1}{2\mathrm{m}}}\left(\mathbf{X}\Theta-{\vec{y}}\right)^{\mathrm{T}}\left(\mathbf{X}\Theta-{\vec{y}}\right)<br>$$</p>
<p>$$<br>\nabla{J}\left(\Theta\right)&#x3D;{\operatorname*{\frac{1}{\mathrm{m}}}}\mathbf{X}^{\mathrm{T}}\left(\mathbf{X}\Theta-{\vec{\mathbf{y}}}\right)<br>$$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先，我们需要定义数据集和学习率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line"># 数据集大小 即20个数据点</span><br><span class="line">m = 20</span><br><span class="line"># x的坐标以及对应的矩阵</span><br><span class="line">X0 = ones((m, 1))  # 生成一个m行1列的向量，也就是x0，全是1</span><br><span class="line">X1 = arange(1, m+1).reshape(m, 1)  # 生成一个m行1列的向量，也就是x1，从1到m</span><br><span class="line">X = hstack((X0, X1))  # 按照列堆叠形成数组，其实就是样本数据</span><br><span class="line"># 对应的y坐标</span><br><span class="line">y = np.array([</span><br><span class="line">    3, 4, 5, 5, 2, 4, 7, 8, 11, 8, 12,</span><br><span class="line">    11, 13, 13, 16, 17, 18, 17, 19, 21</span><br><span class="line">]).reshape(m, 1)</span><br><span class="line"># 学习率</span><br><span class="line">alpha = 0.01</span><br></pre></td></tr></table></figure>

<p>接下来我们以矩阵向量的形式定义代价函数和代价函数的梯度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义代价函数</span><br><span class="line">def cost_function(theta, X, Y):</span><br><span class="line">    diff = dot(X, theta) - Y  # dot() 数组需要像矩阵那样相乘，就需要用到dot()</span><br><span class="line">    return (1/(2*m)) * dot(diff.transpose(), diff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义代价函数对应的梯度函数</span><br><span class="line">def gradient_function(theta, X, Y):</span><br><span class="line">    diff = dot(X, theta) - Y</span><br><span class="line">    return (1/m) * dot(X.transpose(), diff)</span><br></pre></td></tr></table></figure>

<p>最后就是算法的核心部分，梯度下降迭代计算</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 梯度下降迭代</span><br><span class="line">def gradient_descent(X, Y, alpha):</span><br><span class="line">    theta = array([1, 1]).reshape(2, 1)</span><br><span class="line">    gradient = gradient_function(theta, X, Y)</span><br><span class="line">    while not all(abs(gradient) &lt;= 1e-5):</span><br><span class="line">        theta = theta - alpha * gradient</span><br><span class="line">        gradient = gradient_function(theta, X, Y)</span><br><span class="line">    return theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optimal = gradient_descent(X, Y, alpha)</span><br><span class="line">print(&#x27;optimal:&#x27;, optimal)</span><br><span class="line">print(&#x27;cost function:&#x27;, cost_function(optimal, X, Y)[0][0])</span><br></pre></td></tr></table></figure>

<p>当梯度小于1e-5时，说明已经进入了比较平滑的状态，类似于山谷的状态，这时候再继续迭代效果也不大了，所以这个时候可以退出循环！<br>运行代码，计算得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;optimal:&#x27;, optimal)  # 结果 [[0.51583286][0.96992163]]</span><br><span class="line">print(&#x27;cost function:&#x27;, cost_function(optimal, X, Y)[0][0])  # 1.014962406233101</span><br></pre></td></tr></table></figure>

<p>通过matplotlib画出图像，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据数据画出对应的图像</span><br><span class="line">def plot(X, Y, theta):</span><br><span class="line">    import matplotlib.pyplot as plt</span><br><span class="line">    ax = plt.subplot(111)  # 这是我改的</span><br><span class="line">    ax.scatter(X, Y, s=30, c=&quot;red&quot;, marker=&quot;s&quot;)</span><br><span class="line">    plt.xlabel(&quot;X&quot;)</span><br><span class="line">    plt.ylabel(&quot;Y&quot;)</span><br><span class="line">    x = arange(0, 21, 0.2)  # x的范围</span><br><span class="line">    y = theta[0] + theta[1]*x</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot(X1, Y, optimal)</span><br></pre></td></tr></table></figure>

<p>所拟合出的直线如下</p>
<p><a href="https://pic.imgdb.cn/item/647c2806f024cca173561b9a.jpg"><img src="https://pic.imgdb.cn/item/647c2806f024cca173561b9a.jpg"></a></p>
<p>全部代码如下，大家有兴趣的可以复制下来跑一下看一下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line"></span><br><span class="line"># 数据集大小 即20个数据点</span><br><span class="line">m = 20</span><br><span class="line"># x的坐标以及对应的矩阵</span><br><span class="line">X0 = ones((m, 1))  # 生成一个m行1列的向量，也就是x0，全是1</span><br><span class="line">X1 = arange(1, m+1).reshape(m, 1)  # 生成一个m行1列的向量，也就是x1，从1到m</span><br><span class="line">X = hstack((X0, X1))  # 按照列堆叠形成数组，其实就是样本数据</span><br><span class="line"># 对应的y坐标</span><br><span class="line">Y = array([</span><br><span class="line">    3, 4, 5, 5, 2, 4, 7, 8, 11, 8, 12,</span><br><span class="line">    11, 13, 13, 16, 17, 18, 17, 19, 21</span><br><span class="line">]).reshape(m, 1)</span><br><span class="line"># 学习率</span><br><span class="line">alpha = 0.01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义代价函数</span><br><span class="line">def cost_function(theta, X, Y):</span><br><span class="line">    diff = dot(X, theta) - Y  # dot() 数组需要像矩阵那样相乘，就需要用到dot()</span><br><span class="line">    return (1/(2*m)) * dot(diff.transpose(), diff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义代价函数对应的梯度函数</span><br><span class="line">def gradient_function(theta, X, Y):</span><br><span class="line">    diff = dot(X, theta) - Y</span><br><span class="line">    return (1/m) * dot(X.transpose(), diff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 梯度下降迭代</span><br><span class="line">def gradient_descent(X, Y, alpha):</span><br><span class="line">    theta = array([1, 1]).reshape(2, 1)</span><br><span class="line">    gradient = gradient_function(theta, X, Y)</span><br><span class="line">    while not all(abs(gradient) &lt;= 1e-5):</span><br><span class="line">        theta = theta - alpha * gradient</span><br><span class="line">        gradient = gradient_function(theta, X, Y)</span><br><span class="line">    return theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optimal = gradient_descent(X, Y, alpha)</span><br><span class="line">print(&#x27;optimal:&#x27;, optimal)</span><br><span class="line">print(&#x27;cost function:&#x27;, cost_function(optimal, X, Y)[0][0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 根据数据画出对应的图像</span><br><span class="line">def plot(X, Y, theta):</span><br><span class="line">    import matplotlib.pyplot as plt</span><br><span class="line">    ax = plt.subplot(111)  # 这是我改的</span><br><span class="line">    ax.scatter(X, Y, s=30, c=&quot;red&quot;, marker=&quot;s&quot;)</span><br><span class="line">    plt.xlabel(&quot;X&quot;)</span><br><span class="line">    plt.ylabel(&quot;Y&quot;)</span><br><span class="line">    x = arange(0, 21, 0.2)  # x的范围</span><br><span class="line">    y = theta[0] + theta[1]*x</span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plot(X1, Y, optimal)</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，就基本介绍完了梯度下降法的基本思想和算法流程，并且用python实现了一个简单的梯度下降算法拟合直线的案例！<br>最后，我们回到文章开头所提出的场景假设:<br>这个下山的人实际上就代表了<a href="https://en.wikipedia.org/wiki/Backpropagation"><strong>反向传播算法</strong></a>，下山的路径其实就代表着算法中一直在寻找的参数Θ，山上当前点的最陡峭的方向实际上就是代价函数在这一点的梯度方向，场景中观测最陡峭方向所用的工具就是<a href="https://en.wikipedia.org/wiki/Derivative"><strong>微分</strong></a> 。在下一次观测之前的时间就是有我们算法中的学习率α所定义的。<br>可以看到场景假设和梯度下降算法很好的完成了对应！</p>
]]></content>
  </entry>
  <entry>
    <title>泠鸢Lora模型</title>
    <url>/2023/05/01/%E6%B3%A0%E9%B8%A2Lora%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="海盐柠檬"><a href="#海盐柠檬" class="headerlink" title="海盐柠檬"></a>海盐柠檬</h1><span id="more"></span>

<p><a href="https://www.123pan.com/s/k79SVv-iNzJ.html">网盘链接</a></p>
<p>模型哈希：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5: 3bb7100f186fa28c720e928d31ddb740</span><br><span class="line">SHA1: b5551755b92393db4fce29b468e69c3d1c9dbfa9</span><br><span class="line">SHA256: 942f802f6122afb741f53b617f0a9cd1871c19ed3d2e0d4c98f2434eb12fecd0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示词：yousa,1girl,</span><br><span class="line"></span><br><span class="line">额外可选提示词：dress, hat , flat chest, red eyes, side ponytail,</span><br><span class="line"></span><br><span class="line">跑图建议使用DPM ++2M或DPM ++SDE算法</span><br><span class="line"></span><br><span class="line">权重根据模型不同可以在0.8-1之间调整</span><br></pre></td></tr></table></figure>

<p>预览：</p>
<p><img src="https://pic2.imgdb.cn/item/644f70490d2dde57771d8fb1.png"></p>
<hr>
<h1 id="登门喜鹊（待优化）"><a href="#登门喜鹊（待优化）" class="headerlink" title="登门喜鹊（待优化）"></a>登门喜鹊（待优化）</h1><p><a href="https://www.123pan.com/s/k79SVv-zNzJ.html">网盘链接</a></p>
<p>模型哈希：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5: 2718f4f6bc711d3f551599ea873021ac</span><br><span class="line">SHA1: c594d413803aa7aa6c3b528b39250b81b076c22e</span><br><span class="line">SHA256: 1c5d5b5b831e86d5bd15780e29cdb3fad5a579eb2f5f8eee7c47f41b35cf6747</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提示词：yousa,1girl,</span><br><span class="line"></span><br><span class="line">额外可选提示词：dress, side ponytail, flat chest, red eyes,</span><br><span class="line"></span><br><span class="line">跑图建议使用DPM ++2M或DPM ++SDE算法（感觉Euler a也还不错）</span><br><span class="line"></span><br><span class="line">权重根据模型不同可以在0.7-0.9之间调整；</span><br></pre></td></tr></table></figure>

<p>预览：</p>
<p><img src="https://pic2.imgdb.cn/item/645137590d2dde57775a4c76.jpg"></p>
<p><img src="https://pic2.imgdb.cn/item/645137910d2dde57775a8c83.jpg"></p>
<hr>
<p><font color='red'>若您使用此模型，则表明您已阅读并愿意遵守以下使用规约： </font></p>
<p><font color='red'>    1.严禁用此模型参与任何盈利和商业性质活动和内容制作。</font></p>
<p><font color='red'>    2.严禁用此模型参与政治、血腥、暴力、色情、反社会、宗教传播性质的内容制作。</font></p>
<p><font color='red'>    3.严禁用此模型进行侮辱性或猎奇的创作，严禁用于任何损害泠鸢yousa名誉的行为。</font></p>
<p><font color='red'>    4.任何由于不当使用此模型产生的后果由使用者自行承担，与模型训练者无关。</font></p>
]]></content>
  </entry>
  <entry>
    <title>泠鸢lora模型v2</title>
    <url>/2023/05/07/%E6%B3%A0%E9%B8%A2lora%E6%A8%A1%E5%9E%8Bv2/</url>
    <content><![CDATA[<h1 id="泠鸢yousa-LoRA模型"><a href="#泠鸢yousa-LoRA模型" class="headerlink" title="泠鸢yousa LoRA模型"></a>泠鸢yousa LoRA模型</h1><span id="more"></span>

<p><img src="https://pic2.imgdb.cn/item/64572f7d0d2dde5777fc6785.jpg"></p>
<p>​     本次发布的自制yousa LoRA模型共使用147张图片，其中129张是官方配布的几个MMD模型不同动作的截图，18张是yousa月刊、Pixiv不同画师的作品（部分训练图片如图所示）。本人发布此模型仅用于爱好者的学习和讨论，严禁商用和公开的非法内容的传播以及对原创画师、其他模型作者的踩一捧一。</p>
<p><img src="https://pic2.imgdb.cn/item/64572fe50d2dde5777fcc831.png"></p>
<p>本模型共包含8个训练得较好的服装:</p>
<ol>
<li><p>石英式泠鸢yousa（对应Prompt: yousa_origin, origin_hair_ornament, origin_earrings, origin_suits, origin_single_leg_ring, origin_footwear）</p>
</li>
<li><p>登门喜鹊（对应Prompt: yousa_magpie, magpie_hair_ornament, magpie_earrings, magpie_gloves, magpie_suits, magpie_single_leg_ring, magpie_footwear）</p>
</li>
<li><p>海盐柠檬对应Prompt: （yousa_SeaSaltLemon, SeaSaltLemon_minihat, SeaSaltLemon_earrings, SeaSaltLemon_suits, SeaSaltLemon_single_leg_ring, SeaSaltLemon_footwear）</p>
</li>
<li><p>随舰海鸥（对应Prompt: yousa_WithShipSeagull, WithShipSeagull_hat, WithShipSeagull_hair_ornament, WithShipSeagull_suits, WithShipSeagull_footwear）</p>
</li>
<li><p>披风朋克（但没有披风）（对应Prompt: yousa_punk, punk_hair_ornament, punk_earrings, punk_suits, punk_stockings, punk_footwear）</p>
</li>
<li><p>舞台之星（对应Prompt: yousa_StageStar, StageStar_hat, StageStar_earrings, StageStar_suits, StageStar_single_leg_ring, StageStar_footwear）</p>
</li>
<li><p>小红鸢石英式（洛丽塔）（对应Prompt: yousa_LittleKite, LittleKite_hair_ornament, LittleKite_earrings, LittleKite_suits, LittleKite_socks, LittleKite_footwear）</p>
</li>
<li><p>演唱会（对应Prompt: yousa_concert, concert_hair_ornament, concert_earrings, concert_single_gloves, concert_suits, concert_footwear）</p>
</li>
</ol>
<p>​    以上服饰皆可通过 yousa_服饰名（例如yousa_origin、yousa_SeaSaltLemon）来进行调用，其他服饰部件可搭配使用，但需要注意可能会影响背景及其他细节。</p>
<hr>
<p>​    经过前两天的测试，animefull模型作为底模同参数下训练出的LoRA远不如其他模型，而其他2.5D模型训练的LoRA泛化度则不如anything-v4.5。因此本模型基于anything-v4.5进行训练，对anything-v4.5、aom3、cetusMix_Coda(2)、CounterfeitV25、aoaokoPVCStyleModel支持较好，对pastelmix、aniflatmixAnimeFlatColorStyl、anythingV5_PrtRE支持并不好，不建议使用。</p>
<p>​    融合模型非常多建议各位自己测试一下其他模型的泛化度。</p>
<p>​    训练原始分辨率(768x768)+基础Prompt（Prompt: masterpiece, best quality, 1girl, solo, yousa, <code>&lt;lora:yousa_v1.0.0:1&gt;</code>，Negative Prompt: easynegative,  bad_prompt_version2, simple background, white background）生成测试结果如图所示。</p>
<p><img src="https://pic2.imgdb.cn/item/64572fcd0d2dde5777fcb632.webp"></p>
<p>​		此LoRA建议权重设置为0.6~1.1，采样方法和迭代步数请根据实际情况自行调整，推荐使用Hires. fix或Tiled Diffusion + Tiled VAE 或 Ultimate SD upscale进行图片放大。推荐使用ControlNet控制人物肢体。</p>
<p>​		以下例图皆未使用ControlNet，仅使用easynegative和bad_prompt_version2嵌入式模型和Hires. fix + Tiled Diffusion + Tiled VAE进行放大。</p>
<hr>
<p><img src="https://pic2.imgdb.cn/item/645730b90d2dde5777fdd5bd.jpg"></p>
<h2 id="石英式泠鸢"><a href="#石英式泠鸢" class="headerlink" title="石英式泠鸢"></a>石英式泠鸢</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_origin, looking at viewer, sitting, &lt;lora:yousa_v1.0.0:0.9&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 20, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 3822585620, Size: 2048x2048, Model hash: eb4099ba9c, Model: abyssorangemix3AOM3_aom3a3, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: SwinIR_4x, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 112, &#x27;Latent tile height&#x27;: 112, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;SwinIR_4x&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645730e40d2dde5777fe0cea.jpg"></p>
<h2 id="登门喜鹊"><a href="#登门喜鹊" class="headerlink" title="登门喜鹊"></a>登门喜鹊</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_magpie, looking at viewer, &lt;lora:yousa_v1.0.0:0.9&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 20, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 3014091722, Size: 4096x2560, Model hash: 1d1e459f9f, Model: anything-v4.5, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: SwinIR_4x, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 112, &#x27;Latent tile height&#x27;: 112, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;SwinIR_4x&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot; </span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645731100d2dde5777fe3c45.jpg"></p>
<h2 id="小红鸢石英式"><a href="#小红鸢石英式" class="headerlink" title="小红鸢石英式"></a>小红鸢石英式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_LittleKite, looking at viewer, lake, forest, &lt;lora:yousa_v1.0.0:0.9&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 30, Sampler: DPM++ 2M Karras, CFG scale: 7, Seed: 544692987, Size: 2560x4096, Model hash: a074b8864e, Model: CounterfeitV25_25, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: False&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645731850d2dde5777fea068.png"></p>
<h2 id="海盐柠檬"><a href="#海盐柠檬" class="headerlink" title="海盐柠檬"></a>海盐柠檬</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_SeaSaltLemon, looking at viewer, lake, forest, &lt;lora:yousa_v1.0.0:0.9&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 24, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 185057725, Size: 4096x2304, Model hash: bd518b9aee, Model: cetusMix_Codaedition, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645731b20d2dde5777fecc95.jpg"></p>
<h2 id="演唱会"><a href="#演唱会" class="headerlink" title="演唱会"></a>演唱会</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_concert, looking at viewer, street, &lt;lora:yousa_v1.0.0:1&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 24, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 185057725, Size: 4096x2304, Model hash: bd518b9aee, Model: cetusMix_Codaedition, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645731fd0d2dde5777ff08cc.jpg"></p>
<h2 id="随舰海鸥"><a href="#随舰海鸥" class="headerlink" title="随舰海鸥"></a>随舰海鸥</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_WithShipSeagull, looking at viewer, street, &lt;lora:yousa_v1.0.0:1&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 24, Sampler: DPM++ SDE Karras, CFG scale: 7, Seed: 1373778492, Size: 4096x3072, Model hash: f17f6cd695, Model: pastelmix, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot; </span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/6457326e0d2dde5777ff5f33.jpg"></p>
<h2 id="朋克少女（无披风）"><a href="#朋克少女（无披风）" class="headerlink" title="朋克少女（无披风）"></a>朋克少女（无披风）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_punk, looking at viewer, library, &lt;lora:yousa_v1.0.0:1&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 28, Sampler: DPM++ 2M Karras, CFG scale: 7, Seed: 1812682728, Size: 2304x4096, Model hash: eb4099ba9c, Model: abyssorangemix3AOM3_aom3a3, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot; </span><br></pre></td></tr></table></figure>

<hr>
<p><img src="https://pic2.imgdb.cn/item/645733f10d2dde5777009ba8.jpg"></p>
<h2 id="舞台之星"><a href="#舞台之星" class="headerlink" title="舞台之星"></a>舞台之星</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prompt:  masterpiece, best quality, 1girl, solo, yousa, yousa_StageStar, looking ati viewer, &lt;lora:yousa_v1.0.0:1&gt;</span><br><span class="line"></span><br><span class="line">Negative Prompt: easynegative, bad_prompt_version2, simple background, white background</span><br><span class="line"></span><br><span class="line">Steps: 28, Sampler: DPM++ 2M Karras, CFG scale: 7, Seed: 1812682728, Size: 2304x4096, Model hash: eb4099ba9c, Model: abyssorangemix3AOM3_aom3a3, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot;</span><br><span class="line"></span><br><span class="line">Steps: 20, Sampler: DPM++ 2M Karras, CFG scale: 7, Seed: 1836536083, Size: 2304x4096, Model hash: 1d1e459f9f, Model: anything-v4.5, Denoising strength: 0.35, Clip skip: 2, ENSD: 31337, Tiled Diffusion upscaler: 4x-AnimeSharp, Tiled Diffusion scale factor: 2, Tiled Diffusion: &quot;&#123;&#x27;Method&#x27;: &#x27;Mixture of Diffusers&#x27;, &#x27;Latent tile width&#x27;: 128, &#x27;Latent tile height&#x27;: 128, &#x27;Overlap&#x27;: 64, &#x27;Tile batch size&#x27;: 8, &#x27;Upscaler&#x27;: &#x27;4x-AnimeSharp&#x27;, &#x27;Scale factor&#x27;: 2, &#x27;Keep input size&#x27;: True&#125;&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p><font color='red'>若您使用此模型，则表明您已阅读并愿意遵守以下使用规约： </font></p>
<p><font color='red'>    1.严禁用此模型参与任何盈利和商业性质活动和内容制作。</font></p>
<p><font color='red'>    2.严禁用此模型参与政治、血腥、暴力、色情、反社会、宗教传播性质的内容制作。</font></p>
<p><font color='red'>    3.严禁用此模型进行侮辱性或猎奇的创作，严禁用于任何损害泠鸢yousa名誉的行为。</font></p>
<p><font color='red'>    4.任何由于不当使用此模型产生的后果由使用者自行承担，与模型训练者无关。</font></p>
]]></content>
  </entry>
  <entry>
    <title>生成式人工智能服务管理办法</title>
    <url>/2023/04/22/%E7%94%9F%E6%88%90%E5%BC%8F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="生成式人工智能服务管理办法"><a href="#生成式人工智能服务管理办法" class="headerlink" title="生成式人工智能服务管理办法"></a>生成式人工智能服务管理办法</h2><p>（征求意见稿）</p>
<span id="more"></span>

<p><strong>第一条</strong> 为促进生成式人工智能健康发展和规范应用，根据《中华人民共和国网络安全法》《中华人民共和国数据安全法》《中华人民共和国个人信息保护法》等法律、行政法规，制定本办法。</p>
<p><strong>第二条</strong> 研发、利用生成式人工智能产品，面向中华人民共和国境内公众提供服务的，适用本办法。本办法所称生成式人工智能，是指基于算法、模型、规则生成文本、图片、声音、视频、代码等内容的技术。</p>
<p><strong>第三条</strong> 国家支持人工智能算法、框架等基础技术的自主创新、推广应用、国际合作，鼓励优先采用安全可信的软件、工具、计算和数据资源。</p>
<p><strong>第四条</strong> 提供生成式人工智能产品或服务应当遵守法律法规的要求，尊重社会公德、公序良俗，符合以下要求：</p>
<ul>
<li><p><strong>（一）利用生成式人工智能生成的内容应当体现社会主义核心价值观</strong>，不得含有颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，暴力、淫秽色情信息，虚假信息，以及可能扰乱经济秩序和社会秩序的内容。</p>
</li>
<li><p>（二）在算法设计、训练数据选择、模型生成和优化、提供服务等过程中，采取措施防止出现种族、民族、信仰、国别、地域、性别、年龄、职业等歧视。</p>
</li>
<li><p>（三）尊重知识产权、商业道德，不得利用算法、数据、平台等优势实施不公平竞争。</p>
</li>
<li><p>（四）利用生成式人工智能生成的内容应当真实准确，采取措施防止生成虚假信息。</p>
</li>
<li><p>（五）尊重他人合法利益，防止伤害他人身心健康，损害肖像权、名誉权和个人隐私，侵犯知识产权。禁止非法获取、披露、利用个人信息和隐私、商业秘密。</p>
</li>
</ul>
<p><strong>第五条</strong> 利用生成式人工智能产品提供聊天和文本、图像、声音生成等服务的组织和个人（以下称“提供者”），包括通过提供可编程接口等方式支持他人自行生成文本、图像、声音等，承担该产品生成内容生产者的责任；涉及个人信息的，承担个人信息处理者的法定责任，履行个人信息保护义务。</p>
<p><strong>第六条</strong> 利用生成式人工智能产品向公众提供服务前，应当按照《具有舆论属性或社会动员能力的互联网信息服务安全评估规定》向国家网信部门申报安全评估，并按照《互联网信息服务算法推荐管理规定》履行算法备案和变更、注销备案手续。</p>
<p><strong>第七条</strong> 提供者应当对生成式人工智能产品的预训练数据、优化训练数据来源的合法性负责。用于生成式人工智能产品的预训练、优化训练数据，应满足以下要求：</p>
<ul>
<li><p>（一）符合《中华人民共和国网络安全法》等法律法规的要求；</p>
</li>
<li><p>（二）不含有侵犯知识产权的内容；</p>
</li>
<li><p>（三）数据包含个人信息的，应当征得个人信息主体同意或者符合法律、行政法规规定的其他情形；</p>
</li>
<li><p>（四）能够保证数据的真实性、准确性、客观性、多样性；</p>
</li>
<li><p>（五）国家网信部门关于生成式人工智能服务的其他监管要求。</p>
</li>
</ul>
<p><strong>第八条</strong> 生成式人工智能产品研制中采用人工标注时，提供者应当制定符合本办法要求，清晰、具体、可操作的标注规则，对标注人员进行必要培训，抽样核验标注内容的正确性。</p>
<p><strong>第九条</strong> 提供生成式人工智能服务应当按照《中华人民共和国网络安全法》规定，要求用户提供真实身份信息。</p>
<p><strong>第十条</strong> 提供者应当明确并公开其服务的适用人群、场合、用途，采取适当措施防范用户过分依赖或沉迷生成内容。</p>
<p><strong>第十一条</strong> 提供者在提供服务过程中，对用户的输入信息和使用记录承担保护义务。不得非法留存能够推断出用户身份的输入信息，不得根据用户输入信息和使用情况进行画像，不得向他人提供用户输入信息。法律法规另有规定的，从其规定。</p>
<p><strong>第十二条</strong> 提供者不得根据用户的种族、国别、性别等进行带有歧视性的内容生成。</p>
<p><strong>第十三条</strong> 提供者应当建立用户投诉接收处理机制，及时处置个人关于更正、删除、屏蔽其个人信息的请求；发现、知悉生成的文本、图片、声音、视频等侵害他人肖像权、名誉权、个人隐私、商业秘密，或者不符合本办法要求时，应当采取措施，停止生成，防止危害持续。</p>
<p><strong>第十四条</strong> 提供者应当在生命周期内，提供安全、稳健、持续的服务，保障用户正常使用。</p>
<p><strong>第十五条</strong> 对于运行中发现、用户举报的不符合本办法要求的生成内容，除采取内容过滤等措施外，应在3个月内通过模型优化训练等方式防止再次生成。</p>
<p><strong>第十六条</strong> 提供者应当按照《互联网信息服务深度合成管理规定》对生成的图片、视频等内容进行标识。</p>
<p><strong>第十七条</strong> 提供者应当根据国家网信部门和有关主管部门的要求，提供可以影响用户信任、选择的必要信息，包括预训练和优化训练数据的来源、规模、类型、质量等描述，人工标注规则，人工标注数据的规模和类型，基础算法和技术体系等。</p>
<p><strong>第十八条</strong> 提供者应当指导用户科学认识和理性使用生成式人工智能生成的内容，不利用生成内容损害他人形象、名誉以及其他合法权益，不进行商业炒作、不正当营销。用户发现生成内容不符合本办法要求时，有权向网信部门或者有关主管部门举报。</p>
<p><strong>第十九条</strong> 提供者发现用户利用生成式人工智能产品过程中违反法律法规，违背商业道德、社会公德行为时，包括从事网络炒作、恶意发帖跟评、制造垃圾邮件、编写恶意软件，实施不正当的商业营销等，应当暂停或者终止服务。</p>
<p><strong>第二十条</strong> 提供者违反本办法规定的，由网信部门和有关主管部门按照《中华人民共和国网络安全法》《中华人民共和国数据安全法》《中华人民共和国个人信息保护法》等法律、行政法规的规定予以处罚。法律、行政法规没有规定的，由网信部门和有关主管部门依据职责给予警告、通报批评，责令限期改正；拒不改正或者情节严重的，责令暂停或者终止其利用生成式人工智能提供服务，并处一万元以上十万元以下罚款。构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</p>
<p><strong>第二十一条</strong> 本办法自2023年 月 日起实施。</p>
]]></content>
  </entry>
  <entry>
    <title>演讲</title>
    <url>/2023/06/08/%E9%BB%84%E4%BB%81%E5%8B%8B%E5%8F%B0%E5%A4%A7%E6%AF%95%E5%85%B8%E6%BC%94%E8%AE%B2/</url>
    <content><![CDATA[<p>大家好，我今天本来想跟你们说台语，但是⋯⋯我越想越紧张。我在美国长大的，所以我的台语不是很标准，所以我今天跟你们说英文好不好？(台下掌声)</p>
<span id="more"></span>

<p>Okay，那我们开始吧！</p>
<p>各位贵宾、各位家长，2023 年的台大毕业生，大家好！</p>
<p>今天是你们的特别日子，也是梦想成真的日子——属于你们父母的，你们要赶快离家。</p>
<p>今天是荣耀的日子，父母亲牺牲了他们自己，成就了你们。我爸爸妈妈在这， 我哥哥也在这，让我们向养育我们的父母亲展现我们的感谢。</p>
<p>十年前我第一次来台大，陈教授邀请我来看他的物理实验室。我记得他的儿子在硅谷得知了 Nvidia 发明的 CUDA（Compute Unified Device Architecture，统一计算架构）技术，建议陈教授在量子物理模拟使用它。</p>
<p>当我抵达的时候，他秀给我看他创造的东西：整个房间的 Nvidia 游戏显卡， 插在开放式电脑的主机板上，金属架上都是散热用的大同电扇。</p>
<p>他以台湾人的方式，用游戏显卡做了一个超级电脑。他在这里，做了早期Nvidia JOURNEY 示范。他很骄傲，他说：“黄先生，因为你的关系，我可以完成我的事业。”</p>
<p>他说的那些话至今仍感动我，完美诠释了我们公司的价值：帮助这个时代的爱因斯坦与达芬奇完成他们的事业。</p>
<p>我很高兴能再次回到台大，担任你们的致词嘉宾。</p>
<p>给毕业生们：</p>
<p>你们所处的年代很复杂，却也是你们的机会</p>
<p>当我从俄勒冈州立大学毕业时，世界还比较简单。电视还很大一台，没有无线电视跟 MTV、没有手机和行动电话。那是 1994 年，IBM 个人电脑跟 MAC麦金塔开始了个人电脑革命。开始日后晶片与运算程式的发展。</p>
<p>你们正处在的世界更复杂，面临着地缘政治、社会和环境上的变化和挑战，被科技包围着。我们处于一个永远连接和沉浸的数据世界，与现实世界平行存在。在 40 年前，当电脑产业创造了家用 PC，持续研究 AI 技术，我们的运算程式驾驶着汽车、或研读 X 光片影像。AI 为电脑自动化开启了大门，其服务涵盖了世界最大的兆级产业：健康照护、金融服务、运输与制造产业。</p>
<p>AI 为我们带来了巨大的机遇，反应敏捷的企业将利用 AI 技术提升竞争力，而未能善用 AI 的企业将面临衰退。很多企业家，包含今天在场的许多人，未来将会开创新公司。</p>
<p>如同过去的每个计算机时代能创造新的产业，AI 也创造了以前不存在的新工作机会，像是：数据工程师、咏唱工程师、AI 工厂操作员和 AI 安全工程师等，这些工作以前从未存在过。</p>
<p>自动化工作将淘汰一些工作，并且毫无疑问的，AI 会改变每一个工作，大幅 加强程式设计师、设计师、艺术家、行销人员和制造计划者的工作表现。就像在你们之前的每个世代，拥抱科技以获得成功。每个公司与你必须学会利 用 AI 的优势，在 AI 的帮助下做出惊人成就。</p>
<p>有些人担心 AI 可能会抢走你的工作，有些人可能会让 AI 发展出自我意志。</p>
<p>我们正处于一个新领域的开始，就像个人电脑、网路、移动设备与云端技术一样。但是 AI 的影响更为根本，每个运算层面都会被重新改写。它改变了我们撰写软件的方式、执行软件的方式。</p>
<p>从各方面来看，这是电脑产业的再生契机，对于台湾企业而言更是一个黄金机遇。你们正是这个产业的重要基石。</p>
<p>在下个十年，我们的产业将使用新型AI 电脑取代价值上兆美元的传统电脑。</p>
<p>我的旅程始于你们 40 年之前，1984 年是一个完美的毕业年份，我预测 2023年也将如此。我能告诉你什么呢？今天是迄今为止你们最成功的一天，你们从台大毕业了，我也曾经成功过。</p>
<p>在我创办了 Nvidia 前，我经历过失败，而且是大失败，说起来令人耻辱和尴尬，甚至几乎让我们走向毁灭。</p>
<p>让我给你们讲 3 个故事，这些故事定义了 Nvidia 今天的样貌。</p>
<h2 id="坦诚面对错误，谦卑寻求帮助"><a href="#坦诚面对错误，谦卑寻求帮助" class="headerlink" title="坦诚面对错误，谦卑寻求帮助"></a>坦诚面对错误，谦卑寻求帮助</h2><p>我们创办 Nvidia 是为了创造加速运算技术。我们的第一个应用是用于个人电脑游戏的 3D 图形，我们发明了一种非传统的前向纹理处理技术，而且成本相对低廉。我们赢得了与 SEGA 建造游戏主机的合约。这吸引了游戏开发商用我们的平台开发游戏，并提供我们公司资金。</p>
<p>但经过了一年的开发期程，我们意识到我们设计的架构是错误策略，从技术端来看是不合格的。而与此同时，微软即将宣布基于反向纹理映射和三角形的 Windows 95 Direct3D。这代表如果我们完成了 SEGA 的游戏机，我们将会创造出与 Windows 不相容的产品；但如果我们不完成这个合约，我们就会破产。无论如何，我们都会面临倒闭的命运。</p>
<p>我联络了SEGA 执行长，向他解释我们的发明是错误的，我们无法完成合约以及游戏主机，并建议 SEGA 寻找其他合作伙伴。我对他说：“我们必须停下来。”</p>
<p>但我需要 SEGA 全额支付我们的费用，否则 Nvidia 将无法继续经营。</p>
<p>我很难为情的向 SEGA 执行长生提出这个要求，但令我惊讶的是，他同意了。</p>
<p>他的理解和慷慨让我们多活了 3 个月，在那段时间，我们建造了 Riva 128， 就在我们差点没钱时，Riva 128 震撼了新兴的 3D 市场，让我们开始受到关注，也拯救了公司营运。</p>
<p>市场对我们的晶片需求旺盛，让我从4岁离开台湾后又回到了台湾。我与台积电的张忠谋先生会面，并开始一段持续 25 年的合作关系。</p>
<p>我们坦诚面对错误、谦卑的寻求帮助，拯救 Nvidia 的存续。这些特质对于像你们这样最聪明、最成功的人而言，是最难养成的。</p>
<h2 id="追求愿景的艰苦过程"><a href="#追求愿景的艰苦过程" class="headerlink" title="追求愿景的艰苦过程"></a>追求愿景的艰苦过程</h2><p>在 2007 年，我们宣布了 CUDA GPU 加速计算技术，我们的期望是让 CUDA成为一个程式设计模型，在科学运算、物理模拟到图像处理方面，都能提升应用程式的效能。</p>
<p>创建一个全新的运算模型非常困难，且在历史上实属罕见。自从 IBM System360 以来，CPU 的运算模型已经成为标准已有 60 年的时间。CUDA 需要开发人员撰写应用程式，并展示 GPU 的优势；开发人员需要一个大型的使用者基础；大型的 CUDA 使用者基础，需要市场上有人购买新的应用程式。</p>
<p>因此，为了解决先有鸡还是先有蛋的问题。</p>
<p>我们利用我们的游戏显卡 GPU GeForce，它已经拥有庞大的游戏市场，以建 立使用者基础。但 CUDA 的成本非常高，Nvidia 的利润在多年来遭受巨大的打击，我们的市值仅仅维持在 10 亿美元上下。我们多年的低迷表现，让股 东们对 CUDA 持怀疑态度，并希望我们专注于提高盈利能力。</p>
<p>但我们坚持下来，我们相信加速运算的时代将会到来，我们创建了一个名为GTC 的会议，并在全球不辞辛劳的推广 CUDA 技术。然后 CT 重建、分子动力学、粒子物理学、流体动力学和图像处理等应用程式开始大量出现，我们的开发人员撰写算法，并加快了晶片运算速度。</p>
<p>2014 年，Alex 在我们的 GPU 上进行了训练，开启 AI 的大爆炸，幸运的是，我们意识到了深度学习的潜力，我们冒着一切风险去追求深度学习。多年后，AI 革命开始了，Nvidia 成为了推动引擎。我们为 AI 发明了 CUDA，这个旅程锻造了我们的品格，承受痛苦和苦难，是在追求愿景的路上必经之痛。</p>
<h2 id="学会放弃是迈向成功的核心关键"><a href="#学会放弃是迈向成功的核心关键" class="headerlink" title="学会放弃是迈向成功的核心关键"></a>学会放弃是迈向成功的核心关键</h2><p>再讲一个故事，在 2010 年，Google 将 Android 系统打造成出色图形的平台，而手机行业也有调制解调器的晶片公司。Nvidia 优秀的运算能力，让 Nvidia成为 Android 系统良好的合作伙伴。我们取得成功、股价飙升，但竞争对手也很快就涌入，调制解调器制造商们也在学习如何生产运算晶片，而我们却在学习调制解调器。</p>
<p>因为手机市场庞大，我们能抢占市占率。然而，我们却做出艰难的决定，放弃这块市场。因为 Nvidia 的使命，是创造出能解决“普通电脑解决的问题” 的电脑，我们应该专注在愿景上，发挥我们的独特贡献。</p>
<p>我们的放弃获得了回报，我们创造了一个新的市场——机器人技术，拥有神经网路处理器和运行 AI 算法的安全架构。</p>
<p>当时，这还是个看不见规模的市场。从巨大的从手机市场撤退，再创造一个不知道市场规模的机器人市场。然而，现在的我们拥有数十亿美元的自动驾驶、机器人技术的事业，也开创一个新的产业。</p>
<p>“撤退”对像你们如此聪明且成功的人来说并不容易。然而，战略性的撤退、牺牲、决定放弃什么是成功的核心，非常关键的核心。</p>
<p>跑吧！无论如何都要保持着奔跑</p>
<p>2023 年毕业的同学们，你们即将进入一个正在经历巨大变革的世界，就像我毕业时遇到个人电脑和晶片革命时一样，你们正处于 AI 的起跑线上。每个行业都将被革命、重生，为新思想做好准备 - 你们的思想。</p>
<p>在 40 年的时间里，我们创造了个人电脑、网路、移动设备、云端技术。现在的 AI 时代，你们将创造什么？</p>
<blockquote>
<p>无论是什么，像我们一样全力以赴去追求它，跑吧！不要慢慢走。</p>
<p>不论是为了食物而奔跑，或不被他人当做食物而奔跑。你往往无法知道自己正处在哪一种情况，但无论如何，都要保持奔跑。</p>
</blockquote>
<p>在你的旅程中，带上一些我犯过的错、有过的经验。希望你们能谦卑的面对失败，承认错误并寻求帮助。你们将承受实现梦想所需的痛苦和苦难，并做出牺牲，致力于有意义的生活，冲刺你们人生的事业。</p>
<p>2023 年毕业的同学们，我致以衷心向你们每一位祝贺。</p>
<p>加油！</p>
<hr>
<p>Ladies and gentlemen, esteemed faculty members, distinguished guests, proud parents, and above all, the 2023 graduating class of the National Taiwan University. Today is a very special day for you, and a dream come true for your parents.</p>
<p>You should be moving out soon. It is surely a day of pride and joy. So, your parents have made sacrifices to see you on this day. My parents are here, and so is my brother. Let’s show all of our parents and our grandparents, many of them are here, our appreciation.</p>
<p>I came to NTU for the first time over a decade ago. Dr. Chen invited me to visit his computational physics lab. As I recall, his son, based in Silicon Valley, had learned of NVIDIA’s CUDA invention and recommended his father utilize it for his quantum physics simulations.</p>
<p>When I arrived, he opened the door to show me what he had made. NVIDIA GeForce gaming cards filled the room, plugged into open PC motherboards, and sitting on metal shelves in the aisles were oscillating platform fans.</p>
<p>Dr. Chen had built a homemade supercomputer, the Taiwanese Way, out of gaming graphics cards. He started here, an early example of NVIDIA’s journey.<br>He was so proud, and he said to me, Mr. Huang, because of your work, I can do my life’s work. Those words touch me to this day, and perfectly capture our company’s purpose, to help the Einstein and Da Vinci of our time do their life’s work.</p>
<p>I am so happy to be back at NTU, and to be your commencement address. The world was simpler when I graduated from Oregon State University. TVs were not flat yet. There was no cable television, and MTV.</p>
<p>And the words mobile and phone didn’t go together. The year was 1984. The IBM PC-AT and Apple Macintosh launched the PC revolution.</p>
<p>And started the chip and software industry that we know today. You enter a far more complex world, with geopolitical, social, and environmental changes and challenges.</p>
<p>Surrounded by technology, we are now perpetually connected, and immersed in a digital world that parallels our real world. Cars are starting to drive by themselves.</p>
<p>AI will create new jobs that didn’t exist before</p>
<p>Forty years after the computer industry created the home PC, we invented artificial intelligence. Like software that automatically drives a car, or studies x-ray images, AI software has opened the door for computers to automate tasks for the world’s largest, multi-trillion dollars of industries.</p>
<p>Healthcare, financial services, transportation, and manufacturing. AI has opened immense opportunities.</p>
<p>Agile companies will take advantage of AI, and boost their position. Companies less so, will perish. Entrepreneurs, many of them here today, will start new companies.</p>
<p>And like in every computing era before, create new industries. AI will create new jobs that didn’t exist before. Like data engineering, prompt engineering, AI factory operations, and AI safety engineers.</p>
<p>These are jobs that never existed before. Automated tasks will obsolete some jobs. And for sure, AI will change every job. Supercharging the performance of programmers, designers, artists, marketers, and manufacturing planners.</p>
<p>Just as every generation before you embraced technologies to succeed, every company, and you, must learn to take advantage of AI. And do amazing things with an AI co-pilot by your side.</p>
<p>While some worry that AI may take their jobs, someone who expert with AI will. We are at the beginning of a major technology era, like PC, internet, mobile, and cloud. But AI is far more fundamental because every computing layer has been reinvented, from how we write software to how it’s processed.</p>
<p>AI has reinvented computing from the ground up. In every way, this is a rebirth of the computer industry. And a golden opportunity for the companies of Taiwan.</p>
<p>You are the foundation and bedrock of the computer industry. Within the next decade, our industry will replace over a trillion dollars of the world’s traditional computers with new, accelerated AI computers.</p>
<p>My journey started 40 years before yours. 1984 was a perfect year to graduate. I predict that 2023 will be as well.</p>
<p>What can I tell you as you begin your journey? Today is the most successful day of your life so far. You’re graduating from the National Taiwan University. I was also successful until I started NVIDIA.</p>
<p>At NVIDIA, I experienced failures. Great big ones. All humiliating and embarrassing. Many nearly doomed us.</p>
<p>Let me tell you three NVIDIA stories that define us today.</p>
<h2 id="The-first-story-of-NVIDIA-Confronting-mistakes-and-asking-for-help"><a href="#The-first-story-of-NVIDIA-Confronting-mistakes-and-asking-for-help" class="headerlink" title="The first story of NVIDIA: Confronting mistakes and asking for help"></a>The first story of NVIDIA: Confronting mistakes and asking for help</h2><p>We founded NVIDIA to create accelerated computing. Our first application was 3D graphics for PC gaming.</p>
<p>We invented an unconventional 3D approach called forward texture mapping and curves. Our approach was substantially lower cost. We won a contract with SEGA to build their game console, which attracted games for our platform and funded our company.</p>
<p>After one year of development, we realized our architecture was the wrong strategy. It was technically poor. And Microsoft was about to announce Windows 95 Direct 3D based on inverse texture mapping and triangles.</p>
<p>Many companies were already working on 3D chips to support this standard. If we completed SEGA’s game console, we would have built inferior technology, be incompatible with Windows, and be too far behind to catch up.</p>
<p>But we would be out of money if we didn’t finish the contract. Either way, we would be out of business. I contacted the CEO of SEGA and explained that our invention was the wrong approach.</p>
<p>That SEGA should find another partner. And that we could not complete the contract and the console. We had to stop. But I needed Sega to pay us in whole. Or NVIDIA would be out of business.</p>
<p>I was embarrassed to ask. Irimajiri-san, the CEO of SEGA, to his credit and my amazement, agreed.</p>
<p>His understanding and generosity gave us six months to live. With that, we built RIVA 128. Just as we were running out of money. RIVA 128 shocked the young 3D market, put us on the map, and saved the company.</p>
<p>The strong demand for our chip led me back to Taiwan after leaving at the age of four to meet Morris Chang at TSMC and started a partnership that has lasted 25 years. Confronting our mistake and with humility asking for help, save NVIDIA.</p>
<p>These traits are the hardest for the brightest and most successful like yourself.</p>
<h2 id="The-second-story-of-NVIDIA-Endure-pain-and-suffering-needed-to-realize-your-dreams"><a href="#The-second-story-of-NVIDIA-Endure-pain-and-suffering-needed-to-realize-your-dreams" class="headerlink" title="The second story of NVIDIA: Endure pain and suffering needed to realize your dreams"></a>The second story of NVIDIA: Endure pain and suffering needed to realize your dreams</h2><p>In 2007, we announced CUDA GPU Accelerated Computing. Our aspiration was for CUDA to become a programming model that boosts applications from scientific computing and physics simulations to image processing. Creating a new computing model is incredibly hard and rarely done in history.</p>
<p>The CPU computing model has been the standard for 60 years since the IBM System 360. CUDA needed developers to write applications and demonstrate the benefits of the GPU.</p>
<p>Developers needed a large installed base. A large CUDA installed base needed customers buying new applications. To solve the chicken or the egg problem, we used GeForce, our gaming GPU, which already had a large market of gamers, to build the installed base.</p>
<p>But the added cost of CUDA was very high. NVIDIA’s profits took a huge hit for many years. Our market cap hovered just above $1 billion.<br>We suffered many years of poor performance. Our shareholders were skeptical of CUDA. And preferred we focused on improving profitability. But we persevered.</p>
<p>We believed a time for accelerated computing would come. We created a conference called GTC and promoted CUDA tirelessly worldwide. Then the applications came.</p>
<p>Seismic processing, CT reconstruction, molecular dynamics, particle physics, fluid dynamics, and image processing. One science domain after another, they came.</p>
<p>We worked with each developer to write their algorithms and achieved incredible speedups. Then, in 2012, AI researchers discovered CUDA.</p>
<p>The famous AlexNet trained on GeForce GTX 580 started the Big Bang of AI. Fortunately, we realized the potential of deep learning as a whole new software approach. And turned every aspect of our company to advance this new field.</p>
<p>We risked everything to pursue deep learning. A decade later, the AI revolution started. And NVIDIA is the engine of AI developers worldwide.</p>
<p>We invented CUDA and pioneered accelerated computing and AI. But the journey forged our corporate character to endure the pain and suffering that is always needed to realize a vision.</p>
<h2 id="The-third-story-of-NVIDIA-Strategic-retreat"><a href="#The-third-story-of-NVIDIA-Strategic-retreat" class="headerlink" title="The third story of NVIDIA: Strategic retreat"></a>The third story of NVIDIA: Strategic retreat</h2><p>One more story. In 2010, Google aimed to develop Android into a mobile computer with excellent graphics.</p>
<p>The phone industry had chip companies with modem expertise. NVIDIA’s computing and graphics expertise made us an ideal partner to help build Android. So we entered the mobile chip market.</p>
<p>We were instantly successful. And our business and stock price surged. The competition quickly swarmed. Modem chip makers were learning how to build computing chips. And we were learning how to build modems.</p>
<p>The phone market is huge. We could fight for share. Instead, we made a hard decision and sacrificed the market.</p>
<p>NVIDIA’s mission is to build computers to solve problems that ordinary computers cannot. We should dedicate ourselves to realizing our vision and to making a unique contribution.</p>
<p>Our strategic retreat paid off. By leaving the phone market, we opened our minds to invent a new one. We imagined creating a new type of computer for robotic computers.With neural network processor, safety architectures that run AI algorithms.</p>
<p>At the time, this was a zero billion dollar market. To retreat from a giant phone market to create a zero billion dollar robotics market. We now have billions of dollars of automotive and robotics business and started a new industry. Retreat does not come easily to the brightest and most successful people like yourself.</p>
<p>Yet, strategic retreat, sacrifice, deciding what to give up, is that a core, the very core of success?</p>
<p>Class of 2023, you’re about to go into a world witnessing great change. And just as I was with the PC and chip revolution, you’re at the beginning, at the starting line of AI. Every industry will be revolutionized. Reborn.</p>
<p>Ready for new ideas. Your ideas. In 40 years, we created the PC, internet, mobile, cloud, and now the AI era.</p>
<p>What will you create? Whatever it is, run after it like we did. Run. Don’t walk. Remember, either you’re running for food, or you are running from being food.</p>
<p>I hope that part can be translated into Chinese so that everyone can understand.</p>
<blockquote>
<p>Either you’re running for food, or you are running from becoming food.</p>
</blockquote>
<p>And oftentimes, you can’t tell which. Either way, run. And for your journey, take along some of my learnings. That you will have the humility to confront failure, admit a mistake, and ask for help.</p>
<p>You will endure pain and suffering needed to realize your dreams. And you will make sacrifices to dedicate yourself to a life of purpose and doing your life’s work.</p>
<p>Class of 2023, I extend my heartfelt congratulations to each one of you. jiayou!</p>
]]></content>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>相册</title>
    <url>/album/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/json/music.json</url>
    <content><![CDATA[[{"name":"大喜","artist":"泠鸢yousa","url":"http://192.168.1.11:5244/d/%E9%9F%B3%E4%B9%90/%E5%A4%A7%E5%96%9C%20-%20%E6%B3%A0%E9%B8%A2yousa%26%E9%9F%B3%E9%98%99%E8%AF%97%E5%90%AC.flac","cover":"https://y.qq.com/music/photo_new/T002R300x300M000003MNOTS3FmvaO_1.jpg?max_age=2592000","lrc":"http://192.168.1.11:5244/d/%E9%9F%B3%E4%B9%90/%E5%A4%A7%E5%96%9C%20-%20%E6%B3%A0%E9%B8%A2yousa%E3%80%81%E9%9F%B3%E9%98%99%E8%AF%97%E5%90%AC.lrc"}]]]></content>
  </entry>
  <entry>
    <title>原神·精选</title>
    <url>/genshinimg/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>音乐馆</title>
    <url>/music/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>说说</title>
    <url>/essay/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>风景</title>
    <url>/worldScenery/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>泠鸢yousa</title>
    <url>/yousaimg/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
